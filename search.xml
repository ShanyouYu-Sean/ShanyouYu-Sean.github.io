<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Java模块化系统快速入门指南]]></title>
      <url>/2018/03/29/java9-quickguide/</url>
      <content type="html"><![CDATA[<h2 id="Project-Jigsaw-java-模块系统快速上手-原文地址"><a href="#Project-Jigsaw-java-模块系统快速上手-原文地址" class="headerlink" title="Project Jigsaw: java 模块系统快速上手(原文地址)"></a>Project Jigsaw: java 模块系统快速上手(<a href="http://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener">原文地址</a>)</h2><p>本文档提供了一些让开发者快速上手Java模块系统的简单例子。<br>例子中的文件路径用/划分，文件分隔符是：，windows开发者请用\和；替换以上分隔符。</p>
<h3 id="Greetings"><a href="#Greetings" class="headerlink" title="Greetings"></a>Greetings</h3><p>第一个例子展示了一个打印”Greetings!”字符串的简单模块。这个模块由两个源文件组成（module-info.java和Main.java）。按照惯例，模块的源文件应该在一个以模块名字为命名的目录中。</p>
<pre><code>    src/com.greetings/com/greetings/Main.java
    src/com.greetings/module-info.java

    $ cat src/com.greetings/module-info.java
    module com.greetings { }

    $ cat src/com.greetings/com/greetings/Main.java
    package com.greetings;
    public class Main {
        public static void main(String[] args) {
            System.out.println(&quot;Greetings!&quot;);
        }
    }
</code></pre><p>以下命令会讲源文件编译到mods/com.greetings目录中：</p>
<pre><code>    $ mkdir -p mods/com.greetings

    $ javac -d mods/com.greetings \
        src/com.greetings/module-info.java \
        src/com.greetings/com/greetings/Main.java
</code></pre><p>现在我们用以下命令来运行这个例子：</p>
<pre><code>    $ java --module-path mods -m com.greetings/com.greetings.Main
</code></pre><p>–module-path 是模块的路径，他的值是包含模块的一个或多个目录。<br>-m 指定了主模块，/后面的值是模块里包含main方法的全类名。</p>
<h3 id="Greetings-world"><a href="#Greetings-world" class="headerlink" title="Greetings world"></a>Greetings world</h3><p>第二个例子更新了第一个例子中的模块声明，它声明了需要一个名为org.astro的模块的依赖<br>模块org.astro导出了名为org.astro的api包。</p>
<pre><code>    src/org.astro/module-info.java
    src/org.astro/org/astro/World.java
    src/com.greetings/com/greetings/Main.java
    src/com.greetings/module-info.java

    $ cat src/org.astro/module-info.java
    module org.astro {
        exports org.astro;
    }

    $ cat src/org.astro/org/astro/World.java
    package org.astro;
    public class World {
        public static String name() {
            return &quot;world&quot;;
        }
    }

    $ cat src/com.greetings/module-info.java
    module com.greetings {
        requires org.astro;
    }

    $ cat src/com.greetings/com/greetings/Main.java
    package com.greetings;
    import org.astro.World;
    public class Main {
        public static void main(String[] args) {
            System.out.format(&quot;Greetings %s!%n&quot;, World.name());
        }
    }
</code></pre><p>依次编译这两个模块，用javac命令在编译com.greetings模块时指定模块的路径，使得org.astro模块中的引用和其导出包中的类型可以被引用。</p>
<pre><code>    $ mkdir -p mods/org.astro mods/com.greetings

    $ javac -d mods/org.astro \
        src/org.astro/module-info.java src/org.astro/org/astro/World.java

    $ javac --module-path mods -d mods/com.greetings \
        src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
</code></pre><p>使用与第一个例子相同的方式来运行这个例子：</p>
<pre><code>    $ java --module-path mods -m com.greetings/com.greetings.Main
    Greetings world!
</code></pre><h3 id="多模块编译"><a href="#多模块编译" class="headerlink" title="多模块编译"></a>多模块编译</h3><p>在上面的例子中，模块com.greetings和模块org.astro是分开编译的，我们也可以用一条javac命令来编译多个模块</p>
<pre><code>    $ mkdir mods

    $ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)

    $ find mods -type f
    mods/com.greetings/com/greetings/Main.class
    mods/com.greetings/module-info.class
    mods/org.astro/module-info.class
    mods/org.astro/org/astro/World.class
</code></pre><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在目前的实例中，编译好的模块都分散在文件系统中，为了调度和部署，我们通常会把模块打包成模块化jar包，模块化jar包就是在jar包最顶层目录包含module-info.class的普通jar包。</p>
<p>以下命令将会在mlib目录中创建org.astro@1.0.jar和com.greetings.jar</p>
<pre><code>    $ mkdir mlib

    $ jar --create --file=mlib/org.astro@1.0.jar \
        --module-version=1.0 -C mods/org.astro .

    $ jar --create --file=mlib/com.greetings.jar \
        --main-class=com.greetings.Main -C mods/com.greetings .

    $ ls mlib
    com.greetings.jar   org.astro@1.0.jar
</code></pre><p>在这个例子中，模块org.astro在打包时被指定了其版本号1.0，模块com.greetings在打包时被制定了其main方法主类com.greetings.Main。</p>
<p>现在，我们可以直接运行模块com.greetings而无需制定其main class</p>
<pre><code>    $ java -p mlib -m com.greetings
    Greetings world!
</code></pre><p>命令可以用-p来替代–module-path。</p>
<p>jar命令拥有许多新选项，其中一个就是打印模块化jar包中声明的模块。</p>
<pre><code>    $ jar --describe-module --file=mlib/org.astro@1.0.jar
    org.astro@1.0 jar:file:///d/mlib/org.astro@1.0.jar/!module-info.class
    exports org.astro
    requires java.base mandated
</code></pre><h3 id="缺少requires或者exports关键字"><a href="#缺少requires或者exports关键字" class="headerlink" title="缺少requires或者exports关键字"></a>缺少requires或者exports关键字</h3><p>如果我们在com.greetings模块中遗漏了requires关键字：</p>
<pre><code>    $ cat src/com.greetings/module-info.java
    module com.greetings {
        // requires org.astro;
    }

    $ javac --module-path mods -d mods/com.greetings \
        src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
    src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
        import org.astro.World;
                  ^
      (package org.astro is declared in module org.astro, but module com.greetings does not read it)
    1 error
</code></pre><p>如果我们在org.astro模块中遗漏了exports关键字：</p>
<pre><code>    $ cat src/com.greetings/module-info.java
    module com.greetings {
        requires org.astro;
    }
    $ cat src/org.astro/module-info.java
    module org.astro {
        // exports org.astro;
    }

    $ javac --module-path mods -d mods/com.greetings \
        src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
    $ javac --module-path mods -d mods/com.greetings \
       src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
    src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
        import org.astro.World;
                  ^
      (package org.astro is declared in module org.astro, which does not export it)
    1 error
</code></pre><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务允许服务提供者和服务消费者中建立松散的耦合结构。在这个例子中，存在这一个服务提供者和一个服务消费者：模块com.socket提供了API用来做network socket；模块org.fastsocket是一个服务提供模块，它提供了com.socket.spi.NetworkSocketProvider的实现，并且不导出任何包。</p>
<p>下面是模块com.socket的代码：</p>
<pre><code>    $ cat src/com.socket/module-info.java
    module com.socket {
        exports com.socket;
        exports com.socket.spi;
        uses com.socket.spi.NetworkSocketProvider;
    }

    $ cat src/com.socket/com/socket/NetworkSocket.java
    package com.socket;

    import java.io.Closeable;
    import java.util.Iterator;
    import java.util.ServiceLoader;

    import com.socket.spi.NetworkSocketProvider;

    public abstract class NetworkSocket implements Closeable {
        protected NetworkSocket() { }

        public static NetworkSocket open() {
            ServiceLoader&lt;NetworkSocketProvider&gt; sl
                = ServiceLoader.load(NetworkSocketProvider.class);
            Iterator&lt;NetworkSocketProvider&gt; iter = sl.iterator();
            if (!iter.hasNext())
                throw new RuntimeException(&quot;No service providers found!&quot;);
            NetworkSocketProvider provider = iter.next();
            return provider.openNetworkSocket();
        }
    }


    $ cat src/com.socket/com/socket/spi/NetworkSocketProvider.java
    package com.socket.spi;

    import com.socket.NetworkSocket;

    public abstract class NetworkSocketProvider {
        protected NetworkSocketProvider() { }

        public abstract NetworkSocket openNetworkSocket();
    }
</code></pre><p>以下是模块org.fastsocket的代码</p>
<pre><code>    $ cat src/org.fastsocket/module-info.java
    module org.fastsocket {
        requires com.socket;
        provides com.socket.spi.NetworkSocketProvider
            with org.fastsocket.FastNetworkSocketProvider;
    }

    $ cat src/org.fastsocket/org/fastsocket/FastNetworkSocketProvider.java
    package org.fastsocket;

    import com.socket.NetworkSocket;
    import com.socket.spi.NetworkSocketProvider;

    public class FastNetworkSocketProvider extends NetworkSocketProvider {
        public FastNetworkSocketProvider() { }

        @Override
        public NetworkSocket openNetworkSocket() {
            return new FastNetworkSocket();
        }
    }

    $ cat src/org.fastsocket/org/fastsocket/FastNetworkSocket.java
    package org.fastsocket;

    import com.socket.NetworkSocket;

    class FastNetworkSocket extends NetworkSocket {
        FastNetworkSocket() { }
        public void close() { }
    }
</code></pre><p>为了简单化，我们同时编译两个模块，但事实上，服务提供者和服务消费者几乎总是分开编译的</p>
<pre><code>    $ mkdir mods
    $ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)
</code></pre><p>最后我们对模块com.greetings用新的模块的api做更改</p>
<pre><code>    $ cat src/com.greetings/module-info.java
    module com.greetings {
        requires com.socket;
    }

    $ cat src/com.greetings/com/greetings/Main.java
    package com.greetings;

    import com.socket.NetworkSocket;

    public class Main {
        public static void main(String[] args) {
            NetworkSocket s = NetworkSocket.open();
            System.out.println(s.getClass());
        }
    }


    $ javac -d mods/com.greetings/ -p mods $(find src/com.greetings/ -name &quot;*.java&quot;)
</code></pre><p>最后，我们运行com.greetings模块</p>
<pre><code>    $ java -p mods -m com.greetings/com.greetings.Main
    class org.fastsocket.FastNetworkSocket
</code></pre><p>输出结果确认服务提供者已经被定位成功。</p>
<h3 id="The-linker"><a href="#The-linker" class="headerlink" title="The linker"></a>The linker</h3><p>jlink是一个用来在一组拥有传递性依赖的模块之中，建立一个自定义的模块化可运行镜像的工具。</p>
<p>此工具目前需要制定模块路径的模块化jar包或者jmod格式。jdk会将标准的或jdk指定的模块以jmod格式打包。</p>
<p>以下命令会创建一个包含模块com.greetings和其传递性依赖的可运行镜像。</p>
<pre><code>    jlink --module-path $JAVA_HOME/jmods:mlib --add-modules com.greetings --output greetingsapp
</code></pre><p>–module-path的值是包含打包后的模块的路径。在windows下需要将’:’替换成’;’。<br>$JAVA_HOME/jmods是包含java.base.jmod和其他标准化jdk模块的路径。mlib路径包含模块com.greetings的artifact。</p>
<p>jlink工具也包含许多高级的选项来自定义镜像，详见jlink –help</p>
<h3 id="–patch-module"><a href="#–patch-module" class="headerlink" title="–patch-module"></a>–patch-module</h3><p>开发者常会从Doug Lea的CVS中checkout出java.util.concurrent下的类并用-Xbootclasspath/p来替换源文件编译。(我都不知道Doug Lea还在更新juc的代码，膜拜大神)</p>
<p>现在-Xbootclasspath/p已经被舍弃，它在模块化系统中替代是–patch-module，用来替换模块中的类，它也可以被用来增大模块的内容。</p>
<p>javac命令同样也支持–patch-module选项用来编译模块中的as if部分。</p>
<p>以下是用新版本的java.util.concurrent.ConcurrentHashMap来编译并用其运行的例子</p>
<pre><code>    javac --patch-module java.base=src -d mypatches/java.base \
        src/java.base/java/util/concurrent/ConcurrentHashMap.java

    java --patch-module java.base=mypatches/java.base ...
</code></pre>]]></content>
      
        <categories>
            
            <category> Java 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[也来谈谈classloader和classpath hell问题]]></title>
      <url>/2018/01/11/classloader&amp;classpath-hell/</url>
      <content type="html"><![CDATA[<p>classpath hell, 也叫 <a href="https://en.wikipedia.org/wiki/Java_Classloader#JAR_hell" target="_blank" rel="noopener">jar hell</a>。<br>先来简单翻译一下wiki：<br>Java Classloader 是 Java Runtime Environment 的一部分，它动态地将 Java 类加载到 jvm 中。类通常是按需加载的（即只有在需要实例化这个类时才会被加载）。因为有了 classloader 的存在，java runtime 不再需要知道有哪些文件。一个 java 类通常只会被加载一次。<br>当jvm启动时，会用到三个 classloader：</p>
<ol>
<li>Bootstrap class loader</li>
<li>Extensions class loader</li>
<li>System class loader</li>
</ol>
<p>bootstrap class loader是 jvm 的一部分，会加载 <java_home>/jre/lib 下的所有类。</java_home></p>
]]></content>
      
        <categories>
            
            <category> Java 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> classLader </tag>
            
            <tag> classPath Hell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
    
  
</search>
