<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[OAuth教程--访问令牌]]></title>
      <url>/2018/07/13/oauth-guide-12/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>访问令牌是应用程序用于代表用户发出API请求的内容。访问令牌表示特定应用程序访问用户数据的特定部分的授权。</p>
<p>访问令牌必须在运输和存储过程中保密。应该看到访问令牌的唯一方是应用程序本身，授权服务器和资源服务器。应用程序应确保同一设备上的其他应用程序无法访问访问令牌的存储。访问令牌只能在https连接上使用，因为通过非加密通道传递它会使第三方拦截变得非常容易。</p>
<p>令牌endpoint是应用程序发出请求以获取用户访问令牌的位置。本节介绍如何验证令牌请求以及如何返回相应的响应和错误。</p>
<h3 id="授权码请求"><a href="#授权码请求" class="headerlink" title="授权码请求"></a>授权码请求</h3><p>当应用试图交换访问令牌时，将使用授权码交换授予。用户通过重定向URL返回应用程序后，应用程序将从URL获取授权码并使用它来请求访问令牌。此请求将发送到令牌endpoint。</p>
<p>####请求参数</p>
<p>访问令牌请求将包含以下参数。</p>
<blockquote>
<p><strong>grant_type （需要）</strong><br>grant_type参数必须设置为“authorization_code”。</p>
<p><strong>code （需要）</strong><br>code参数是客户端先前从授权服务器接收的授权码。</p>
<p><strong>redirect_uri （可能需要）</strong><br>如果重定向URI包含在初始授权请求中，则服务也必须在令牌请求中要求它。令牌请求中的重定向URI必须与生成授权代码时使用的重定向URI完全匹配。 否则服务必须拒绝该请求。</p>
<p><strong>client_id （如果不存在其他客户端身份验证，则需要）</strong><br>如果客户端通过HTTP Basic Auth或其他方法进行身份验证，则不需要此参数。否则，此参数是必需的。</p>
</blockquote>
<p>如果客户端发出了客户端密钥，则服务器必须对客户端进行身份验证。验证客户端的一种方法是接受此请求中的另一个参数client_secret。或者，授权服务器可以使用HTTP Basic Auth。从技术上讲，规范允许授权服务器支持任何形式的客户端身份验证，甚至提到公钥/私钥对作为选项。但实际上，大多数服务器都支持使用此处提到的方法之一或两者共同来验证客户端的简单方法。</p>
<h4 id="验证授权码"><a href="#验证授权码" class="headerlink" title="验证授权码"></a>验证授权码</h4><p>在检查所有必需参数并在客户端被发出秘钥时验证客户端之后，授权服务器可以继续验证请求的其他部分。</p>
<p>然后，服务器检查授权码是否有效，并且尚未过期。然后，该服务必须验证请求中提供的授权码是否已发送给所标识的客户端。最后，服务必须确保存的重定向URI参数与用于请求授权代码的重定向URI匹配。</p>
<p>如果所有内容都检出，该服务可以生成访问令牌并进行响应。</p>
<p>例<br>以下示例显示了私密客户端的授权授予请求。</p>
<pre><code class="bash">POST /oauth/token HTTP/1.1
Host: authorization-server.com

grant_type=authorization_code
&amp;code=xxxxxxxxxxx
&amp;redirect_uri=https://example-app.com/redirect
&amp;client_id=xxxxxxxxxx
&amp;client_secret=xxxxxxxxxx
</code></pre>
<h4 id="安全考虑因素"><a href="#安全考虑因素" class="headerlink" title="安全考虑因素"></a>安全考虑因素</h4><h5 id="防止重复攻击"><a href="#防止重复攻击" class="headerlink" title="防止重复攻击"></a>防止重复攻击</h5><p>如果多次使用授权码，授权服务器必须拒绝后续请求。授权码存储在数据库中是很容易实现，因为它们可以简单地标记为已使用。</p>
<p>如果要实现自编码授权码（如我们的示例代码中所示），则需要跟踪已在令牌生命周期中使用的令牌。一种方法是通过生命周期之内，将授权码缓存在缓存中来实现此目的（具有过期时间的缓存）。这样在验证时，我们可以通过检查授权码的缓存来检查它们是否已被使用。一旦授权码到达其到期日期，它将不再在缓存中，但我们可以根据到期日期拒绝它。</p>
<p>如果授权码被多次使用，则应将其视为攻击。如果可能，服务应撤销此授权码发出的先前访问令牌。</p>
<h3 id="密码授予"><a href="#密码授予" class="headerlink" title="密码授予"></a>密码授予</h3><p>当应用程序交换用户的访问令牌的用户名和密码时，将使用密码授予。这正是首先要创建的OAuth，因此您绝不允许第三方应用使用此授权。</p>
<p>此授权类型的常见用途是用您的服务为应用启用密码登录。用户使用他们的用户名和密码登录来登录网站或原生应用程序，但绝不允许第三方应用程序直接询问用户的密码。</p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>访问令牌请求将包含以下参数。</p>
<blockquote>
<p><strong>grant_type（必填）</strong> - grant_type参数必须设置为“password”。<br><strong>username （必填）</strong> - 用户的用户名。<br><strong>password （必填）</strong> - 用户的密码。<br><strong>scope （可选）</strong> - 应用程序请求的范围。<br><strong>客户端身份验证</strong>（如果客户端被授予秘钥，则需要）</p>
</blockquote>
<p>如果客户端被授予秘钥，则必须验证此请求。通常，服务将允许其他请求参数如client_id和client_secret，或接受在HTTP Basic auth header中的客户端ID和秘钥。</p>
<p>例<br>以下是服务将接收的示例密码授予。</p>
<pre><code class="bash">POST /oauth/token HTTP/1.1
Host: authorization-server.com

grant_type=password
&amp;username=user@example.com
&amp;password=1234luggage
&amp;client_id=xxxxxxxxxx
&amp;client_secret=xxxxxxxxxx
</code></pre>
<h3 id="客户端凭据"><a href="#客户端凭据" class="headerlink" title="客户端凭据"></a>客户端凭据</h3><p>当应用程序请求访问令牌来访问其自己的资源，而不是代表用户访问他们的资源时，将使用客户端凭据授予。</p>
<h4 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h4><blockquote>
<p><strong>grant_type （需要）</strong><br>grant_type参数必须设置为client_credentials。</p>
<p><strong>scope （可选的）</strong><br>您的服务可以支持客户端凭据授予的不同范围。实际上，实际上并没有多少服务支持这一点。</p>
<p><strong>客户端验证（必填）</strong><br>客户端需要为此请求进行身份验证。通常，服务将接受请求参数client_id和client_secret，或接受在HTTP Basic auth header中的客户端ID和秘钥。</p>
</blockquote>
<p>例<br>以下是客户端凭据的请求例子。</p>
<pre><code class="bash">POST /token HTTP/1.1
Host: authorization-server.com

grant_type=client_credentials
&amp;client_id=xxxxxxxxxx
&amp;client_secret=xxxxxxxxxx
</code></pre>
<h3 id="访问令牌响应"><a href="#访问令牌响应" class="headerlink" title="访问令牌响应"></a>访问令牌响应</h3><h4 id="响应成功"><a href="#响应成功" class="headerlink" title="响应成功"></a>响应成功</h4><p>如果访问令牌的请求有效，则授权服务器需要生成访问令牌（和可选的刷新令牌）并将这些令牌返回给客户端，通常还有一些有关授权的其他属性。</p>
<p>具有访问令牌的响应应包含以下属性：</p>
<blockquote>
<p><strong>access_token （必需）</strong> 授权服务器发出的访问令牌字符串。<br><strong>token_type （必需）</strong> 这是令牌的类型，通常只是字符串“bearer”。<br><strong>expires_in （推荐）</strong> 如果访问令牌会过期，服务器应回复授予访问令牌的持续时间。<br><strong>refresh_token（可选）</strong> 如果访问令牌会过期，则应该返回刷新令牌，应用程序可以使用该令牌来获取新的访问令牌。但是，使用隐式授权发出的令牌无法发出刷新令牌。<br><strong>scope（可选）</strong> 如果用户授予的范围与应用程序请求的范围相同，则此参数是可选的。如果授予的范围与请求的范围不同，例如，如果用户修改了范围，则此参数是必需的。</p>
</blockquote>
<p>使用访问令牌进行响应时，服务器还必须包含附加<code>Cache-Control: no-store</code>和<code>Pragma: no-cache</code>的HTTP header，以确保客户端不会缓存此请求。</p>
<p>例如，成功的令牌响应可能如下所示：</p>
<pre><code class="json">HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
  &quot;access_token&quot;:&quot;MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3&quot;,
  &quot;token_type&quot;:&quot;bearer&quot;,
  &quot;expires_in&quot;:3600,
  &quot;refresh_token&quot;:&quot;IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk&quot;,
  &quot;scope&quot;:&quot;create&quot;
}
</code></pre>
<p>####访问令牌</p>
<p>OAuth 2.0 Bearer Token的格式实际上是在单独的规范<a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">RFC 6750</a>中描述的。规范要求的令牌没有已定义的结构，因此您可以生成任意字符串并实现所需的令牌。令牌中的有效字符是字母数字，和标点字符：-._~+/</p>
<p>通常，服务将生成随机字符串并将其与相关的用户和范围信息一起存储在数据库中，或者将使用自编码令牌，其中令牌字符串本身包含所有必要的信息。</p>
<h4 id="响应失败"><a href="#响应失败" class="headerlink" title="响应失败"></a>响应失败</h4><p>如果访问令牌请求无效，例如重定向URL与授权期间使用的URL不匹配，则服务器需要返回错误响应。</p>
<p>使用HTTP 400状态代码（除非另有说明）返回错误响应，带有<code>error</code>和<code>error_description</code>参数。该<code>error</code>参数将始终是下面列出的值之一。</p>
<blockquote>
<p><strong>invalid_request</strong> - 请求缺少参数，因此服务器无法继续执行请求。如果请求包含不受支持的参数或重复参数，也可能会返回此信息。<br><strong>invalid_client</strong> - 客户端身份验证失败，例如请求包含无效的客户端ID或秘钥。在这种情况下发送HTTP 401响应。<br><strong>invalid_grant</strong> - 授权码（或密码授予类型的用户密码）无效或已过期。或者授权中给出的重定向URL与此访问令牌请求中提供的URL不匹配，也将返回这个的错误。<br><strong>invalid_scope</strong> - 对于包含范围（密码或client_credentials授权）的访问令牌请求，此错误表示请求中的范围值无效。<br><strong>unauthorized_client</strong> - 此客户端无权使用请求的授权类型。例如，如果限制哪些应用程序可以使用隐式授权，则会为其他应用程序返回此错误。<br><strong>unsupported_grant_type</strong> - 如果请求授权服务器无法识别的授权类型，请使用此代码。请注意，未知的授权类型也使用此特定错误代码而不是使用invalid_request。</p>
</blockquote>
<p>返回错误响应时有两个可选参数，<code>error_description</code>和<code>error_uri</code>。这些旨在为开发人员提供有关错误的更多信息，而不是向最终用户显示。但是，请记住，无论您多么警告，许多开发人员都会将此错误文本直接传递给最终用户，因此最好确保它对最终用户至少有所帮助。</p>
<p>该<code>error_description</code>参数只能包含ASCII字符，最多应该是一两句话来描述错误的情况。这<code>error_uri</code>是链接到API文档的好地方，可以获取有关如何更正遇到的特定错误的信息。</p>
<p>整个错误响应作为JSON字符串返回，类似于成功响应。以下是错误响应的示例。</p>
<pre><code class="json">HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  &quot;error&quot;: &quot;invalid_request&quot;,
  &quot;error_description&quot;: &quot;Request was missing the &#39;redirect_uri&#39; parameter.&quot;,
  &quot;error_uri&quot;: &quot;See the full API docs at https://authorization-server.com/docs/access_token&quot;
}
</code></pre>
<h3 id="自编码访问令牌"><a href="#自编码访问令牌" class="headerlink" title="自编码访问令牌"></a>自编码访问令牌</h3><p>自编码令牌提供了一种通过编码令牌字符串中的所有必要信息来避免在数据库中存储令牌的方法。这样做的主要好处是API服务器能够在不对每个API请求进行数据库查找的情况下验证访问令牌，从而使API更容易扩展。</p>
<p>OAuth 2.0 Bearer Tokens的好处是应用程序无需了解服务中如何实现访问令牌。这意味着可以在不影响客户端的情况下更改令牌的实现规则。</p>
<p>如果您已经拥有可水平扩展的分布式数据库系统，那么使用自编码令牌可能无法获得任何好处。实际上，如果已经解决了分布式数据库问题，使用自编码令牌只会引入新问题，因为使自编码令牌失效会成为额外的障碍。</p>
<p>有许多方法可以自编码令牌。您选择的实际方法仅对您的实现很重要，因为令牌信息不会暴露给外部开发人员。</p>
<p>创建自编码标记的一种方法是创建序列化的json串来包含在token中的所有数据，并使用仅为您的服务器知道的密钥对结果字符串进行签名。</p>
<p>一种常见的技术是使用<a href="https://tools.ietf.org/html/rfc7515" target="_blank" rel="noopener">JSON Web Signature（JWS）</a>标准来处理令牌的编码，解码和验证。 <a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">JSON Web Token (JWT)</a>规范定义了一些字段，你可以在JWS中使用，或定义一些时间戳字段来确定令牌是否有效。我们将在此示例中使用JWT库，因为它提供了时间到期的内置处理。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>下面的代码是用PHP编写的，使用Firebase PHP-JWT库来编码和验证令牌。您需要包含该库才能运行示例代码</p>
<pre><code class="php">&lt;?php
use \Firebase\JWT\JWT;

# Define the secret key used to create and verify the signature
$jwt_key = &#39;secret&#39;;

# Set the user ID of the user this token is for
$user_id = 1000;

# Set the client ID of the app that is generating this token
$client_id = &#39;https://example-app.com&#39;;

# Provide the list of scopes this token is valid for
$scope = &#39;read write&#39;;

$token_data = array(

  # Subject (The user ID)
  &#39;sub&#39; =&gt; $user_id,

  # Issuer (the token endpoint)
  &#39;iss&#39; =&gt; &#39;https://&#39; . $_SERVER[&#39;PHP_SELF&#39;],

  # Client ID (this is a non-standard claim)
  &#39;cid&#39; =&gt; $client_id,

  # Issued At
  &#39;iat&#39; =&gt; time(),

  # Expires At
  &#39;exp&#39; =&gt; time()+7200, // Valid for 2 hours

  # The list of OAuth scopes this token includes
  &#39;scope&#39; =&gt; $scope
);
$token_string = JWT::encode($token_data, $jwt_key);
</code></pre>
<p>这将产生一个字符串，如：</p>
<pre><code class="jwt">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjEwMDAsI
mlzcyI6Imh0dHBzOi8vYXV0aG9yaXphdGlvbi1zZXJ2ZXIuY29tIiw
iY2lkIjoiaHR0cHM6Ly9leGFtcGxlLWFwcC5jb20iLCJpYXQiOjE0N
zAwMDI3MDMsImV4cCI6MTUyOTE3NDg1MSwic2NvcGUiOiJyZWFkIHd
yaXRlIn0.QiIrnmaC4VrbAYAsu0YPeuJ992p20fSxrXWPLw-gkFA
</code></pre>
<p>此令牌由三部分组成，以句点分隔。第一部分描述了使用的签名方法。第二部分包含令牌数据。第三部分是签名。</p>
<p>例如，此令牌的第一个部分是JSON对象：</p>
<pre><code class="json">{
   &quot;typ&quot;:&quot;JWT&quot;,
   &quot;alg&quot;:&quot;HS256”
}
</code></pre>
<p>第二个部分包含API端点处理请求所需的实际数据，例如用户标识和范围访问。</p>
<pre><code class="json">{
  &quot;sub&quot;: 1000,
  &quot;iss&quot;: &quot;https://authorization-server.com&quot;,
  &quot;cid&quot;: &quot;https://example-app.com&quot;,
  &quot;iat&quot;: 1470002703,
  &quot;exp&quot;: 1470009903,
  &quot;scope&quot;: &quot;read write&quot;
}
</code></pre>
<p>Base64编码前两个部分产生以下两个字符串：</p>
<pre><code class="jwt">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
</code></pre>
<pre><code class="jwt">eyJzdWIiOjEwMDAsImlzcyI6Imh0dHBzOi8vYXV0aG9yaXphdGlvbi1z
ZXJ2ZXIuY29tIiwiY2lkIjoiaHR0cHM6Ly9leGFtcGxlLWFwcC5jb20i
LCJpYXQiOjE0NzAwMDI3MDMsImV4cCI6MTUyOTE3NDg1MSwic2NvcGUi
OiJyZWFkIHdyaXRlIn0
</code></pre>
<p>然后我们计算两个字符串和秘钥的散列，从而产生另一个字符串：</p>
<pre><code class="jwt">QiIrnmaC4VrbAYAsu0YPeuJ992p20fSxrXWPLw-gkFA
</code></pre>
<p>最后，将所有三个字符串连接在一起，用句点分隔。</p>
<pre><code class="jwt">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjEwMDAsI
mlzcyI6Imh0dHBzOi8vYXV0aG9yaXphdGlvbi1zZXJ2ZXIuY29tIiw
iY2lkIjoiaHR0cHM6Ly9leGFtcGxlLWFwcC5jb20iLCJpYXQiOjE0N
zAwMDI3MDMsImV4cCI6MTUyOTE3NDg1MSwic2NvcGUiOiJyZWFkIHd
yaXRlIn0.QiIrnmaC4VrbAYAsu0YPeuJ992p20fSxrXWPLw-gkFA
</code></pre>
<h4 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h4><p>可以使用相同的JWT库来验证访问令牌。库将同时解码和验证签名，如果签名无效，或者令牌的过期日期已经过去，则会抛出异常。</p>
<p>注意：任何人都可以通过base64解码令牌信息来解码令牌字符串的中间部分。因此，您不要存储您不希望用户或开发人员在令牌中看到的私人信息或信息，这一点很重要。如果要隐藏令牌信息，可以使用JSON Web加密规范加密令牌中的数据。</p>
<pre><code class="php">try {
  # Note: You must provide the list of supported algorithms in order to prevent 
  # an attacker from bypassing the signature verification. See:
  # https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/
  $token = JWT::decode($token_string, $jwt_key, [&#39;HS256&#39;]);
  $error = false;
} catch(\Firebase\JWT\ExpiredException $e) {
  $token = false;
  $error = &#39;expired&#39;;
  $error_description = &#39;The token has expired&#39;;
} catch(\Firebase\JWT\SignatureInvalidException $e) {
  $token = false;
  $error = &#39;invalid&#39;;
  $error_description = &#39;The token provided was malformed&#39;;
} catch(Exception $e) {
  $token = false;
  $error = &#39;unauthorized&#39;;
  $error_description = $e-&gt;getMessage();
}

if($error) {
  header(&#39;HTTP/1.1 401 Unauthorized&#39;);
  echo json_encode(array(
    &#39;error&#39;=&gt;$error, 
    &#39;error_description&#39;=&gt;$error_description
  ));
  die();
} else {
  // Now $token has all the data that we encoded in it originally
  print_r($token);
}
</code></pre>
<p>此时，该服务具有所需的所有信息，例如可用的用户ID，范围等，并且不必进行数据库查找。接下来，它可以检查以确保访问令牌未过期，可以验证范围是否足以执行所请求的操作，然后可以处理该请求。</p>
<p>因为可以在不进行数据库查找的情况下验证令牌，所以在令牌过期之前无法使令牌无效。您需要采取其他步骤来使自编码的令牌无效。</p>
<h3 id="访问令牌生命周期"><a href="#访问令牌生命周期" class="headerlink" title="访问令牌生命周期"></a>访问令牌生命周期</h3><p>当您的服务发出访问令牌时，您需要做出一些关于您希望令牌持续多久的决定。不幸的是，每项服务都没有全面的解决方案。不同的选项会有各种权衡，因此您应该选择最适合您应用需求的选项（或选项组合）。</p>
<h4 id="短期访问令牌和长期刷新令牌"><a href="#短期访问令牌和长期刷新令牌" class="headerlink" title="短期访问令牌和长期刷新令牌"></a>短期访问令牌和长期刷新令牌</h4><p>授予令牌的常用方法是使用访问令牌和刷新令牌的组合，以获得最大的安全性和灵活性。OAuth 2.0规范建议使用此选项，并且一些实现已采用此方法。</p>
<p>通常，使用此方法的服务将发出持续时间从几小时到几周的访问令牌。当服务发出访问令牌时，它还会生成一个永不过期的刷新令牌，并在响应中返回该令牌。（请注意，无法使用隐式授权发布刷新令牌。）</p>
<p>当访问令牌到期时，应用程序可以使用刷新令牌来获取新的访问令牌。它可以在幕后进行，无需用户参与，因此对用户来说是一个无缝的过程。</p>
<p>这种方法的主要好处是该服务可以使用自编码访问令牌，无需数据库查找即可对其进行验证。但是，这意味着没有办法直接使这些令牌过期，因此，令牌的发布时间很短，因此应用程序被迫不断刷新它们，从而使服务有机会在需要时撤销应用程序的访问权限。</p>
<p>从第三方开发人员的角度来看，处理刷新令牌往往令人沮丧。开发人员非常喜欢不会过期的访问令牌，因为处理的代码要少得多。为了帮助缓解这些问题，服务通常会在其SDK中构建令牌刷新逻辑，以便该流程对开发人员而言是透明的。</p>
<p>总之，在以下情况下使用短期访问令牌和长期刷新令牌：</p>
<ul>
<li>您想使用自编码访问令牌</li>
<li>您希望限制泄露访问令牌的风险</li>
<li>您将提供给开发人员处理刷新逻辑的SDK</li>
</ul>
<h4 id="短期访问令牌，没有刷新令牌"><a href="#短期访问令牌，没有刷新令牌" class="headerlink" title="短期访问令牌，没有刷新令牌"></a>短期访问令牌，没有刷新令牌</h4><p>如果要确保用户了解正在访问其帐户的应用程序，则该服务可以在不刷新令牌的情况下发出相对短期的访问令牌。访问令牌可以持续从当前应用程序会话到几周。当访问令牌到期时，应用程序将被强制使用户再次登录，以便您作为服务知道用户不断参与重新授权应用程序。</p>
<p>通常，此选项由服务使用，如果第三方应用程序意外或恶意泄漏访问令牌，则存在高风险。通过要求用户不断重新授权应用程序，如果攻击者从服务中窃取访问权限，则该服务可以确保潜在的损害受到限制。</p>
<p>通过不发布刷新令牌，这使得应用程序无法在用户不在屏幕前的情况下持续使用访问令牌。这使得连续同步数据的应用程序将无法在此方法下执行此操作。</p>
<p>从用户的角度来看，这是最有可能让人感到沮丧的选项，因为用户必须不断重新授权应用程序。</p>
<p>总之，在以下情况下使用没有刷新令牌的短期访问令牌：</p>
<ul>
<li>您希望最大程度地防范泄露访问令牌的风险</li>
<li>您希望强制用户了解他们授予的第三方访问权限</li>
<li>您不希望第三方应用程序对用户数据进行脱机访问</li>
</ul>
<h4 id="非过期访问令牌"><a href="#非过期访问令牌" class="headerlink" title="非过期访问令牌"></a>非过期访问令牌</h4><p>非过期访问令牌是开发人员最简单的方法。如果您选择此选项，请务必考虑您所做的权衡。</p>
<p>如果你想能够任意撤销它们，那么使用自编码令牌是不切实际的。因此，您需要将这些令牌存储在某种数据库中，因此可以根据需要删除它们或将其标记为无效。</p>
<p>请注意，即使服务打算发布非过期访问令牌以供正常使用，您仍需要提供一种机制，以便在特殊情况下使其过期，例如，如果用户明确要撤消应用程序的访问权限，或者用户帐户已删除。</p>
<p>对于测试自己的应用程序的开发人员来说，非过期访问令牌就更容易。您甚至可以为开发人员预生成一个或多个非过期访问令牌，并在应用程序详细信息页面上显示给他们。通过这种方式，他们可以立即开始使用令牌发出API请求，而不必担心设置OAuth流程以开始测试API。</p>
<p>总之，在以下情况下使用非过期访问令牌：</p>
<ul>
<li>你有一个机制来随时撤销访问令牌</li>
<li>如果令牌泄露，你没有巨大的风险</li>
<li>您希望为开发人员提供简单的身份验证机制</li>
<li>您希望第三方应用程序可以脱机访问用户的数据</li>
</ul>
<h3 id="刷新访问令牌"><a href="#刷新访问令牌" class="headerlink" title="刷新访问令牌"></a>刷新访问令牌</h3><p>本节介绍如何允许开发人员使用刷新令牌获取新的访问令牌。如果您的服务与访问令牌一起发布刷新令牌，那么您需要实现此处描述的刷新授权类型。</p>
<h4 id="请求参数-2"><a href="#请求参数-2" class="headerlink" title="请求参数"></a>请求参数</h4><p>访问令牌请求将包含以下参数。</p>
<blockquote>
<p><strong>grant_type （需要）</strong><br>grant_type参数必须设置为“refresh_token”。</p>
<p><strong>refresh_token （需要）</strong><br>先前发布给客户端的刷新令牌。</p>
<p><strong>scope （可选的）</strong><br>请求的范围不得包含原始访问令牌中未发布的其他范围。通常，这不会包含在请求中，如果省略，服务应发出一个访问令牌，其范围与先前发布的相同。</p>
<p>客户端身份验证（如果客户端被授予秘钥，则需要）<br>通常，刷新令牌仅用于私密客户端。但是，由于可以在没有客户端秘钥的情况下使用授权码流程，因此刷新授权也可以给没有秘钥的客户端使用。如果客户端被授予秘钥，则客户端必须验证此请求。通常，该服务将允许额外的查询参数client_id和client_secret，或接受在HTTP Basic auth header中的客户端ID和秘钥。如果客户端没有秘钥，则此请求中不会出现客户端身份验证。</p>
</blockquote>
<h4 id="验证刷新令牌授权"><a href="#验证刷新令牌授权" class="headerlink" title="验证刷新令牌授权"></a>验证刷新令牌授权</h4><p>在检查所有必需参数并在客户端被授予秘钥时验证客户端之后，授权服务器可以继续验证请求的其他部分。</p>
<p>然后，服务器检查刷新令牌是否有效，并且尚未过期。如果向私密客户端发出刷新令牌，则服务必须确保将请求中的刷新令牌发送给经过身份验证的客户端。</p>
<p>如果所有内容都检出，该服务可以生成访问令牌并进行响应。服务器可以在响应中发出新的刷新令牌，但是如果响应不包括新的刷新令牌，则客户端假定现有的刷新令牌仍然有效。</p>
<p>例<br>以下是服务将接收的示例刷新授权。</p>
<pre><code class="bash">POST /oauth/token HTTP/1.1
Host: authorization-server.com

grant_type=refresh_token
&amp;refresh_token=xxxxxxxxxxx
&amp;client_id=xxxxxxxxxx
&amp;client_secret=xxxxxxxxxx
</code></pre>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--重定向URI]]></title>
      <url>/2018/07/13/oauth-guide-11/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>重定向网址是OAuth流程的重要组成部分。用户成功授权应用程序后，授权服务器将带着URL中的授权码或访问令牌将用户重定向回应用程序。由于重定向URL将包含敏感信息，因此服务不会将用户重定向到任意位置就显得至关重要。</p>
<p>确保用户仅被定向到适当位置的最佳方法是要求开发人员在创建应用程序时注册一个或多个重定向URL。在这些部分中，我们将介绍如何处理移动应用程序的重定向URL，如何验证重定向URL以及如何处理错误。</p>
<h3 id="重定向URI注册"><a href="#重定向URI注册" class="headerlink" title="重定向URI注册"></a>重定向URI注册</h3><p>为了确保服务的安全性，您必须要求开发人员为应用程序注册一个或多个重定向URL。授权服务器绝不能重定向到任何其他位置。注册新应用程序包括创建注册表单，以允许开发人员为其应用程序注册重定向URL。</p>
<p>如果攻击者可以在用户到达授权服务器之前操纵重定向URL，则可能导致服务器将用户重定向到恶意服务器，恶意服务器会将授权码发送给攻击者。对于没有client_secret的公共客户端，只需要client_id和授权码就可以获取访问令牌。如果攻击者可以获得授权码，则可以将其交换为公共客户端的访问令牌。这是授权服务器在应用程序注册期间就应该知道应用程序是公共还是私有的另一个重要原因。</p>
<h4 id="有效的重定向网址"><a href="#有效的重定向网址" class="headerlink" title="有效的重定向网址"></a>有效的重定向网址</h4><p>在构建表单以允许开发人员注册重定向URL时，您应该对他们输入的URL进行一些基本验证。</p>
<p>已注册的重定向URL可能包含查询字符串参数，但不得在fragment中包含任何内容。如果开发人员尝试注册包含fragment的重定向URL，则注册服务器应拒绝该请求。</p>
<p>请注意，对于原生和移动应用程序，该平台可能允许开发人员注册URL方案<code>myapp://</code>，然后可以在重定向URL中使用该方案。这意味着授权服务器应允许注册任意URL方案，以支持为原生应用程序注册重定向URL。</p>
<h4 id="按请求自定义"><a href="#按请求自定义" class="headerlink" title="按请求自定义"></a>按请求自定义</h4><p>通常，开发人员会认为他们需要能够在每个授权请求上使用不同的重定向URL，并且会尝试更改每个请求的查询字符串参数。这不是重定向URL的预期用途，授权服务器不应该允许这样的URL。服务器应拒绝任何具有与注册URL不完全匹配的重定向URL的授权请求。</p>
<p>如果客户端希望在重定向URL中包含特定于请求的数据，则可以使用“state”参数来存储在重定向用户之后将包括的数据。可以在state参数本身中对数据进行编码，也可以使用state参数作为会话ID来在服务器上存储状态。</p>
<h3 id="原生应用程序的重定向URI"><a href="#原生应用程序的重定向URI" class="headerlink" title="原生应用程序的重定向URI"></a>原生应用程序的重定向URI</h3><p>原生应用程序是安装在设备上的客户端，例如桌面应用程序或移动应用程序。在支持与安全性和用户体验相关的原生应用程序时，需要记住一些事项。</p>
<p>授权endpoint通常会将用户重定向回客户端注册的重定向URL。根据平台，应用程序可以声明URL模式，也可以注册启动应用程序的自定义URL方案。例如，iOS应用程序可以注册自定义协议，例如<code>myapp://</code>，然后使用redirect_uri <code>myapp://callback</code>。</p>
<h4 id="应用程序声明的https-URL重定向"><a href="#应用程序声明的https-URL重定向" class="headerlink" title="应用程序声明的https URL重定向"></a>应用程序声明的https URL重定向</h4><p>某些平台（从iOS 9开始的Android和iOS）允许应用程序覆盖特定的URL模式以启应用程序而不是Web浏览器。例如，应用程序可以注册<code>https://app.example.com/auth</code>，只要Web浏览器尝试重定向到该URL，操作系统就会启动应用程序。</p>
<p>如果操作系统支持声明URL，则应使用此方法。这允许操作系统保证应用程序的标识。如果操作系统不支持此操作，则应用程序必须使用自定义URL方案。</p>
<h4 id="自定义URL方案"><a href="#自定义URL方案" class="headerlink" title="自定义URL方案"></a>自定义URL方案</h4><p>大多数移动和桌面操作系统允许应用注册自定义URL方案，当从系统浏览器访问具有该方案的URL时，该方案将启动应用程序。</p>
<p>使用此方法，本机应用程序正常启动OAuth流，方法是使用标准授权码参数启动系统浏览器。唯一的区别是重定向URL将是具有应用程序自定义方案的URL。</p>
<p>当授权服务器发送打算将用户重定向到<code>myapp://callback#token=....</code>的Location header时，手机将启动应用程序，应用程序将能够恢复授权过程，从URL解析访问令牌并在内部存储它。</p>
<h4 id="自定义URL方案命名空间"><a href="#自定义URL方案命名空间" class="headerlink" title="自定义URL方案命名空间"></a>自定义URL方案命名空间</h4><p>由于没有集中注册URL方案的方法，因此应用程序必须尽力选择不会相互冲突的URL方案。</p>
<p>您的服务可以通过要求URL方案遵循特定模式来提供帮助，并且只允许开发人员注册与该模式匹配的自定义方案。</p>
<p>例如，Facebook根据应用的客户端ID为每个应用生成一个URL方案。例如，<code>fb00000000://</code>数字对应于应用程序的客户端ID。这提供了一种生成全局唯一URL方案的合理可靠方法，因为其他应用程序不太可能使用具有此模式的URL方案。</p>
<p>应用程序的另一个选项是将反向域名模式与应用程序发布者控制的域一起使用。这也可以由服务强制执行。</p>
<h3 id="重定向URI验证"><a href="#重定向URI验证" class="headerlink" title="重定向URI验证"></a>重定向URI验证</h3><p>有三种情况需要验证重定向网址。</p>
<ul>
<li>当开发人员将重定向URL注册为创建应用程序的一部分时</li>
<li>在授权请求中（授权码类型和隐式授权类型）</li>
<li>当应用程序交换访问令牌的授权码时</li>
</ul>
<h4 id="重定向URL注册"><a href="#重定向URL注册" class="headerlink" title="重定向URL注册"></a>重定向URL注册</h4><p>如创建应用程序中所述，该服务应允许开发人员在创建应用程序时注册一个或多个重定向URL。重定向URL的唯一限制是它不能包含fragment组件。该服务必须允许开发人员使用自定义URL方案注册重定向URL，以便在某些平台上支持应用程序。</p>
<h4 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h4><p>当应用程序启动OAuth流程时，它会将用户定向到您服务的授权endpoint。该请求将在URL中包含多个参数，包括重定向URL。</p>
<p>此时，授权服务器必须验证重定向URL，以确保请求中的URL与应用程序的一个已注册URL匹配。请求还将有一个client_id参数，因此服务应该根据该id查找重定向URL。攻击者完全有可能使用一个应用程序的客户端ID和攻击者的重定向URL来创建授权请求，这就是需要注册的原因。</p>
<p>服务应查找URL的完全匹配，并避免仅匹配特定URL的一部分。（如果需要自定义每个请求，客户端可以使用state参数。）简单的字符串匹配就足够了，因为无法根据请求自定义重定向URL。服务器需要做的就是检查请求中的重定向URL是否与开发人员在注册其应​​用程序时输入的重定向URL相匹配。</p>
<p>如果重定向URL不是已注册的重定向URL之一，则服务器必须立即显示指示此类的错误，而不是重定向用户。这样可以避免将授权服务器用作打开的重定向程序。</p>
<h4 id="授予访问令牌"><a href="#授予访问令牌" class="headerlink" title="授予访问令牌"></a>授予访问令牌</h4><p>令牌endpoint时用授权码交换访问令牌的的请求。此请求将包含重定向URL以及授权码。作为安全性的附加度量，服务器应验证此请求中的重定向URL是否与授权码的初始授权请求中包含的重定向URL完全匹配。如果重定向URL不匹配，则服务器会拒绝该请求并显示错误。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--范围]]></title>
      <url>/2018/07/13/oauth-guide-10/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>本章是对OAuth服务提供商的指导。</p>
<p>范围(scope)是一种限制应用访问用户数据的方法。与授予对用户帐户的完全访问权限相比，为应用程序提供一种方式，来限制他们代表用户访问和操作的范围，通常是一种更有效的方式。</p>
<p>某些应用仅使用OAuth来识别用户，因此他们只需要访问用户ID和基本配置文件信息。其他应用可能需要知道更敏感的信息，例如用户的生日，或者他们可能需要能够代表用户发布内容，或修改个人资料数据。如果用户确切知道应用程序可以和不能对他们的帐户做什么，他们将更愿意授权应用程序。范围是一种控制访问权限的方法，可帮助用户识别他们授予应用程序的权限。</p>
<h3 id="定义范围"><a href="#定义范围" class="headerlink" title="定义范围"></a>定义范围</h3><p>定义范围的好地方是分别定义读取与写入。这适用于Twitter，因为并非所有应用程序实际上都希望能够将内容发布到您的Twitter帐户，有些只需要访问您的个人资料信息。</p>
<p>定义服务范围时的挑战是不要因定义太多范围而被忽略。用户需要能够理解他们授予的授权范围，并且这将在列表中呈现给用户。当呈现给用户时，他们需要真正了解正在发生的事情。如果您为用户设计的过度复杂，他们可能会单击“确定”直到应用程序正常工作，并忽略任何警告。</p>
<h4 id="读与写"><a href="#读与写" class="headerlink" title="读与写"></a>读与写</h4><p>通常，在定义服务范围时，读取和写入访问是一个很好的起点。通常，对想要更新配置文件信息的应用程序，使用单独的访问控制来处理对用户的私有配置文件信息的读访问。</p>
<p>需要能够代表用户创建内容的应用程序（例如，将推文发布到用户的时间线的第三方Twitter应用程序），与仅需要读取用户的公共数据的应用程序相比，需要获得不同级别的访问权限。</p>
<h4 id="限制对敏感信息的访问"><a href="#限制对敏感信息的访问" class="headerlink" title="限制对敏感信息的访问"></a>限制对敏感信息的访问</h4><p>通常，对于不同安全级别的用户，服务将具有不同的配置。例如，GitHub有一个单独的范围，允许应用程序访问私有存储库。默认情况下，应用程序无权访问私有存储库，除非他们要求该范围，因此用户可以放心地知道他们选择的应用只能访问属于其组织的私有存储库。</p>
<p>GitHub提供了一个单独的范围，允许应用程序删除repos，因此用户可以放心，随机应用程序无法绕过这个范围删除其存储库。</p>
<p>Dropbox为应用程序提供了一种限制自己只能编辑单个文件夹中文件的方法。这为尝试使用Dropbox作为存储或同步机制的应用程序提供了一种方法，用户无需担心应用程序可能会读取其所有文件。</p>
<h4 id="通过功能选择性地启用访问"><a href="#通过功能选择性地启用访问" class="headerlink" title="通过功能选择性地启用访问"></a>通过功能选择性地启用访问</h4><p>范围的一个很好的用途是根据所需的功能选择性地启用对用户帐户的访问。例如，Google为其各种服务提供了一组范围，例如Google云端硬盘，Gmail，YouTube等。这意味着需要访问YouTube API的应用程序也不一定能够访问用户的Gmail帐户。</p>
<p>谷歌的API是有效使用范围的一个很好的例子。有关Google OAuth API支持的范围的完整列表，请访问<code>https://developers.google.com/oauthplayground/</code>上的 OAuth 2.0 Playground。</p>
<h4 id="限制对可结算资源的访问"><a href="#限制对可结算资源的访问" class="headerlink" title="限制对可结算资源的访问"></a>限制对可结算资源的访问</h4><p>如果您的服务提供的API可能会导致用户产生费用，那么设定范围是防止滥用此功能的应用程序的好方法。</p>
<p>例如，在提供使用许可内容的高级功能的情况下，提供用于聚合给定区域的人口统计数据的API。用户在使用服务时收取费用，费用取决于要查询的区域的大小。当用户登录使用完全不同的API部分的应用时，用户希望确保此应用无法使用人口统计信息API，因为这会导致该用户产生费用。在这种情况下，服务应定义一个特殊范围，例如“人口统计”。人口统计信息API应仅响应来自包含此范围的令牌的API请求。</p>
<p>在此示例中，人口统计信息API可以使用<a href="https://www.oauth.com/oauth2-servers/token-introspection-endpoint/" target="_blank" rel="noopener">令牌自解析端点</a>来查找对此令牌有效的范围列表。如果响应在范围列表中不包含“人口统计”，则端点将使用HTTP 403响应拒绝该请求。</p>
<h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p>用户在授权应用程序时看到的界面需要清楚地显示应用程序请求的范围列表。用户可能不知道服务提供的范围的所有可能性，因此最好使该文本尽可能清晰明了，避免使用行话和缩写。</p>
<p>如果请求授予应用程序对用户帐户的完全访问权限，或访问其帐户的大部分内容，例如除了更改密码之外能够执行所有操作，则该服务应该非常清楚。例如，Dropbox授权用户界面上的第一句话是“示例OAuth应用程序希望访问Dropbox中的文件和文件夹”，其中包含“了解更多”链接，该链接指向帮助页面，该帮助页面准确描述了应用程序将具有哪些访问权限。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/dropbox.png" alt="dropbox"></p>
<p>Flickr授权界面显示用户在登录时授予应用程序的三件事，并清楚地显示应用程序不具有的权限。显示这一点的好处是，用户可以放心，他们授权的应用程序将无法进行潜在的破坏性操作。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/flickr.png" alt="flickr"></p>
<p>GitHub在提供有关用户授予范围的详细信息方面做得非常出色。请求的每个范围都会在页面上显示一个部分，其中包含名称，图标，突出显示是只读还是读写的简短说明，以及下拉列表以查看更详细的说明。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/github.png" alt="github"></p>
<p>Google为其所有服务提供单一授权终端，包括Gmail API，Google云端硬盘，Youtube等。其授权界面会在列表中显示每个范围，并包含一个“信息”图标，您可以点击该图标以获取有关特定内容的详细信息范围。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/google.png" alt="google"></p>
<p>单击信息图标会显示一个叠加层，详细描述此范围允许的内容。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/google-scope-popup.png" alt="google_scope"></p>
<p>您可以看到有多种方法可以为用户提供有关OAuth授权范围的信息，并且各种服务采用了截然不同的方法。在您定义范围时，请务必考虑应用程序的隐私和安全要求。</p>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>虽然这是一个看似未充分利用的功能，但OAuth 2.0规范明确允许授权服务器授予访问令牌的范围小于应用程序的请求。这为一些有趣的可能性留下了空间。</p>
<p>在开始开发OAuth 2.0规范之前，OAuth 1已部署在Twitter上，Twitter应用程序生态系统正在迅速发展。在创建Twitter应用程序时，您可以选择您的应用程序是需要读取+写入权限还是只读取对用户帐户的访问权限。这是一种开发OAuth 2.0范围概念的机制。但是，这种实现是相当有限的，因为应用程序要么不请求写访问权限，要么用户可能只是拒绝该请求，如果他们不想授予应用程序写访问权限。</p>
<p>很快就开发了一种常见的Twitter应用程序的反模式，它只使用写访问权来发布推文给应用程序做广告。其中一个更臭名昭着的事件发生在2010年，当时应用程序“Twifficiency”声称“根据你的推特活动计算你的推特效率”，但这却很快失控。您将使用您的Twitter帐户登录该应用程序，它会抓取您过去的推文并对其进行分析。但是，它也自动发推文“我的Twifficiency得分是__％。你的是多少？”从而链接到第三方网站。许多人甚至不知道应用程序正在执行此操作，或者他们已授予此应用程序权限以发布到其帐户。这导致应用程序变成病毒式传播，因为使用该应用程序的任何人的关注者都会在他们的时间轴中看到它。</p>
<p>许多人对此感到不安，并在Twitter上大声抱怨。当时雅虎的开发人员Ben Ward更进一步，创建了一个可以解决这个问题的潜在用户界面的模型，并写了一篇简短的博客文章解释它。<code>https://benward.uk/blog/tumblr-968515729</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftfc4um00ij30lp0cftat.jpg" alt="twitter"></p>
<p>在帖子中，Ward描述了一个允许应用程序请求特定权限的用户界面，用户可以选择授予或不授予每个权限。这将允许用户登录应用程序但不允许其首先发布到其帐户。稍后，如果用户确实想要允许该应用发布，则该应用可以提供在Twitter上重新授权用户的机制。几个月后，沃德在Twitter被聘用。</p>
<p>这篇文章引发了一些参与OAuth规范开发的人们之间的讨论，这个讨论现在只存在于archive.org上的Google Buzz主题：<code>http://web.archive.org/web/20100823114908/</code>,<code>http://www.google.com/buzz/tantek/5YHAAmztLcD/t-Look-BenWard-schools-Twitter-on-OAuth</code>。</p>
<p>直到今天，Twitter仍然没有提供这种细粒度的授权。但是，其他服务已经开始实现类似的功能，在授权流程中为用户提供更多控制，而不是使其看起来像“单击确定以继续”对话框。</p>
<p>Facebook推出了最近的更新，为初始页面提供了一个简单的用户界面，允许用户点击编辑应用程序将被授予的范围，如下所示。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftfc74seznj30sc0f7jso.jpg" alt="facebook"></p>
<p>如果单击“编辑您提供的信息”，则会转到一个界面，列出应用程序请求的每个范围，您可以根据需要取消选中它们。在下面的屏幕截图中，我选择不允许应用程序查看我的朋友列表。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftfc7yma0rj30si0f775b.jpg" alt="facebook checkbox"></p>
<p>只有应用程序请求的范围才会出现在此列表中。这为用户提供了更好的体验，因为他们能够保持控制并更好地了解应用程序如何使用其帐户。</p>
<p>FitBit跟踪用户健康的许多方面，例如步数，心率，消耗的食物和饮料，睡眠质量，体重等。FitBit API对第三方应用程序提供对所有这些数据的访问。由于许多第三方应用程序只会读取或写入某些类型的数据，FitBit会提供精细的范围，以便用户只能授予对其配置文件的某些部分的访问权限。</p>
<p>FitBit的授权页面（如下所示）允许用户有选择地授予或拒绝访问应用程序请求的每个特定范围。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ftfcao2nejj30pw0r4n14.jpg" alt="fitbit"></p>
<p>GitHub 在2013 年的博客文章中描述了他们计划允许用户编辑范围，但截至2018年，依旧没有后续跟进。</p>
<p>使用户能够选择授予哪些范围是让人们对使用第三方应用感到更舒服的好方法。每个范围旁边加复选框就足够了，或者您可以将控件移动到像Facebook这样的单独屏幕。您需要确保在发送访问令牌响应时，它包括用户所授予的范围列表，而不是应用程序请求的。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--授权]]></title>
      <url>/2018/07/13/oauth-guide-9/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>本章是对OAuth服务提供商的指导。</p>
<p>授权界面是用户在授予应用程序访问其帐户时看到的页面。以下部分介绍如何构建授权页面，界面中包含哪些组件以及如何最好地向用户显示界面。</p>
<p>在实施OAuth服务时，您正在使开发人员能够构建利用您的平台的应用程序，允许应用程序访问并可能修改私有用户内容，或代表用户行事。因此，您需要确保为用户提供尽可能多的信息以保护其帐户，并确保他们了解应用程序对其帐户执行的操作。</p>
<h3 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h3><p>客户端会将用户的浏览器定向到授权服务器以开始OAuth流程。客户端可以使用授权码授予类型或隐式授权。除了response_type参数指定的授权类型外，请求还有许多其他参数来指示请求的细节。</p>
<p><a href="http://seanthefish.com/2018/06/29/oauth-guide-2/">OAuth 2.0客户端</a>描述了客户端如何为您的服务构建授权URL。授权服务器第一次看到用户申请此授权请求时，将使用客户端设置的查询参数将用户定向到服务器。此时，授权服务器将需要验证请求并提供授权接口，允许用户批准或拒绝该请求。</p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>以下参数用于开始授权请求。例如，如果授权服务器URL是<code>https://authorization-server.com/auth</code>, 客户端将创建如下的URL并将用户的浏览器指向它：</p>
<pre><code class="html">https://authorization-server.com/auth?response_type=code
&amp;client_id=29352735982374239857
&amp;redirect_uri=https://example-app.com/callback
&amp;scope=create+delete
&amp;state=xcoivjuywkdkhvusuye3kch
</code></pre>
<blockquote>
<p><strong>response_type</strong><br>response_type将设置为code，表示应用程序希望在成功时收到授权码。</p>
<p><strong>client_id</strong><br>client_id是应用程序的公共标识符。</p>
<p><strong>redirect_uri （可选的）</strong><br>redirect_uri不规范所要求的，但你的服务应该需要它。此URL必须与开发人员在创建应用程序时注册的其中一个URL匹配，如果请求不匹配，授权服务器应拒绝该请求。</p>
<p><strong>scope （可选的）</strong><br>请求可以具有一个或多个scope值，指示应用程序请求的附加访问。授权服务器需要向用户显示请求的scope。</p>
<p><strong>state （推荐的）</strong><br>state应用程序使用该参数来存储特定于请求的数据和/或防止CSRF攻击。授权服务器必须将未修改的state值返回给应用程序。</p>
</blockquote>
<h4 id="授予类型"><a href="#授予类型" class="headerlink" title="授予类型"></a>授予类型</h4><p>当客户端应用程序期望授权码作为响应时，授权码授予类型将与密钥和公共客户端一起工作。要启动授权码授予，客户端将使用查询参数response_type=code以及其他所需参数将用户的浏览器定向到授权服务器。</p>
<h4 id="验证授权请求"><a href="#验证授权请求" class="headerlink" title="验证授权请求"></a>验证授权请求</h4><p>授权服务器必须首先验证client_id请求中的对应的有效的应用程序。</p>
<p>如果您的服务器允许应用程序注册多个重定向URL，则验证重定向URL有两个步骤。如果请求包含redirect_uri参数，则服务器必须确认它是此应用程序的有效重定向URL。如果redirect_uri请求中没有参数，并且只注册了一个URL，则服务器使用先前注册的重定向URL。否则，如果请求中没有重定向URL，并且没有注册重定向URL，就将会返回一个错误。</p>
<p>如果client_id无效，服务器应立即拒绝请求并向用户显示错误。</p>
<h4 id="无效的重定向网址"><a href="#无效的重定向网址" class="headerlink" title="无效的重定向网址"></a>无效的重定向网址</h4><p>如果授权服务器检测到重定向URL有问题，则需要通知用户该问题。由于多种原因，重定向网址可能无效，包括：</p>
<ul>
<li>缺少重定向URL参数</li>
<li>重定向URL参数无效，例如，如果它是不解析为URL的字符串</li>
<li>重定向URL与应用程序的已注册重定向URL之一不匹配</li>
</ul>
<p>在这些情况下，授权服务器应向用户显示错误，通知他们问题。服务器不得将用户重定向回应用程序。这避免了所谓的“<a href="https://oauth.net/advisories/2014-1-covert-redirect/" target="_blank" rel="noopener">开放重定向器攻击</a>”。如果已注册重定向URL，则服务器应仅将用户重定向到重定向URL。</p>
<h4 id="其他错误"><a href="#其他错误" class="headerlink" title="其他错误"></a>其他错误</h4><p>通过将用户重定向到重定向URL，并使用查询字符串中的错误代码来处理所有其他错误。有关如何响应错误的详细信息，请参阅“<a href="https://www.oauth.com/oauth2-servers/authorization/the-authorization-response/" target="_blank" rel="noopener">授权响应</a>”部分。</p>
<p>如果请求缺少response_type参数，或者该参数的值是除了code和token之外的任何内容，则服务器会返回invalid_request错误。</p>
<p>由于授权服务器可能要求客户端指定它们是公共的还是机密的，因此它可以拒绝不允许的授权请求。例如，如果客户端指定它们是机密客户端，则服务器可以拒绝使用令牌授权类型的请求。拒绝时，请使用错误代码unauthorized_client。</p>
<p>如果存在无法识别的scope值，授权服务器应拒绝该请求。在这种情况下，服务器可以使用invalid_scope错误代码重定向到回调URL 。</p>
<p>授权服务器需要存储此请求的“state”值，以便将其包含在访问令牌响应中。服务器不得修改或对state值包含的内容做出任何假设，因为它纯粹是为了客户端的便利。</p>
<h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>用户在单击应用程序的“登录”或“连接”按钮后将看到的第一件事是您的授权服务器UI。由授权服务器决定是否在每次访问授权屏幕时要求用户登录，或者让用户登录一段时间。如果授权服务器要在请求之间记住用户，那么它将需要请求用户在将来访问时授权该应用程序。</p>
<p>通常像Twitter或Facebook这样的网站希望他们的用户在大多数时间都是签名的，因此他们为他们的授权屏幕提供了一种方式，通过不要求他们每次登录来为用户提供简化的体验。但是，根据服务以及第三方应用程序的安全要求，可能需要或允许开发人员选择要求用户在每次访问授权屏幕时登录。</p>
<p>在Google的API中，应用程序可以添加prompt=login到授权请求，这会导致授权服务器在显示授权提示之前强制用户再次登录。</p>
<p>在任何情况下，如果用户已退出，或者在您的服务上还没有帐户，则需要为他们提供在此屏幕上登录或创建帐户的方法。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/twitter_logged_out_auth_screen.png" alt="Twitter的授权屏幕的退出视图"></p>
<p>因为OAuth 2.0规范中未指定，您可以按照您希望的方式对用户进行身份验证。大多数服务使用传统的用户名/密码登录来验证其用户，但这绝不是解决问题的唯一方法。在企业环境中，常见的技术是使用SAML（一种基于XML的身份验证标准）来利用组织中的现有身份验证机制，同时避免创建另一个用户名/密码数据库。</p>
<p>一旦用户使用授权服务器进行身份验证，它就可以继续处理授权请求并将用户重定向回应用程序。通常，服务器将认为成功登录也意味着用户授权该应用程序。在这种情况下，具有登录提示的授权页面将需要包括描述以下事实的文本：通过登录，用户正在批准该授权请求。这将导致以下用户流程。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/github_create_new_application_1.png" alt="登录和未登录的用户流程"></p>
<p>如果授权服务器需要通过SAML或其他内部系统对用户进行身份验证，则用户流程将如下所示</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/okta_oauth-diagrams_2.png" alt="用于单独验证服务器的用户流"></p>
<p>在此流程中，用户在登录后被定向回授权服务器，在那里他们看到授权请求，就像他们已经登录一样。</p>
<h3 id="授权接口"><a href="#授权接口" class="headerlink" title="授权接口"></a>授权接口</h3><p>授权界面是用户在收到来自第三方应用程序的授权请求时将看到的屏幕。由于第三方应用程序会要求用户授予某种级别的访问权限，因此您需要确保用户在授权应用程序权限时做出明智决策所需的所有信息。授权接口通常具有以下组件：</p>
<h4 id="网站名称和logo"><a href="#网站名称和logo" class="headerlink" title="网站名称和logo"></a>网站名称和logo</h4><p>该服务应该易于用户识别，因为他们需要知道他们授予哪些服务访问权限。但是，您确定主页上的网站应与授权界面一致。通常，这通过在屏幕的一定的位置显示应用程序名称和logo，或在整个网站上使用一致的颜色方案来完成。</p>
<h4 id="用户识别"><a href="#用户识别" class="headerlink" title="用户识别"></a>用户识别</h4><p>如果用户已登录，则应向用户指明。这可能就像在屏幕的右上角显示他们的名字和照片一样，就像在网站的其他部分一样。</p>
<p>重要的是，用户知道他们当前登录的帐户，以防他们管理多个帐户，以便他们不会错误地授权不同的用户帐户。</p>
<h5 id="申请细节"><a href="#申请细节" class="headerlink" title="申请细节"></a>申请细节</h5><p>授权接口应清楚地标识发出请求的应用程序。除了开发人员提供的应用程序名称之外，通常还应该显示网站和应用程序的logo，这是开发人员注册应用程序时收集的信息。我们在<a href="http://seanthefish.com/2018/07/08/oauth-guide-7/">客户端注册</a>中详细讨论了这一点。</p>
<h4 id="要求的范围"><a href="#要求的范围" class="headerlink" title="要求的范围"></a>要求的范围</h4><p>应该向用户清楚地显示授权请求中提供的范围值。范围值通常是表示特定访问的短字符串，因此应向用户显示更易于阅读的版本。</p>
<p>例如，如果服务将“私有”范围定义为对私有配置文件数据的读取访问权限，则授权服务器应该说“此应用程序将能够查看您的私有配置文件数据”。如果范围明确允许写入访问，也应该在描述中标识，例如“此应用程序将能够编辑您的配置文件数据”。</p>
<p>如果没有范围，但您的服务仍然授予对用户帐户的一些基本访问级别，则应该包含描述应用程序将访问的内容的消息。如果省略范围意味着应用程序获得的唯一内容是用户标识，则可以包含一条消息，以表示“此应用程序希望您登录”。</p>
<p>有关如何在服务中有效使用范围的更多信息，请参阅<a href="https://www.oauth.com/oauth2-servers/scope/" target="_blank" rel="noopener">范围</a>。</p>
<h4 id="请求的或有效的生命周期"><a href="#请求的或有效的生命周期" class="headerlink" title="请求的或有效的生命周期"></a>请求的或有效的生命周期</h4><p>授权服务器必须决定授权的有效期，访问令牌的持续时间以及刷新令牌的持续时间。</p>
<p>大多数服务不会自动使授权失效，而是希望用户定期查看和撤消对他们不再想要使用的应用的访问权限。但是，默认情况下，某些服务提供有限的令牌生存期，并允许应用程序请求更长的持续时间，或强制用户在授权过期后重新授权应用程序。</p>
<p>无论您对授权的有效期做出何种决定，都应该向用户明确说明应用程序能够代表用户执行多长时间。这可能是一个句子，加单的表明：“这个应用程序将能够访问您的帐户，直到您撤销访问”或者“这个应用程序将能够访问您的帐户，时效为一个星期。”关于令牌生命周期的更多信息请参见<a href="https://www.oauth.com/oauth2-servers/access-tokens/access-token-lifetime/" target="_blank" rel="noopener">访问令牌生命周期</a>。</p>
<h4 id="允许否认"><a href="#允许否认" class="headerlink" title="允许否认"></a>允许否认</h4><p>最后，授权服务器应该向用户提供两个按钮，以允许或拒绝该请求。如果用户未登录，则应提供登录提示而不是“允许”按钮。</p>
<p>如果用户批准该请求，则授权服务器将生成访问令牌并使用令牌信息重定向到应用程序。如果用户单击“拒绝”，则服务器会重定向到应用程序，并在URL中显示错误代码。</p>
<h3 id="授权响应"><a href="#授权响应" class="headerlink" title="授权响应"></a>授权响应</h3><p>根据授权类型，授权服务器将使用授权码或访问令牌进行响应。</p>
<h4 id="授权码响应"><a href="#授权码响应" class="headerlink" title="授权码响应"></a>授权码响应</h4><p>如果请求有效并且用户授予授权请求，则授权服务器生成授权码并将用户重定向回应用程序，将代码和先前的“state”值添加到重定向URL。</p>
<h4 id="生成授权码"><a href="#生成授权码" class="headerlink" title="生成授权码"></a>生成授权码</h4><p>授权码必须在颁发后不久到期。OAuth 2.0规范建议最长生命周期为10分钟，但实际上，大多数服务设置的到期时间要短得多，大约30-60秒。授权代码本身可以是任意长度，但应记录代码的长度。</p>
<p>因为授权代码是短暂的并且是单次使用的，所以它们是实现自编码的很好的候选者。使用此技术，您可以避免将授权代码存储在数据库中，而是将所有必要的信息编码到代码本身中。您可以使用服务器端环境的内置加密库，也可以使用JSON Web Signature（JWS）等标准。由于此字符串只需要您的授权服务器可以理解，因此不需要使用JWS等标准来实现此字符串。也就是说，如果您没有可以轻松访问的已经可用的加密库，JWS是一个很好的候选者，因为有许多语言的库可用。</p>
<p>需要与授权代码关联的信息如下。</p>
<blockquote>
<p><strong>client_id</strong><br>请求此代码的客户端ID（或其他客户端标识符）</p>
<p><strong>redirect_uri</strong><br>使用的重定向网址。需要存储，因为访问令牌请求必须包含相同的重定向URL，以便在发出访问令牌时进行验证。</p>
<p><strong>用户信息(User info)</strong><br>用于标识此授权代码所针对的用户的某种方式，例如用户ID。</p>
<p><strong>到期日期(Expiration Date)</strong><br>代码需要包含到期日期，以便使它能只持续很短的时间。</p>
<p><strong>唯一ID(Unique ID)</strong><br>代码需要其自己的某种ID，以便能够检查代码之前是否已被使用过。数据库ID或随机字符串就足够了。</p>
</blockquote>
<p>通过创建JWS令牌或生成随机字符串并将关联信息存储在数据库中生成授权码后，您需要将用户重定向到指定的应用程序重定向URL。要添加到重定向URL的查询字符串的参数如下：</p>
<blockquote>
<p><strong>code</strong><br>此参数包含客户端稍后将为访问令牌交换的授权码。</p>
<p><strong>state</strong><br>如果初始请求包含state参数，则响应还必须包含请求中的确切值。客户端将使用此将此响应与初始请求相关联。</p>
</blockquote>
<p>例如，授权服务器通过发送以下HTTP响应来重定向用户。</p>
<pre><code class="http">HTTP/1.1 302 Found
Location: https://oauth2client.com/redirect?code=g0ZGZmNjVmOWI&amp;state=dkZmYxMzE2
</code></pre>
<h4 id="隐式授权类型响应"><a href="#隐式授权类型响应" class="headerlink" title="隐式授权类型响应"></a>隐式授权类型响应</h4><p>使用隐式授权，授权服务器立即生成访问令牌，并使用令牌和其他参数重定向到回调URL。有关生成访问令牌的详细信息以及响应中所需参数的详细信息，请参阅访问<a href="https://www.oauth.com/oauth2-servers/access-tokens/access-token-response/" target="_blank" rel="noopener">令牌响应</a>。</p>
<p>例如，授权服务器通过发送以下HTTP响应来重定向用户（出于显示目的，需要额外的换行符）。</p>
<pre><code class="http">HTTP/1.1 302 Found
Location: https://example-app.com/redirect#access_token=MyMzFjNTk2NTk4ZTYyZGI3
 &amp;state=dkZmYxMzE2
 &amp;token_type=bearer
 &amp;expires_in=86400
</code></pre>
<h5 id="错误响应"><a href="#错误响应" class="headerlink" title="错误响应"></a>错误响应</h5><p>在两种情况下，授权服务器应直接显示错误消息，而不是将用户重定向到应用程序：如果client_id无效，或者redirect_uri无效。在所有其他情况下，可以将用户重定向到应用程序的重定向URL以及描述错误的查询字符串参数。</p>
<p>重定向到应用程序时，服务器会将以下参数添加到重定向URL：</p>
<blockquote>
<p><strong>error</strong><br>通常是以下列表中的一个ASCII错误代码：</p>
<ul>
<li><em>invalid_request</em> - 请求缺少参数，包含无效参数，多次包含参数，或者无效。</li>
<li><em>access_denied</em> - 用户或授权服务器拒绝该请求</li>
<li><em>unauthorized_client</em> - 不允许客户端使用此方法请求授权码，例如，如果机密客户端尝试使用隐式授权类型。</li>
<li><em>unsupported_response_type8</em> - 服务器不支持使用此方法获取授权代码，例如，如果授权服务器从未实现隐式授权类型。</li>
<li><em>invalid_scope</em> - 请求的范围无效或未知。</li>
<li><em>server_error</em> - 服务器可以使用此错误代码重定向，而不是向用户显示500内部服务器错误页面。</li>
<li><em>temporarily_unavailable</em> - 如果服务器正在进行维护或不可用，则可以返回此错误代码，而不是使用503 Service Unavailable状态代码进行响应。</li>
</ul>
<p><strong>error_description</strong><br>授权服务器可以可选地包括错误的描述。此参数旨在供开发人员理解错误，而不是要向最终用户显示。除双引号和反斜杠外，此参数的有效字符是ASCII字符集，特别是十六进制代码20-21,23-5B和5D-7E。</p>
<p><strong>error_uri</strong><br>服务器还可以将URL返回到人类可读的网页，其中包含有关错误的信息。这是为了让开发人员获得有关错误的更多信息，而不是要向最终用户显示。</p>
<p><strong>state</strong><br>如果请求包含状态参数，则错误响应还必须包含请求中的确切值。客户端可以使用它将此响应与初始请求相关联。</p>
</blockquote>
<p>例如，如果用户拒绝授权请求，服务器将构造以下URL并发送HTTP重定向响应（如下所示）（URL中的换行符用于说明目的）。</p>
<pre><code class="http">HTTP/1.1 302 Found
Location: https://example-app.com/redirect?error=access_denied
 &amp;error_description=The+user+denied+the+request
 &amp;error_uri=https%3A%2F%2Foauth2server.com%2Ferror%2Faccess_denied
 &amp;state=wxyz1234
</code></pre>
<h3 id="安全考虑因素"><a href="#安全考虑因素" class="headerlink" title="安全考虑因素"></a>安全考虑因素</h3><p>以下是构建授权服务器时应考虑的一些已知问题。</p>
<p>除了此处列出的注意事项外，<a href="https://tools.ietf.org/html/rfc6819" target="_blank" rel="noopener">OAuth 2.0线程模型和安全注意事项草案</a>中还提供了更多信息。</p>
<h4 id="网络钓鱼攻击"><a href="#网络钓鱼攻击" class="headerlink" title="网络钓鱼攻击"></a>网络钓鱼攻击</h4><p>针对OAuth服务器的一种潜在攻击是网络钓鱼攻击。这是攻击者创建一个看起来与服务授权页面相同的网页的地方，该页面通常包含用户名和密码字段。然后，通过各种手段，攻击者可以诱骗用户访问该页面。除非用户可以检查浏览器的地址栏，否则该页面可能看起来与真正的授权页面相同，并且用户可以输入他们的用户名和密码。</p>
<p>攻击者可以尝试诱骗用户访问伪造服务器的一种方法是将此网络钓鱼页面嵌入到本机应用程序中的嵌入式Web视图中。由于嵌入式Web视图不显示地址栏，因此用户无法直观地确认它们位于合法站点上。遗憾的是，这在移动应用程序中很常见，并且开发人员通常希望通过整个登录过程将用户保留在应用程序中来提供更好的用户体验。某些OAuth提供商鼓励第三方应用程序打开Web浏览器或启动提供程序的本机应用程序，而不是允许它们在Web视图中嵌入授权页面。</p>
<h5 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h5><p>确保通过https提供授权服务器以避免DNS欺骗。</p>
<p>授权服务器应该向开发人员介绍网络钓鱼攻击的风险，并且可以采取措施防止该页面嵌入到本机应用程序或iframe中。</p>
<p>应该让用户了解网络钓鱼攻击的危险，并且应该教导用户最佳实践，例如只访问他们信任的应用程序，并定期查看应用程序列表，对不再使用的应用程序授权撤销的访问权限。</p>
<p>该服务可能希望在允许其他用户使用该应用程序之前验证第三方应用程序。Instagram和Dropbox等服务目前都是这样做的，在初始创建应用程序时，该应用程序只能由开发人员或其他白名单用户帐户使用。应用程序提交审批并进行审核后，可以由该服务的整个用户群使用。这使服务有机会检查应用程序如何与服务交互。</p>
<h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><p>在点击劫持攻击中，攻击者创建了一个恶意网站，在该网站中，攻击者网页上方的透明iframe中加载了授权服务器URL。攻击者的网页堆放在iframe下方，并且有一些看似无害的按钮或链接，非常小心地放在授权服务器的确认按钮下面。当用户单击误导性可见按钮时，他们实际上是单击授权页面上的隐藏按钮，从而授予对攻击者应用程序的访问权限。这允许攻击者欺骗用户在他们不知情的情况下授予访问权限。</p>
<h5 id="对策-1"><a href="#对策-1" class="headerlink" title="对策"></a>对策</h5><p>通过确保授权URL始终直接在本机浏览器中加载，而不是嵌入在iframe中，可以防止这种攻击。较新的浏览器可以让授权服务器设置HTTP标头，X-Frame-Options旧版浏览器可以使用常见的Javascript“框架破坏”技术。</p>
<h4 id="重定向URL操作"><a href="#重定向URL操作" class="headerlink" title="重定向URL操作"></a>重定向URL操作</h4><p>攻击者可以使用属于已知正常应用程序的客户端ID构建授权URL，将重定向URL设置为攻击者控制下的URL。如果授权服务器未验证重定向URL，并且攻击者使用“令牌”响应类型，则用户将使用URL中的访问令牌返回到攻击者的应用程序。如果客户端是公共客户端，并且攻击者拦截授权码，则攻击者还可以通过授权码交换访问令牌。</p>
<p>另一个类似的攻击是攻击者可以欺骗用户的DNS，并且注册的重定向不是https URL。这将允许攻击者伪装成有效的重定向URL，并以这种方式窃取访问令牌。</p>
<p>“打开重定向”攻击是指授权服务器不需要重定向URL的完全匹配，而是允许攻击者构建将重定向到攻击者网站的URL。无论这是否最终被用于窃取授权码或访问令牌，这也是一个危险，因为它可以用于发起其他无关的攻击。有关Open Redirect攻击的更多详细信息，请访问<code>https://oauth.net/advisories/2014-1-covert-redirect/</code>。</p>
<h4 id="对策-2"><a href="#对策-2" class="headerlink" title="对策"></a>对策</h4><p>授权服务器必须要求应用程序注册一个或多个重定向URL，并且重定向到先前注册的URL必须完全匹配。</p>
<p>授权服务器还应要求所有重定向URL均为https。由于这有时会给开发人员带来负担，特别是在应用程序运行之前，在应用程序处于“开发阶段”时允许非https重定向URL并且只能由开发人员访问，然后要求在发布应用程序之前，重定向URL应更改为https URL。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--客户端注册]]></title>
      <url>/2018/07/13/oauth-guide-8/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>本章是对OAuth服务提供商的指导。</p>
<h3 id="注册新的应用程序"><a href="#注册新的应用程序" class="headerlink" title="注册新的应用程序"></a>注册新的应用程序</h3><p>当开发人员访问您的网站时，他们需要一种方法来创建新的应用程序并获取凭据。通常，您可以让他们在创建应用程序之前创建开发人员帐户，或代表其组织创建帐户。</p>
<p>虽然OAuth 2.0规范不要求您在授予凭据之前特别收集任何应用程序信息，但大多数服务会在发出client_id和client_secret之前收集有关应用程序的基本信息，例如应用程序名称和图标。但是，为了安全起见，您需要开发人员为应用程序注册一个或多个重定向URL，这一点非常重要。重定向URL中对此进行了更详细的说明。</p>
<p>通常，服务收集有关应用程序的信息，例如：</p>
<ul>
<li>应用名称</li>
<li>应用程序的图标</li>
<li>应用程序主页的URL</li>
<li>应用程序的简短描述</li>
<li>应用程序隐私策略的链接</li>
<li>重定向网址列表</li>
</ul>
<p>下面是GitHub用于注册应用程序的界面。在其中，它们收集应用程序名称，主页URL，回调URL和可选描述。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/github_create_new_application_1.png" alt="在Github上创建一个新的应用程序"><br>在GitHub上创建一个新的应用程序</p>
<p>最好向开发人员展示您从中收集的信息是显示给最终用户，还是仅供内部使用。</p>
<p>Foursquare的应用程序注册页面要求提供类似的信息，但他们还要求提供简短的标语和隐私政策URL。这些在授权提示中显示给用户。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/foursquare_create_new_application.png" alt="在Foursquare上创建一个新的应用程序"><br>在Foursquare上创建一个新的应用程序</p>
<p>由于使用隐式授权类型的安全性考虑因素，某些服务（例如Instagram）默认情况下会禁用新应用程序的此授权类型，并要求开发人员在应用程序的设置中明确启用它，如下所示。或者，该服务可以使开发人员选择他们正在创建的应用程序类型（公共或私有），并仅向私有应用程序发出密钥。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/instagram_create_new_application.png" alt="在Instagram上创建一个新的应用程序"><br>在Instagram上创建一个新的应用程序</p>
<p>Instagram还提供了一个说明，指示开发人员不要用可能使应用程序看起来来自Instagram的单词命名他们的应用程序。这也是包含API使用条款链接的优势。</p>
<h3 id="客户端ID和秘钥"><a href="#客户端ID和秘钥" class="headerlink" title="客户端ID和秘钥"></a>客户端ID和秘钥</h3><p>此时，您已构建了应用程序注册页面，您已准备好让开发人员注册该应用程序。当开发人员注册应用程序时，您需要生成客户端ID和可选的密钥。在生成这些字符串时，在安全性和美学方面需要考虑一些重要的事项。</p>
<h4 id="客户端ID"><a href="#客户端ID" class="headerlink" title="客户端ID"></a>客户端ID</h4><p>client_id是应用程序的公共标识符。即使它是公开的，最好是第三方无法猜测，因此许多实现使用类似32字符的十六进制字符串。它在授权服务器处理的所有客户端中也必须是唯一的。如果客户端ID是可猜测的，则可以更轻松地针对任意应用程序进行网络钓鱼攻击。</p>
<p>以下是来自支持OAuth 2.0的服务的客户端ID的一些示例：</p>
<ul>
<li>Foursquare： ZYDPLLBWSK3MVQJSIYHB1OR2JXCY0X2C5UJ2QAR2MAAIT5Q</li>
<li>Github： 6779ef20e75817b79602</li>
<li>Google： 292085223830.apps.googleusercontent.com</li>
<li>Instagram： f2a1ed52710d4533bde25be6da03b6e3</li>
<li>SoundCloud： 269d98e4922fb3895e9ae2108cbb5064</li>
<li>Windows Live： 00000000400ECB04</li>
</ul>
<p>如果开发人员正在创建“公共”应用程序（移动或单页应用程序），那么您根本不应该向应用程序发出client_secret。这是确保开发人员不会意外地将其包含在应用程序中的唯一方法。如果它不存在，它就不会泄露！</p>
<p>因此，您应该询问开发人员在启动时创建的应用程序类型。您可以向他们提供以下选项，并仅为“Web服务器”应用程序发出密钥。</p>
<ul>
<li>Web服务器应用程序</li>
<li>基于浏览器的应用</li>
<li>原生应用</li>
<li>移动应用</li>
</ul>
<p>当然，没有什么可以阻止开发人员选择错误的选项，但是通过主动询问开发人员将使用哪种类型的应用程序，您可以帮助减少泄露秘密的可能性。了解正在创建哪种类型的应用程序的另一个原因是您需要注册公共客户端的重定向URL，但是对于私有客户端，重定向URL的注册在技术上是可选的。有关详细信息，请参阅<a href="https://www.oauth.com/oauth2-servers/redirect-uris/redirect-uri-registration/" target="_blank" rel="noopener">重定向URI注册</a>。</p>
<h4 id="客户端密钥"><a href="#客户端密钥" class="headerlink" title="客户端密钥"></a>客户端密钥</h4><p>client_secret是只有应用程序和授权服务器知道的密钥。它必须足够随机以至于无法猜测，这意味着您应该避免使用常见的UUID库，这些库通常会考虑生成它的服务器的时间戳或MAC地址。生成安全密钥的一个好方法是使用加密安全库生成256位值并将其转换为十六进制表示。</p>
<p>在PHP中，您可以使用OpenSSL函数生成随机字节并转换为十六进制字符串：</p>
<pre><code class="php">bin2hex(openssl_random_pseudo_bytes(32));
</code></pre>
<p>或者在PHP 7及更高版本中，random_bytes可以使用内置函数。</p>
<p>在Ruby中，您可以使用SecureRandom库生成十六进制字符串：</p>
<pre><code class="ruby">require &#39;securerandom&#39;
SecureRandom.hex(32)
</code></pre>
<p>开发人员永远不要将其client_secret公开（基于移动或基于浏览器的）应用程序包含在内是至关重 为了帮助开发人员避免意外地执行此操作，最好使客户端密钥在视觉上与ID不同。这种方式当开发人员复制并粘贴ID和密钥时，很容易识别哪个是哪个。通常使用较长的字符串来表示密钥是一种很好的方式来表明这一点，或者在密钥前加上“密钥”或“私密”。</p>
<h4 id="存储和显示客户端ID和密钥"><a href="#存储和显示客户端ID和密钥" class="headerlink" title="存储和显示客户端ID和密钥"></a>存储和显示客户端ID和密钥</h4><p>对于每个注册的应用程序，您需要存储公共client_id和私有client_secret。因为这些本质上等同于用户名和密码，所以不应以纯文本格式存储密钥，而应仅存储加密或散列版本，以帮助降低秘密泄露的可能性。</p>
<p>当您发出客户端ID和密钥时，您需要将它们显示给开发人员。大多数服务为开发人员提供了一种检索现有应用程序密钥的方法，尽管有些服务只显示一次密钥并要求开发人员立即自行存储。如果您只显示一次密钥，则可以存储它的散列版本以避免存储明文密码。</p>
<p>如果您选择稍后可以向开发人员显示的方式存储密钥，则在披露密钥时应采取额外的预防措施。保护密钥的常用方法是在开发人员尝试检索密钥时插入“重新授权”提示。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/github_confirm_password.png" alt="GitHub重新授权提示"><br>GitHub在进行敏感更改时要求确认您的密码</p>
<p>该服务要求开发人员在泄密之前确认其密码。当您尝试查看或更新敏感信息时，这在Amazon或GitHub的网站中很常见。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/dropbox_show_secret.png" alt="Dropbox&#39;显示秘密&#39;确认"><br>Dropbox会隐藏秘密，直到被点击为止</p>
<p>此外，在开发人员点击“显示”之前模糊应用程序详细信息页面上的密钥是防止意外泄露秘密的好方法。</p>
<h3 id="删除应用程序和撤消秘钥"><a href="#删除应用程序和撤消秘钥" class="headerlink" title="删除应用程序和撤消秘钥"></a>删除应用程序和撤消秘钥</h3><p>开发人员需要一种方法来删除（或至少停用）他们的应用程序。为开发人员提供一种方法来撤销秘钥，并为其应用程序生成新的客户端密钥也是一个好主意。</p>
<h4 id="删除应用程序"><a href="#删除应用程序" class="headerlink" title="删除应用程序"></a>删除应用程序</h4><p>当开发人员删除应用程序时，该服务应通知开发人员删除应用程序的后果。例如，GitHub告诉开发人员将撤销所有访问令牌，以及将受影响的用户数量。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1ftfbpd4ohnj30d106e0tk.jpg" alt="GitHub删除应用程序提示"><br>GitHub要求确认删除申请</p>
<p>删除应用程序应立即撤消颁发给应用程序的所有访问令牌和其他凭据，例如待处理的授权代码和刷新令牌。</p>
<h4 id="撤销秘钥"><a href="#撤销秘钥" class="headerlink" title="撤销秘钥"></a>撤销秘钥</h4><p>该服务应该为开发人员提供重置客户端密钥的方法。在秘钥被意外暴露的情况下，开发人员需要一种方法来确保可以撤销旧秘密。撤销秘密不一定会使用户的访问令牌无效，因为如果开发人员想要使所有用户令牌无效，他们也可以随时删除该应用程序。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ftfbqqm2vzj30d607kq40.jpg" alt="GitHub重置客户端密码提示"><br>GitHub要求确认重置应用程序的秘钥</p>
<p>重置密钥应该保持所有现有的访问令牌都处于活动状态。但是，这确实意味着使用旧秘钥的任何已部署应用程序将无法使用旧秘钥刷新访问令牌。部署的应用程序需要在能够使用刷新令牌之前更新其秘密。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--进行身份验证请求]]></title>
      <url>/2018/07/13/oauth-guide-7/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>无论您使用哪种授权类型，或者您是否使用了客户端密钥，您现在都可以使用API​​来使用OAuth 2.0 Bearer Token。</p>
<p>API服务器可以通过两种方式接受Bearer Token。一个在HTTP Authorization标头中，另一个在post body参数中。它取决于它支持的服务，因此您需要检查文档以确定。</p>
<p>在HTTP标头中传入访问令牌时，您应该发出如下请求：</p>
<pre><code class="bash">POST /resource/1/update HTTP/1.1
Authorization: Bearer RsT5OjbzRn430zqMLgV3Ia&quot;
Host: api.authorization-server.com

description=Hello+World
</code></pre>
<p>如果服务接受帖子正文中的访问令牌，那么您可以发出如下请求：</p>
<pre><code class="bash">POST /resource/1/ HTTP/1.1
Host: api.authorization-server.com

access_token=RsT5OjbzRn430zqMLgV3Ia
&amp;description=Hello+World
</code></pre>
<p>请注意，由于OAuth 2.0规范实际上并不需要上面的任何一个选项，因此您必须阅读与之交互的特定服务的API文档，以了解它们是否支持post body参数或HTTP标头。</p>
<p>访问令牌不应由您的应用程序解析。你应用程序唯一应该做的就是使用它来发出API请求。一些服务将使用结构化令牌（如JWT）作为其访问令牌，但客户端在这种情况下无需担心解码令牌。</p>
<p>实际上，尝试解码访问令牌是危险的，因为服务器不保证访问令牌将始终保持相同的格式。完全有可能在下次从服务获得访问令牌时，它将采用不同的格式。要记住的是，访问令牌对客户端是不透明的，并且应该仅用于发出API请求而不是自己解释。</p>
<p>如果您试图找出您的访问令牌是否已过期，您可以存储您第一次获得访问令牌时返回的过期时间，或者只是尝试发出请求查看当前令牌是否过期，并获取新的访问令牌。</p>
<p>如果您正在尝试查找有关登录用户的更多信息，您应该阅读特定服务的API文档以了解他们的建议。例如，Google的API使用OpenID Connect提供userinfo endpoint，该endpoint可以返回有关给定访问令牌的用户的信息。</p>
<h3 id="刷新访问令牌"><a href="#刷新访问令牌" class="headerlink" title="刷新访问令牌"></a>刷新访问令牌</h3><p>当您最初收到访问令牌时，它可能包含刷新令牌以及到期时间，如下例所示。</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;AYjcyMzY3ZDhiNmJkNTY&quot;,
  &quot;refresh_token&quot;: &quot;RjY2NjM5NzA2OWJjuE7c&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;expires&quot;: 3600
}
</code></pre>
<p>刷新令牌的存在意味着访问令牌将过期，您将能够在没有用户交互的情况下获得新令牌。</p>
<p>“expires”值是访问令牌有效的秒数。这取决于令牌服务的提供商，并且可能取决于应用程序或组织自己的策略。您可以使用它来抢先刷新访问令牌，而不是等待带有过期令牌的请求失败。</p>
<p>如果您发出API请求并且令牌已经过期，您将收到一个指示响应。您可以检查此特定错误消息，然后刷新令牌并再次尝试请求。</p>
<p>如果您使用的是基于JSON的API，则可能会返回带有invalid_token错误的JSON错误响应。在一些情况下，WWW-Authenticate header也会出现invalid_token错误。</p>
<pre><code class="bash">HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer error=&quot;invalid_token&quot;
  error_description=&quot;The access token expired&quot;
Content-type: application/json

{
  &quot;error&quot;: &quot;invalid_token&quot;,
  &quot;error_description&quot;: &quot;The access token expired&quot;
}
</code></pre>
<p>当您的代码识别出此特定错误时，它可以使用之前收到的刷新令牌向令牌endpoint发出请求，并返回可用于重试原始请求的新访问令牌。</p>
<p>要使用刷新令牌，请向服务的令牌endpoint发出POST请求grant_type=refresh_token，并包括刷新令牌和客户端凭据。</p>
<pre><code class="bash">POST /oauth/token HTTP/1.1
Host: authorization-server.com

grant_type=refresh_token
&amp;amp;refresh_token=xxxxxxxxxxx
&amp;amp;client_id=xxxxxxxxxx
&amp;amp;client_secret=xxxxxxxxxx
</code></pre>
<p>响应将是新的访问令牌，也可能包含新的刷新令牌，就像您在交换访问令牌的授权代码时收到的那样。</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;BWjcyMzY3ZDhiNmJkNTY&quot;,
  &quot;refresh_token&quot;: &quot;Srq2NjM5NzA2OWJjuE7c&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;expires&quot;: 3600
}
</code></pre>
<p>如果您没有获得新的刷新令牌，那么这意味着当新的访问令牌到期时，您现有的刷新令牌将继续工作。</p>
<p>请记住，用户可以在任何时候撤销应用程序 ，因此，当刷新访问令牌也失败时，您的应用程序需要能够处理这种情况。此时，您需要再次提示用户进行授权。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--移动和原生应用]]></title>
      <url>/2018/07/13/oauth-guide-6/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>与单页应用程序一样，移动应用程序也无法保持客户机密的机密性。因此，移动应用还必须使用不需要客户端密钥的OAuth流程。当前的最佳做法是使用授权流程以及启动外部浏览器，以确保本机应用程序无法修改浏览器窗口或检查内容。</p>
<p>许多网站都提供移动SDK，为您处理授权过程。对于这些网站，你最好直接使用他们的SDK，因为他们可能用非标准的方式添加增加了他们的API。Google提供了一个名为AppAuth的开源库，它可以处理下面描述的流程的实现细节。它旨在能够与任何实现规范的OAuth 2.0服务器一起使用。如果服务不提供自己的抽象，并且您必须直接使用其OAuth 2.0的endpoint，你就可以参照本节介绍来了解如何使用授权与API进行交互。</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>创建一个“登录”按钮，该按钮将打开SFSafariViewController或启动本机浏览器。您将使用与服务器端应用程序中所述相同的授权请求参数。</p>
<p>对于本机应用程序的重定向URL，在iOS上，应用程序可以注册像<code>org.example.app://</code>这样的自定义URL scheme，只要访问具有该scheme的URL，就会启动应用程序。在Android上，应用程序可以注册URL匹配模式，如果访问了与模式匹配的URL，则会启动本机应用程序。</p>
<h3 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h3><p>在这个例子中，我们将创建一个简单的iPhone应用程序，获取访问虚构API的授权。</p>
<h4 id="应用程序启动授权请求"><a href="#应用程序启动授权请求" class="headerlink" title="应用程序启动授权请求"></a>应用程序启动授权请求</h4><p>要开始授权过程，应用程序应该有一个“登录”按钮。该链接应构建为服务授权endpoint的完整URL。</p>
<p>授权URL通常采用以下格式：</p>
<pre><code class="http">https://authorization-server.com/authorize
?client_id=eKNjzFFjH9A1ysYd
&amp;response_type=code
&amp;redirect_uri=exampleapp://auth
&amp;state=1234zyx
</code></pre>
<p>在这种情况下请注意重定向URL的自定义方案。iOS提供了应用程序注册自定义URL方案的功能。在Android上，应用可以改为匹配特定的网址模式，以便应用在访问特定网址时在应用列表中显示并进行处理。在iOS上，您应该在应用程序的.plist文件中注册您将使用的自定义方案。这将导致设备在访问以您的自定义方案开头的URL时启动您的应用，包括移动版Safari或其他iOS应用。</p>
<p>当用户点击“登录”按钮时，应用程序应用SFSafariViewController打开共享系统cookie的嵌入式浏览器来打开登录URL。WebView在应用程序中使用嵌入式窗口被认为是非常危险的，因为这使用户无法保证他们正在查看服务自己的网站，并且是网络钓鱼攻击的简单来源。通过使用SFSafariViewController共享Safari cookie的API，您可以知道用户是否已经登录该服务。</p>
<h4 id="用户批准该请求"><a href="#用户批准该请求" class="headerlink" title="用户批准该请求"></a>用户批准该请求</h4><p>在被定向到auth服务器时，用户看到如下所示的授权请求。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/sfsafariviewcontroller-example.png" alt="内置浏览器"></p>
<p>嵌入式SFSafariViewController。右上角的“完成”按钮折叠视图并将用户返回到应用程序。</p>
<h4 id="该服务将用户重定向回应用程序"><a href="#该服务将用户重定向回应用程序" class="headerlink" title="该服务将用户重定向回应用程序"></a>该服务将用户重定向回应用程序</h4><p>当用户完成登录后，该服务将重定向回您的应用程序的重定向URL，在这种情况下，该URL具有一个自定义方案，该方案将触发您的应用程序委托的application:openURL:options:方法。Location重定向的标题将类似于以下内容，它将作为url参数传递给您的方法。</p>
<pre><code class="html">org.example.app://auth?state=1234zyx
&amp;code=lS0KgilpRsT07qT_iMOg9bBSaWqODC1g061nSLsa8gV2GYtyynB6A
</code></pre>
<p>然后，您的应用应该从URL解析授权码，交换代码以获取访问令牌，并关闭SFSafariViewController。除了不使用客户端密钥之外，交换访问令牌的代码与授权代码流中的代码相同。</p>
<h3 id="安全考虑因素"><a href="#安全考虑因素" class="headerlink" title="安全考虑因素"></a>安全考虑因素</h3><h4 id="始终打开本机浏览器或使用-SFSafariViewController"><a href="#始终打开本机浏览器或使用-SFSafariViewController" class="headerlink" title="始终打开本机浏览器或使用 SFSafariViewController"></a>始终打开本机浏览器或使用 SFSafariViewController</h4><p>您永远不应该使用OAuth提示打开嵌入式Web视图，因为它无法让用户验证他们正在查看的网页的来源。攻击者会创建一个看起来就像授权网页并将其嵌入到自己的恶意应用程序中的网页，让他们能够窃取用户名和密码。</p>
<h4 id="PKCE"><a href="#PKCE" class="headerlink" title="PKCE"></a>PKCE</h4><p>如果您使用的服务支持PKCE扩展（<a href="https://tools.ietf.org/html/rfc7636" target="_blank" rel="noopener">RFC 7636</a>），那么您应该利用它提供的额外安全性。通常，例如在使用Google OAuth API的情况下，服务提供的本机SDK将透明地处理此问题，因此您无需担心详细信息，并且无需任何额外工作即可从额外的安全性中受益。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--单页应用]]></title>
      <url>/2018/07/13/oauth-guide-5/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>从网页加载Javascript和HTML源代码后，单页应用程序（或基于浏览器的应用程序）将会完全在浏览器中运行。由于浏览器可以使用所有源代码，因此无法保持客户端密钥的机密性，因此这些应用程序不会使用该密钥。该流程与授权代码流完全相同，但在最后一步，授权码在不使用客户端密钥的情况下交换访问令牌。</p>
<p>下图是用户与浏览器进行交互的示例，该浏览器直接向服务发出API请求。在首次从客户端下载Javascript和HTML源代码之后，浏览器会直接向服务发出API请求。在这种情况下，应用程序的服务器永远不会向服务发出API请求，因为所有事情都是直接在浏览器中处理的。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/okta_oauth-diagrams.png" alt="用户的浏览器直接与API服务器通信"></p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权码是客户端交换访问令牌的临时代码。代码本身从授权服务器获得，用户可以查看客户端请求的信息，并批准或拒绝该请求。</p>
<p>Web流程的第一步是请求用户授权。这是通过为用户创建单击的授权请求链接来完成的。</p>
<p>授权URL通常采用以下格式：</p>
<pre><code class="html">https://authorization-server.com/oauth/authorize
  ?client_id=a17c21ed
  &amp;response_type=code
  &amp;state=5ca75bd30
  &amp;redirect_uri=https%3A%2F%2Fexample-app.com%2Fauth
</code></pre>
<p>用户访问授权页面后，服务会向用户显示请求的解释，包括应用程序名称，范围等。如果用户单击“批准”，服务器将重定向回网站，并附带授权码和URL查询字符串中的state值。</p>
<h3 id="授权请求参数"><a href="#授权请求参数" class="headerlink" title="授权请求参数"></a>授权请求参数</h3><p>以下参数用于发出授权请求。</p>
<blockquote>
<p><strong>client_id</strong><br>这client_id是您的应用的标识符。首次向服务注册您的应用程序时，您将收到一个client_id。</p>
<p><strong>response_type</strong><br>response_type设置为code表示您希望以授权码作为响应。</p>
<p><strong>redirect_uri （可选的）</strong><br>该redirect_uri是在规范中可选的，但是有些服务需要它。这是您希望在授权完成后将用户重定向到的URL。这必须与您先前在服务中注册的重定向URL相匹配。</p>
<p><strong>scope （可选的）</strong><br>包括一个或多个范围值以请求其他访问级别。这些值将取决于特定的服务。</p>
<p><strong>state （推荐的）</strong><br>该state参数有两个功能。当用户被重定向回您的应用程序时，您在状态中包含的任何值都将包含在重定向中。这使您的应用程序有机会在被定向到授权服务器的用户和再次返回之间保留数据，例如使用state参数作为会话密钥。这可用于指示在授权完成后应用中要执行的操作，例如，指示在授权后要重定向到应用的哪个页面。这也可以作为CSRF保护机制。当用户重定向回您的应用程序时，请仔细检查状态值是否与您最初设置的值相匹配。这将确保攻击者无法拦截授权流程。</p>
<p>请注意，缺少使用客户端密钥意味着使用state参数对单页应用程序更为重要。</p>
</blockquote>
<h3 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h3><p>以下分步示例说明了对单页应用程序使用授权授予类型。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="应用程序启动授权请求"><a href="#应用程序启动授权请求" class="headerlink" title="应用程序启动授权请求"></a>应用程序启动授权请求</h5><p>应用程序通过制作包含ID的URL以及可选的scope和state来启动流程。该应用程序可以将其放入<code>&lt;a href=&quot;&quot;&gt;</code>标签中。</p>
<pre><code class="html">&lt;a href=&quot;https://authorization-server.com/authorize?response_type=code
     &amp;client_id=mRkZGFjM&amp;state=TY2OTZhZGFk&quot;&gt;Connect Your Account&lt;/a&gt;
</code></pre>
<h5 id="用户批准该请求"><a href="#用户批准该请求" class="headerlink" title="用户批准该请求"></a>用户批准该请求</h5><p>在被定向到auth服务器时，用户看到授权请求。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/okta_oauth-diagrams-approve.png" alt="示例授权请求"></p>
<p>用户被带到服务并看到请求后，他们将允许或拒绝该请求。如果他们允许请求，他们将被重定向回重定向URL以及查询字符串中的授权码。然后，该应用程序需要交换授权码以获得访问令牌。</p>
<pre><code class="http">https://example-app.com/cb?code=Yzk5ZDczMzRlNDEwY&amp;state=TY2OTZhZGFk
</code></pre>
<p>如果您在初始授权网址中包含“state”参数，则该服务会在用户授权您的应用后将其返回给您。你的应用程序应该将state参数与它在初始请求中创建的state餐素进行比较。这有助于确保您只交换您请求的授权码，防止攻击者使用任意或被盗的授权码重定向到您的回调URL。</p>
<h5 id="交换访问令牌的授权码"><a href="#交换访问令牌的授权码" class="headerlink" title="交换访问令牌的授权码"></a>交换访问令牌的授权码</h5><p>要交换访问令牌的授权码，应用程序会向服务的令牌endpoint发出POST请求。请求将具有以下参数。</p>
<blockquote>
<p><strong>grant_type （需要）</strong><br>该grant_type参数必须设置为“authorization_code”。</p>
<p><strong>code （需要）</strong><br>此参数用于从授权服务器接收的授权代码，该授权代码将位于此请求中的查询字符串参数“code”中。</p>
<p><strong>redirect_uri （可能需要）</strong><br>如果重定向URL包含在初始授权请求中，则它也必须包含在令牌请求中，并且必须相同。某些服务支持注册多个重定向URL，有些服务需要在每个请求上指定重定向URL。请查看服务的文档以了解具体信息。</p>
<p><strong>客户端识别ID（必填）</strong><br>尽管客户端密钥未在此流程中使用，但该请求需要发送客户端ID以识别发出请求的应用程序。这意味着客户端必须将客户端ID包含为POST主体参数，而不是像包含客户端密钥时那样使用HTTP基本认证。</p>
</blockquote>
<pre><code class="bash">POST /oauth/token HTTP/1.1
  Host: authorization-endpoint.com
  grant_type=code
  &amp;code=Yzk5ZDczMzRlNDEwY
  &amp;redirect_uri=https://example-app.com/cb
  &amp;client_id=mRkZGFjM
</code></pre>
<h3 id="隐式流程"><a href="#隐式流程" class="headerlink" title="隐式流程"></a>隐式流程</h3><p>有些服务使用隐式流程用于单页面应用程序，而不是允许应用程序毫无限制地使用授权码流程。</p>
<p>隐式流程绕过代码交换步骤，而是将查询字符串片段中的访问令牌立即返回给客户端。</p>
<p>在实践中，只有非常有限的情况需要这样做。几个主要的实现（Keycloak，Deutsche Telekom，Smart Health IT）选择完全避免隐式流程并使用授权码流程。</p>
<p>为了使单页应用程序使用授权码流程，它必须能够向授权服务器发出POST请求。这意味着如果授权服务器位于不同的域上，则服务器将需要支持相应的CORS头。如果不支持CORS头，则服务可以使用隐式流程。</p>
<p>在任何情况下，对于隐式流程以及授权码流程来说，都没有客户端秘钥，服务器必须要求注册重定向URL以保持流程的安全性。</p>
<h4 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h4><p>通过使用“state”参数并将重定向URL限制为可认证客户端，这是授权代码授予无客户端密钥的客户端的唯一安全方法。由于没有使用密钥，除了使用注册的重定向URL之外，没有办法验证客户的身份。这就是为什么您需要使用OAuth 2.0服务预先注册您的重定向网址。</p>
<p>尽管OAuth 2.0规范并不特别要求重定向URL使用TLS加密，但强烈建议您使用它。不需要的唯一原因是因为部署SSL网站对许多开发人员来说仍然是一个障碍，这将阻碍规范的广泛采用。有些API确实需要https作为重定向端点，但许多API仍然没有。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--服务器端应用程序]]></title>
      <url>/2018/07/13/oauth-guide-4/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>服务器端应用程序是处理OAuth 2服务器时遇到的最常见的应用程序类型。这些应用程序在Web服务器上运行，其中应用程序的源代码不可供公众使用，因此他们可以保持其客户端秘钥的机密性。</p>
<p>下图说明了用户与正在与客户端通信的浏览器进行交互的典型示例。客户端和API服务器之间具有单独的安全通信通道。用户的浏览器从不直接向API服务器发出请求，所有内容都先通过客户端。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftf3o8318wj30p006edfx.jpg" alt="应用程序的服务器与API通信"></p>
<p>服务器端应用程序使用authorization_code授权类型。在此流程中，在用户授权应用程序之后，应用程序接收“授权码”，然后它可以交换访问令牌。</p>
<h3 id="授权码授予"><a href="#授权码授予" class="headerlink" title="授权码授予"></a>授权码授予</h3><p>授权码是客户端将为访问令牌交换的临时代码。代码本身从授权服务器获得，其中用户有机会查看客户端请求的信息，并批准或拒绝该请求。</p>
<p>授权码流程与其他授权类型相比具有一些优势。当用户授权应用程序时，会带着URL中的临时代码返回应用程序。应用程序有这个代码来交换访问令牌。当应用程序发出访问令牌请求时，该请求将使用客户端密钥进行身份验证，从而降低攻击者拦截授权码并自行使用它的风险。这也意味着访问令牌永远不会被用户看到，因此这是将令牌传递回应用程序的最安全方式，从而降低令牌泄露给其他人的风险。</p>
<p>Web流程的第一步是请求用户授权。这是通过创建用户单击的授权请求链接来完成的。</p>
<p>授权URL通常采用以下格式：</p>
<pre><code class="http">https://authorization-server.com/oauth/authorize
?client_id=a17c21ed
&amp;response_type=code
&amp;state=5ca75bd30
&amp;redirect_uri=https%3A%2F%2Fexample-app.com%2Fauth
</code></pre>
<p>确切的URL endpoint将由您要连接的服务指定，但参数名称将始终相同。</p>
<p>请注意，在接受服务之前，您很可能首先需要在服务中注册重定向URL。这也意味着您无法根据请求更改重定向网址。相反，您可以使用该state参数来自定义请求。</p>
<p>用户访问授权页面后，该服务会向用户显示请求的说明，包括应用程序名称，范围等。如果用户单击“批准”，则服务器将使用您在查询字符串参数中提供的“code”和相同的“state”参数重定向回应用程序。请务必注意，这不是访问令牌。您可以使用授权码执行的唯一操作是发出获取访问令牌的请求。</p>
<h4 id="授权授予参数"><a href="#授权授予参数" class="headerlink" title="授权授予参数"></a>授权授予参数</h4><p>以下参数用于授予授权。您应该使用以下参数构建一个查询字符串，并将其附加到从其文档中获取的应用程序的授权endpoint后。</p>
<blockquote>
<p><strong>response_type=code</strong><br>response_type设置为code表示您希望将授权码作为响应。</p>
<p><strong>client_id</strong><br>client_id是您的应用的标识符。首次向服务注册您的应用时，您将收到client_id。</p>
<p><strong>redirect_uri （可选的）</strong><br>redirect_uri是可选的，但强烈建议你添加。这是您希望在授权完成后将用户重定向到的URL。这必须与您先前在服务中注册的重定向URL相匹配。</p>
<p><strong>scope （可选的）</strong><br>包括一个或多个范围值（以空格分隔）以请求其他访问级别。它的值取决于特定服务。</p>
<p><strong>state （推荐的）</strong><br>state参数有两个功能。当用户被重定向回您的应用程序时，您在state中包含的任何值都将包含在重定向中。这使您的应用程序有机会在用户被定向到授权服务器和再次返回之间保留数据，例如使用state参数作为会话密钥。也可用于指示在授权完成后应用中要执行的操作，例如，指示在授权后应该重定向到应用的哪个页面。也可以作为CSRF保护机制。当用户重定向回您的应用程序时，请仔细检查state值是否与您最初设置的值相匹配。这将确保攻击者无法拦截授权流程。</p>
</blockquote>
<p>将所有这些查询字符串参数组合到登录URL中，并将用户的浏览器定向到那里。通常，应用程序会将这些参数放入登录按钮，或者从应用程序自己的登录URL发送重定向到此URL。</p>
<h4 id="用户批准该请求"><a href="#用户批准该请求" class="headerlink" title="用户批准该请求"></a>用户批准该请求</h4><p>在用户进入服务并看到请求后，他们将允许或拒绝该请求。如果他们允许请求，他们将带着查询字符串中的授权码，并被重定向回指定的重定向URL。然后，应用程序需要使用此授权码交换访问令牌。</p>
<h4 id="交换访问令牌的授权码"><a href="#交换访问令牌的授权码" class="headerlink" title="交换访问令牌的授权码"></a>交换访问令牌的授权码</h4><p>要使用授权码交换访问令牌，应用程序会向服务的令牌endpoint发出POST请求。请求将具有以下参数。</p>
<blockquote>
<p><strong>grant_type （需要）</strong><br>grant_type参数必须设置为“authorization_code”。</p>
<p><strong>code （需要）</strong><br>查询字符串参数“code”中存放从授权服务器接收的授权码。</p>
<p><strong>redirect_uri （可能需要）</strong><br>如果重定向URL包含在初始授权请求中，则它也必须包含在令牌请求中，并且必须相同。某些服务支持注册多个重定向URL，有些服务需要在每个请求上指定重定向URL。请查看服务的文档以了解具体信息。</p>
</blockquote>
<h4 id="客户端验证（必填）"><a href="#客户端验证（必填）" class="headerlink" title="客户端验证（必填）"></a>客户端验证（必填）</h4><p>该服务将要求客户端在发出访问令牌请求时进行身份验证。通常，服务通过HTTP Basic Auth来进行客户端身份验证，并使用客户端的client_id和client_secret。但是，某些服务通过接受client_id和client_secret作为POST body参数来支持身份验证。检查服务的文档以找出服务所期望的内容，因为OAuth 2.0规范将此决定留给了服务。</p>
<h3 id="示例流程"><a href="#示例流程" class="headerlink" title="示例流程"></a>示例流程</h3><p>以下逐步说明示例使用授权代码授予类型。</p>
<p>步骤：</p>
<ul>
<li>使用应用程序的客户端ID，重定向URL和state参数创建登录链接</li>
<li>用户看到授权提示并批准该请求</li>
<li>用户带着授权码重定向回应用程序的服务器</li>
<li>应用程序使用授权码交换访问令牌</li>
</ul>
<h4 id="应用程序启动授权请求"><a href="#应用程序启动授权请求" class="headerlink" title="应用程序启动授权请求"></a>应用程序启动授权请求</h4><p>应用程序通过制作包含ID，scope和state的URL来启动流程。该应用程序可以将其放入<code>&lt;a href=&quot;&quot;&gt;</code>标签中。</p>
<pre><code class="html">&lt;a href=&quot;https://authorization-server.com/oauth/authorize
?response_type=code&amp;client_id=mRkZGFjM&amp;state=5ca75bd30&quot;&gt;
Connect Your Account&lt;/a&gt;
</code></pre>
<h4 id="用户批准该请求-1"><a href="#用户批准该请求-1" class="headerlink" title="用户批准该请求"></a>用户批准该请求</h4><p>在被定向到auth服务器后，用户会看到下图所示的授权请求。如果用户批准该请求，他们将带着授权码和state参数重定向回应用程序。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftf5fephk0j30kw0bw0t3.jpg" alt="示例授权请求"></p>
<h4 id="服务将用户重定向回应用程序"><a href="#服务将用户重定向回应用程序" class="headerlink" title="服务将用户重定向回应用程序"></a>服务将用户重定向回应用程序</h4><p>服务将用户重定向回发出请求的应用程序。重定向将在URL中包含“code”和原始的“state”参数。</p>
<pre><code class="http">https://example-app.com/cb?code=Yzk5ZDczMzRlNDEwY&amp;state=5ca75bd30
</code></pre>
<h4 id="应用程序使用授权吗交换访问令牌"><a href="#应用程序使用授权吗交换访问令牌" class="headerlink" title="应用程序使用授权吗交换访问令牌"></a>应用程序使用授权吗交换访问令牌</h4><p>该应用程序使用授权码，通过向授权服务器发出POST请求来获取访问令牌。</p>
<pre><code class="bash">POST /oauth/token HTTP/1.1
Host: authorization-server.com

code=Yzk5ZDczMzRlNDEwY
&amp;grant_type=code
&amp;redirect_uri=https://example-app.com/cb
&amp;client_id=mRkZGFjM
&amp;client_secret=ZGVmMjMz
</code></pre>
<p>auth服务器验证请求，并返回访问令牌和访问令牌过期时使用的刷新令牌。</p>
<p>响应：</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;AYjcyMzY3ZDhiNmJkNTY&quot;,
  &quot;refresh_token&quot;: &quot;RjY2NjM5NzA2OWJjuE7c&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;expires&quot;: 3600
}
</code></pre>
<h3 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h3><p>有几种情况下，您可能会在授权期间收到错误响应。</p>
<p>错误会通过在返回的重定向URL的查询字符串提示。重定向URL总会有一个错误参数，也可能包含error_description和error_uri。</p>
<p>例如:<br><code>https://example-app.com/cb?error=invalid_scope</code></p>
<p>尽管服务器返回error_description密钥，但错误描述并不打算显示给用户。相反，您应该向用户显示您自己的错误消息。这允许您告诉用户采取适当的措施来纠正问题，并且如果您正在构建多语言网站，还可以让您有机会本地化错误消息。</p>
<h4 id="无效的重定向网址"><a href="#无效的重定向网址" class="headerlink" title="无效的重定向网址"></a>无效的重定向网址</h4><p>如果提供的重定向URL无效，则auth服务器不会重定向到它。相反，它可以向用户显示描述问题的信息。</p>
<h4 id="无法识别-client-id"><a href="#无法识别-client-id" class="headerlink" title="无法识别 client_id"></a>无法识别 client_id</h4><p>如果无法识别客户端ID，则auth服务器不会重定向用户。相反，它可能会显示一条描述问题的信息。</p>
<h4 id="用户拒绝该请求"><a href="#用户拒绝该请求" class="headerlink" title="用户拒绝该请求"></a>用户拒绝该请求</h4><p>如果用户拒绝授权请求，则服务器会将用户重定向包含error=access_denied查询字符串的重定向URL ，并且不会出现code字段。由应用程序决定此时向用户显示的内容。</p>
<h4 id="无效的参数"><a href="#无效的参数" class="headerlink" title="无效的参数"></a>无效的参数</h4><p>如果一个或多个参数无效，例如缺少必需值，或者response_type参数错误，服务器将重定向到重定向URL并包含描述问题的查询字符串参数。</p>
<p>error参数的其他可能值为：</p>
<ul>
<li>invalid_request：请求缺少必需参数，包含无效参数值，或者格式错误。</li>
<li>unauthorized_client：客户端无权使用此方法请求授权码。</li>
<li>unsupported_response_type：授权服务器不支持使用此方法获取授权码。</li>
<li>invalid_scope：请求的范围无效，未知或格式错误。</li>
<li>server_error：授权服务器遇到意外情况，导致无法完成请求。</li>
<li>temporarily_unavailable：由于服务器临时过载或维护，授权服务器当前无法处理请求。</li>
</ul>
<p>此外，服务器可以包括参数error_description和error_uri关于错误的附加信息。</p>
<h3 id="用户体验考虑事项"><a href="#用户体验考虑事项" class="headerlink" title="用户体验考虑事项"></a>用户体验考虑事项</h3><p>为了使授权代码授权生效，授权页面必须出现在用户熟悉的Web浏览器中，并且不得嵌入到iframe弹出窗口或移动到应用程序中的嵌入式浏览器中。因此，对于传统的“Web应用程序”来说，用户已经在Web浏览器中并且重定向到服务器的授权页面的这种操作，是最适用的。</p>
<h3 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h3><p>授权码授权是为可以保护其客户端ID和密钥的客户端设计的。因此，最适合不提供其源代码的在服务器上运行的网络应用程序。</p>
<p>如果应用程序想要使用授权代码授权但无法保护其密钥（即本机移动应用程序），则在请求交换访问令牌的授权代码时就不需要客户端密钥。但是，某些服务不接受没有客户端密钥的授权码交换，因此本机应用程序可能需要为这些服务使用备用方法。</p>
<p>尽管OAuth 2.0规范并不特别要求重定向URL使用TLS加密，但我强烈建议您使用它。不需要的唯一原因是因为部署SSL网站对许多开发人员来说仍然是一个障碍，这将阻碍规范的广泛采用。有些API确实需要https作为重定向端点，但许多API仍然没有这样要求。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--使用Google登录]]></title>
      <url>/2018/07/13/oauth-guide-3/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>尽管OAuth是<strong>授权协议</strong>而不是<strong>身份验证协议</strong>，但它通常用作身份验证工作流程的基础。许多常见OAuth API的典型用途是在登录第三方应用程序时识别当前用户。</p>
<p>身份验证和授权经常相互混淆，但如果从应用程序的角度考虑它们，则可以更容易理解。正在验证用户的应用只是验证用户是谁。授权用户的应用程序正在尝试访问或修改属于该用户的内容。</p>
<p>OAuth被设计为授权协议，因此每个OAuth流程的最终结果是应用程序获取访问令牌，以便能够访问或修改有关用户帐户的内容。访问令牌本身并未说明用户是谁。</p>
<p>有几种方法可以让不同的服务为应用程序提供一种查找用户身份的方法。一种简单的方法是API提供“用户信息”的endpoint，当使用访问令牌访问API时，该endpoint将返回经过身份验证的用户的名称和其他配置文件信息。虽然这不是OAuth标准的一部分，但它是许多服务采用的常见方法。更高级和标准化的方法是使用OAID 2.0扩展的OpenID Connect。OpenID Connect在后面有更详细的介绍。</p>
<p>本章将使用简化的OpenID Connect工作流程和Google API来识别用户并登录到您的应用程序。</p>
<h3 id="创建一个应用程序"><a href="#创建一个应用程序" class="headerlink" title="创建一个应用程序"></a>创建一个应用程序</h3><p>在我们开始之前，我们需要在Google API控制台中创建一个应用程序，以获取客户端ID和客户端秘钥，并注册重定向URL。</p>
<p>访问<code>https://console.developers.google.com/</code>并创建一个新项目。您还需要为项目创建OAuth 2.0凭据，因为Google不会自动执行此操作。在侧栏中，单击“Credentials”选项卡，然后单击“Create credentials”并从下拉列表中选择“OAuth client ID”。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftdy5lw1czj30sg0jwn09.jpg" alt="创建一个应用程序"></p>
<p>Google控制台会提示您提供有关您的应用程序的一些信息，例如产品名称，主页和logo。在下一页上，选择”Web application”类型，然后输入重定向URL。这样，您就会收到客户端ID和秘钥。</p>
<h3 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h3><p>本章节示例代码是用PHP编写的，不需要外部包，也不需要框架，这可以很容易地翻译成其他语言。要模仿此示例代码，您应该将它全部放在一个PHP文件中。</p>
<p>创建一个新文件夹并在该文件夹中创建一个空文件<code>index.php</code>。从该文件夹内部运行的命令行输入<code>php -S localhost:8000</code>，您将能够在浏览器中访问<code>http://localhost:8000</code>来运行您的代码。以下示例中的所有代码都应添加到此index.php文件中。</p>
<p>让我们为OAuth流程设置一些变量，添加我们在创建应用程序时从Google获得的客户端ID和秘钥。</p>
<pre><code class="php">// Fill these out with the values you got from Google
$googleClientID = &#39;&#39;;
$googleClientSecret = &#39;&#39;;

// This is the URL we&#39;ll send the user to first
// to get their authorization
$authorizeURL = &#39;https://accounts.google.com/o/oauth2/v2/auth&#39;;

// This is Google&#39;s OpenID Connect token endpoint
$tokenURL = &#39;https://www.googleapis.com/oauth2/v4/token&#39;;

// The URL for this script, used as the redirect URL
$baseURL = &#39;https://&#39; . $_SERVER[&#39;SERVER_NAME&#39;]
    . $_SERVER[&#39;PHP_SELF&#39;];

// Start a session so we have a place
// to store things between redirects
session_start();
</code></pre>
<p>定义了这些变量，并开始会话，让我们设置登录和注销的页面。我们将显示一个超级简单的页面，它只是指示用户是否已登录，并且具有登录或注销的链接。</p>
<pre><code class="php">// If there is a user ID in the session
// the user is already logged in
if(!isset($_GET[&#39;action&#39;])) {
  if(!empty($_SESSION[&#39;user_id&#39;])) {
    echo &#39;&lt;h3&gt;Logged In&lt;/h3&gt;&#39;;
    echo &#39;&lt;p&gt;User ID: &#39;.$_SESSION[&#39;user_id&#39;].&#39;&lt;/p&gt;&#39;;
    echo &#39;&lt;p&gt;Email: &#39;.$_SESSION[&#39;email&#39;].&#39;&lt;/p&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=logout&quot;&gt;Log Out&lt;/a&gt;&lt;/p&gt;&#39;;

    // Fetch user info from Google&#39;s userinfo endpoint
    echo &#39;&lt;h3&gt;User Info&lt;/h3&gt;&#39;;
    echo &#39;&lt;pre&gt;&#39;;
    $ch = curl_init(&#39;https://www.googleapis.com/oauth2/v3/userinfo&#39;);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
      &#39;Authorization: Bearer &#39;.$_SESSION[&#39;access_token&#39;]
    ]);
    curl_exec($ch);
    echo &#39;&lt;/pre&gt;&#39;;

  } else {
    echo &#39;&lt;h3&gt;Not logged in&lt;/h3&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=login&quot;&gt;Log In&lt;/a&gt;&lt;/p&gt;&#39;;
  }
  die();
}
</code></pre>
<p>已注销的页面包含指向我们的登录的URL链接，该URL用于启动OAuth流程。</p>
<h3 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h3><p>现在我们已经设置了必要的变量，让我们开始OAuth流程。</p>
<p>我们要让人们做的第一件事是,在查询字符串为<code>?action=login</code>时，访问此页面以启动该流程。</p>
<p>请注意，此请求中的scope现在是OpenID Connect的scope，“openid email”，表示我们不是要求访问用户的Google数据，只是想知道他们是谁。</p>
<p>另请注意，我们使用<code>response_type=code</code>参数来指示我们希望Google返回用来交换id_token的授权码。</p>
<pre><code class="php">// Start the login process by sending the user
// to Google&#39;s authorization page
if(isset($_GET[&#39;action&#39;]) &amp;&amp; $_GET[&#39;action&#39;] == &#39;login&#39;) {
  unset($_SESSION[&#39;user_id&#39;]);

  // Generate a random hash and store in the session
  $_SESSION[&#39;state&#39;] = bin2hex(random_bytes(16));

  $params = array(
    &#39;response_type&#39; =&gt; &#39;code&#39;,
    &#39;client_id&#39; =&gt; $googleClientID,
    &#39;redirect_uri&#39; =&gt; $baseURL,
    &#39;scope&#39; =&gt; &#39;openid email&#39;,
    &#39;state&#39; =&gt; $_SESSION[&#39;state&#39;]
  );

  // Redirect the user to Google&#39;s authorization page
  header(&#39;Location: &#39;.$authorizeURL.&#39;?&#39;.http_build_query($params));
  die();
}
</code></pre>
<p>生成用于保护客户端的“state”参数非常重要。这是客户端生成并存储在会话中的随机字符串。当Google将用户发送回应用时，该应用使用state参数来验证是否是它发出的请求。</p>
<p>我们建立一个授权URL，然后将用户发送到那里。该网址包含我们的公共客户ID，我们之前在Google注册的重定向网址，我们要求的scope以及state参数。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftdz43ass6j30se0x2wgz.jpg" alt="Google的授权请求"></p>
<p>如果用户已登录Google，他们会看到如上所示的帐户选择页面，要求他们选择现有帐户或使用其他帐户。请注意，此屏幕看起来不像典型的OAuth屏幕，因为用户没有授予应用程序任何权限，而只是尝试识别它们。</p>
<p>当用户选择一个帐户时，他们将被重定向回我们的页面，并在请求中返回code和state参数。下一步是使用Google API验证授权码。</p>
<h3 id="获取ID令牌"><a href="#获取ID令牌" class="headerlink" title="获取ID令牌"></a>获取ID令牌</h3><p>当用户被重定向回我们的应用程序时，查询字符串中将有一个code和state参数。该state参数将与我们在初始授权请求中设置的参数相同，并且在用于我们的应用程序之前，应该检查它是否匹配。这可确保我们的应用不会欺骗Google向攻击者发送授权码。</p>
<pre><code class="php">// When Google redirects the user back here, there will
// be a &quot;code&quot; and &quot;state&quot; parameter in the query string
if(isset($_GET[&#39;code&#39;])) {
  // Verify the state matches our stored state
  if(!isset($_GET[&#39;state&#39;]) || $_SESSION[&#39;state&#39;] != $_GET[&#39;state&#39;]) {
    header(&#39;Location: &#39; . $baseURL . &#39;?error=invalid_state&#39;);
    die();
  }

  // Verify the authorization code
  $ch = curl_init($tokenURL);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
  curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query([
    &#39;grant_type&#39; =&gt; &#39;authorization_code&#39;,
    &#39;client_id&#39; =&gt; $googleClientID,
    &#39;client_secret&#39; =&gt; $googleClientSecret,
    &#39;redirect_uri&#39; =&gt; $baseURL,
    &#39;code&#39; =&gt; $_GET[&#39;code&#39;]
  ]));
  $response = json_decode(curl_exec($ch), true);

  // ... fill in from the code in the next section
}
</code></pre>
<p>此代码首先检查从Google返回的“状态”是否与我们在会话中存储的状态匹配。</p>
<p>我们向Google的令牌endpoint建立了一个POST请求，其中包含我们应用的客户端ID和密码，以及Google在查询字符串中发回给我们的授权码。</p>
<p>Google将验证我们的请求，然后使用访问令牌和ID令牌进行回复。响应将如下所示。</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;ya29.Glins-oLtuljNVfthQU2bpJVJPTu&quot;,
  &quot;token_type&quot;: &quot;Bearer&quot;,
  &quot;expires_in&quot;: 3600,
  &quot;id_token&quot;: &quot;eyJhbGciOiJSUzI1NiIsImtpZCI6ImFmZmM2MjkwN
  2E0NDYxODJhZGMxZmE0ZTgxZmRiYTYzMTBkY2U2M2YifQ.eyJhenAi
  OiIyNzIxOTYwNjkxNzMtZm81ZWI0MXQzbmR1cTZ1ZXRkc2pkdWdzZX
  V0ZnBtc3QuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQi
  OiIyNzIxOTYwNjkxNzMtZm81ZWI0MXQzbmR1cTZ1ZXRkc2pkdWdzZX
  V0ZnBtc3QuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIi
  OiIxMTc4NDc5MTI4NzU5MTM5MDU0OTMiLCJlbWFpbCI6ImFhcm9uLn
  BhcmVja2lAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUs
  ImF0X2hhc2giOiJpRVljNDBUR0luUkhoVEJidWRncEpRIiwiZXhwIj
  oxNTI0NTk5MDU2LCJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2ds
  ZS5jb20iLCJpYXQiOjE1MjQ1OTU0NTZ9.ho2czp_1JWsglJ9jN8gCg
  WfxDi2gY4X5-QcT56RUGkgh5BJaaWdlrRhhN_eNuJyN3HRPhvVA_KJ
  Vy1tMltTVd2OQ6VkxgBNfBsThG_zLPZriw7a1lANblarwxLZID4fXD
  YG-O8U-gw4xb-NIsOzx6xsxRBdfKKniavuEg56Sd3eKYyqrMA0DWnI
  agqLiKE6kpZkaGImIpLcIxJPF0-yeJTMt_p1NoJF7uguHHLYr6752h
  qppnBpMjFL2YMDVeg3jl1y5DeSKNPh6cZ8H2p4Xb2UIrJguGbQHVIJ
  vtm_AspRjrmaTUQKrzXDRCfDROSUU-h7XKIWRrEd2-W9UkV5oCg&quot;
}
</code></pre>
<p>应将访问令牌视为不透明字符串。除了能够使用它来发出API请求之外，它对您的应用程序没有重要意义。</p>
<p>ID令牌具有您的应用可以解析的特定结构，以找出登录者的用户数据。ID令牌是JWT，在OpenID Connect中有更详细的解释。您可以将Google的JWT粘贴到jsonwebtoken.io等网站，以快速向您显示内容。</p>
<h3 id="验证用户信息"><a href="#验证用户信息" class="headerlink" title="验证用户信息"></a>验证用户信息</h3><p>通常，在信任ID令牌中的任何信息之前验证ID令牌至关重要。这是因为通常您的应用会通过不受信任的渠道（例如浏览器重定向）获取ID令牌。</p>
<p>在这种情况下，您使用客户端密钥通过HTTPS连接向Google获取ID令牌，以便向Google进行身份验证，因此您可以确信您获得的ID令牌实际上来自服务商而非攻击者。考虑到这一点，我们可以不加验证的解码ID令牌。谷歌就是这样做的：<code>https://developers.google.com/identity/protocols/OpenIDConnect#obtainuserinfo</code>。</p>
<p>看看上面的JWT。它由三个部分组成，每个部分用一个句点分隔。我们可以在点上分割字符串，然后取出中间部分。中间部分是base64编码的JSON字符串，包含ID令牌数据。以下是JWT中的数据示例。</p>
<pre><code class="json">{
  &quot;azp&quot;: &quot;272196069173.apps.googleusercontent.com&quot;,
  &quot;aud&quot;: &quot;272196069173.apps.googleusercontent.com&quot;,
  &quot;sub&quot;: &quot;110248495921238986420&quot;,
  &quot;hd&quot;: &quot;okta.com&quot;,
  &quot;email&quot;: &quot;aaron.parecki@okta.com&quot;,
  &quot;email_verified&quot;: true,
  &quot;at_hash&quot;: &quot;0bzSP5g7IfV3HXoLwYS3Lg&quot;,
  &quot;exp&quot;: 1524601669,
  &quot;iss&quot;: &quot;https://accounts.google.com&quot;,
  &quot;iat&quot;: 1524598069
}
</code></pre>
<p>我们真正关心的这个演示是两个属性sub和email。sub(subject)属性包含了登录用户的唯一用户标识符。我们会提取它，并将其存储在会话中，这将向我们的应用程序表明用户已经登录。</p>
<p>我们还会在会话中存储ID令牌和访问令牌，以便我们以后可以使用它们，这也是我们获取并显示用户信息的另一种方法。</p>
<pre><code class="php">  // ... continuing from the previous code sample, insert this

  // Split the JWT string into three parts
  $jwt = explode(&#39;.&#39;, $data[&#39;id_token&#39;]);

  // Extract the middle part, base64 decode, then json_decode it
  $userinfo = json_decode(base64_decode($jwt[1]), true);

  $_SESSION[&#39;user_id&#39;] = $userinfo[&#39;sub&#39;];
  $_SESSION[&#39;email&#39;] = $userinfo[&#39;email&#39;];

  // While we&#39;re at it, let&#39;s store the access token and id token
  // so we can use them later
  $_SESSION[&#39;access_token&#39;] = $data[&#39;access_token&#39;];
  $_SESSION[&#39;id_token&#39;] = $data[&#39;id_token&#39;];

  header(&#39;Location: &#39; . $baseURL);
  die();
}
</code></pre>
<p>现在，您将被重定向回应用程序的主页，我们将使用我们在先前创建的代码向您显示用户ID和电子邮件。</p>
<pre><code class="javascript">echo &#39;&lt;p&gt;User ID: &#39;.$_SESSION[&#39;user_id&#39;].&#39;&lt;/p&gt;&#39;;
echo &#39;&lt;p&gt;Email: &#39;.$_SESSION[&#39;email&#39;].&#39;&lt;/p&gt;&#39;;
</code></pre>
<h4 id="使用ID令牌检索用户信息"><a href="#使用ID令牌检索用户信息" class="headerlink" title="使用ID令牌检索用户信息"></a>使用ID令牌检索用户信息</h4><p>Google提供了一个额外的API endpoint，称为tokeninfo endpoint，您可以使用它来查找ID令牌详细信息，而不是自己解析它。这不建议用于生产应用程序，因为它需要额外的HTTP往返，但可用于测试和故障排除。</p>
<p>Google的tokeninfo endpoint<code>https://www.googleapis.com/oauth2/v3/tokeninfo</code>位于其OpenID Connect发现文档中:<code>https://accounts.google.com/.well-known/openid-configuration</code>。要查找我们收到的ID令牌的信息，请使用查询字符串中的ID令牌向tokeninfo endpoint发出GET请求。</p>
<p><code>https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=eyJ</code></p>
<p>响应将是一个JSON对象，其中包含JWT本身包含的类似属性列表。</p>
<pre><code class="json">{
 &quot;azp&quot;: &quot;272196069173.apps.googleusercontent.com&quot;,
 &quot;aud&quot;: &quot;272196069173.apps.googleusercontent.com&quot;,
 &quot;sub&quot;: &quot;110248495921238986420&quot;,
 &quot;hd&quot;: &quot;okta.com&quot;,
 &quot;email&quot;: &quot;aaron.parecki@okta.com&quot;,
 &quot;email_verified&quot;: &quot;true&quot;,
 &quot;at_hash&quot;: &quot;NUuq_yggZYi_2-13hJSOXw&quot;,
 &quot;exp&quot;: &quot;1524681857&quot;,
 &quot;iss&quot;: &quot;https://accounts.google.com&quot;,
 &quot;iat&quot;: &quot;1524678257&quot;,
 &quot;alg&quot;: &quot;RS256&quot;,
 &quot;kid&quot;: &quot;affc62907a446182adc1fa4e81fdba6310dce63f&quot;
}
</code></pre>
<h4 id="使用访问令牌来检索用户信息"><a href="#使用访问令牌来检索用户信息" class="headerlink" title="使用访问令牌来检索用户信息"></a>使用访问令牌来检索用户信息</h4><p>如前所述，许多OAuth 2.0服务还提供endpoint来检索登录用户的用户信息。这是OpenID Connect标准的一部分，endpoint将成为服务的OpenID Connect Discovery文档的一部分。</p>
<p>谷歌的userinfo endpoint是<code>https://www.googleapis.com/oauth2/v3/userinfo</code>。在这种情况下，您使用访问令牌而不是ID令牌来查找用户信息。向该 endpoint发出GET请求，并像执行OAuth 2.0 API请求时那样,在HTTP Header中添加Authorization传递访问令牌。</p>
<pre><code class="http">GET /oauth2/v3/userinfo
Host: www.googleapis.com
Authorization: Bearer ya29.Gl-oBRPLiI9IrSRA70...
</code></pre>
<p>响应将是一个JSON对象，其中包含有关用户的若干属性。响应将始终包含sub密钥，该密钥是用户的唯一标识符。Google还会返回用户的个人资料信息，例如姓名，个人资料照片网址，性别，区域设置，个人资料网址和电子邮件。服务器还可以添加自己的声明，例如Google hd在使用G Suite帐户时显示帐户的“托管域”。</p>
<pre><code class="json">{
 &quot;sub&quot;: &quot;110248495921238986420&quot;,
 &quot;name&quot;: &quot;Aaron Parecki&quot;,
 &quot;given_name&quot;: &quot;Aaron&quot;,
 &quot;family_name&quot;: &quot;Parecki&quot;,
 &quot;picture&quot;: &quot;https://lh4.googleusercontent.com/-kw-iMgD
   _j34/AAAAAAAAAAI/AAAAAAAAAAc/P1YY91tzesU/photo.jpg&quot;,
 &quot;email&quot;: &quot;aaron.parecki@okta.com&quot;,
 &quot;email_verified&quot;: true,
 &quot;locale&quot;: &quot;en&quot;,
 &quot;hd&quot;: &quot;okta.com&quot;
}
</code></pre>
<h4 id="下载示例代码"><a href="#下载示例代码" class="headerlink" title="下载示例代码"></a>下载示例代码</h4><p>您可以从GitHub下载此示例中使用的完整示例代码，网址为<code>https://github.com/aaronpk/sample-oauth2-client</code>。</p>
<p>在用户登录后，您已经看到了三种不同的方式来获取用户的个人资料信息。那么您应该使用哪个以及何时使用？</p>
<p>对于性能敏感的应用程序，您可能在每个请求上读取ID令牌或使用它们来维护会话，您绝对应该在本地验证ID令牌而不是发出网络请求。Google的API文档提供了有关离线验证ID令牌的详细信息的指南。</p>
<p>如果您所做的只是在登录后尝试查找用户的姓名和电子邮件，那么向userinfo endpoint发出API请求是最简单，最直接的选择。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--访问OAuth服务器中的数据]]></title>
      <url>/2018/07/13/oauth-guide-2/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>在本章中，我们将介绍如何在现有OAuth 2.0服务器上访问您的数据。对于此示例，我们将使用GitHub API，并构建一个简单的应用程序，该应用程序将展示出该GitHub登录用户创建的所有库。</p>
<h3 id="创建一个应用程序"><a href="#创建一个应用程序" class="headerlink" title="创建一个应用程序"></a>创建一个应用程序</h3><p>在我们开始之前，我们需要在GitHub上创建一个应用程序，以获取客户端ID和客户端密钥。</p>
<p>在GitHub.com上，从“设置”页面，单击侧栏中的“开发人员设置”链接。您最终将访问<code>https://github.com/settings/developers</code>。从那里，单击“新OAuth应用程序”，您将看到一个简短的表单，如下所示。</p>
<p>填写所需信息，包括回调URL。如果您在本地开发应用程序，则必须使用本地地址作为回调URL。由于GitHub每个应用程序只允许一个注册的回调URL，因此创建两个应用程序非常有用，一个用于开发，另一个用于生产。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ft8d4v1w2oj318g0v40wo.jpg" alt="在GitHub上注册一个新的OAuth应用程序"></p>
<p>完成此表单后，您将进入一个页面，您可以在其中看到发布到您的应用程序的客户端ID和秘钥，如下所示。</p>
<p>客户端ID被视为公共信息，用于构建登录URL，或者可以包含在网页的Javascript源代码中。客户密钥必须保密。不要将它提交到您的git存储库！</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1ft8dayhs69j316k1vdqcv.jpg" alt="GitHub应用程序已创建"></p>
<h3 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h3><p>此示例代码是用PHP编写的，不需要外部包，也不需要框架。这可以很容易地翻译成其他语言。您可以将它全部放在一个PHP文件中。</p>
<p>创建一个新文件夹并在该文件夹中创建一个空文件index.php。从该文件夹内部运行命令行，<code>php -S localhost:8000</code>，您将能够在浏览器中访问<code>http://localhost:8000</code>来运行您的代码。以下示例中的所有代码都应添加到此index.php文件中。</p>
<p>为了让我们更轻松，让我们定义一个方法，apiRequest()它是一个简单的cURL包装器。此函数将包含GitHub API所需的Accept和User-Agent Header，并自动解码JSON响应。如果我们在会话中有访问令牌，它也会发送带有访问令牌的正确OAuth Header，以便进行经过身份验证的请求。</p>
<pre><code class="php">function apiRequest($url, $post=FALSE, $headers=array()) {
  $ch = curl_init($url);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);

  if($post)
    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($post));

  $headers = [
    &#39;Accept: application/vnd.github.v3+json, application/json&#39;,
    &#39;User-Agent: https://example-app.com/&#39;
  ];

  if(isset($_SESSION[&#39;access_token&#39;]))
    $headers[] = &#39;Authorization: Bearer &#39;.$_SESSION[&#39;access_token&#39;];

  curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);

  $response = curl_exec($ch);
  return json_decode($response, true);
}
</code></pre>
<p>现在让我们设置一些OAuth流程所需的变量。</p>
<pre><code class="php">// Fill these out with the values from Github
$githubClientID = &#39;&#39;;
$githubClientSecret = &#39;&#39;;

// This is the URL we&#39;ll send the user to first
// to get their authorization
$authorizeURL = &#39;https://github.com/login/oauth/authorize&#39;;

// This is the endpoint we&#39;ll request an access token from
$tokenURL = &#39;https://github.com/login/oauth/access_token&#39;;

// This is the Github base URL for API requests
$apiURLBase = &#39;https://api.github.com/&#39;;

// The URL for this script, used as the redirect URL
$baseURL = &#39;https://&#39; . $_SERVER[&#39;SERVER_NAME&#39;]
    . $_SERVER[&#39;PHP_SELF&#39;];

// Start a session so we have a place to
// store things between redirects
session_start();
</code></pre>
<p>首先，让我们设置“登录”和“注销”视图。这将显示一条简单的消息，指示用户是登录还是注销。</p>
<pre><code class="php">// If there is an access token in the session
// the user is already logged in
if(!isset($_GET[&#39;action&#39;])) {
  if(!empty($_SESSION[&#39;access_token&#39;])) {
    echo &#39;&lt;h3&gt;Logged In&lt;/h3&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=repos&quot;&gt;View Repos&lt;/a&gt;&lt;/p&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=logout&quot;&gt;Log Out&lt;/a&gt;&lt;/p&gt;&#39;;
  } else {
    echo &#39;&lt;h3&gt;Not logged in&lt;/h3&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=login&quot;&gt;Log In&lt;/a&gt;&lt;/p&gt;&#39;;
  }
  die();
}
</code></pre>
<p>已注销的视图包含指向我们的登录URL的链接，该URL启动OAuth流程。</p>
<h3 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h3><p>现在我们已经设置了必要的变量，让我们开始OAuth流程。</p>
<p>我们要让人们做的第一件事是,在查询字符串<code>?action=login</code>中访问此页面以启动该过程。</p>
<p>请注意，我们在此请求中要求的范围包括“user”和“public_repo”。这意味着该应用程序将能够读取用户配置文件信息以及访问公共存储库。</p>
<pre><code class="php">// Start the login process by sending the user
// to Github&#39;s authorization page
if(isset($_GET[&#39;action&#39;]) &amp;&amp; $_GET[&#39;action&#39;] == &#39;login&#39;) {
  unset($_SESSION[&#39;access_token&#39;]);

  // Generate a random hash and store in the session
  $_SESSION[&#39;state&#39;] = bin2hex(random_bytes(16));

  $params = array(
    &#39;response_type&#39; =&gt; &#39;code&#39;,
    &#39;client_id&#39; =&gt; $githubClientID,
    &#39;redirect_uri&#39; =&gt; $baseURL,
    &#39;scope&#39; =&gt; &#39;user public_repo&#39;,
    &#39;state&#39; =&gt; $_SESSION[&#39;state&#39;]
  );

  // Redirect the user to Github&#39;s authorization page
  header(&#39;Location: &#39;.$authorizeURL.&#39;?&#39;.http_build_query($params));
  die();
}
</code></pre>
<p>生成用于保护客户端的“state”参数非常重要。这是客户端生成并存储在会话中的随机字符串。我们使用state参数作为额外的安全检查，以便当Github将用户发送回查询字符串中的状态时，我们可以验证我们确实发起了此请求，并且它不是发出该请求的攻击者。</p>
<p>我们建立授权URL，然后将用户发送到那里。URL包含我们的公共客户端ID，我们之前在Github上注册的重定向URL，我们要求的范围以及“state”参数。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1ft8difjyjmj30xg1dsjx4.jpg" alt="GitHub的授权请求"></p>
<p>此时，用户将看到Github的OAuth授权提示，如上所示。</p>
<p>当用户批准该请求时，他们将被重定向回我们的页面并在请求中包含code和state参数。下一步是用授权码交换访问令牌。</p>
<h3 id="获取访问令牌"><a href="#获取访问令牌" class="headerlink" title="获取访问令牌"></a>获取访问令牌</h3><p>当用户被重定向回我们的应用程序时，查询字符串中将有一个code和state参数。该state参数将与我们在初始授权请求中设置的参数相同，在我们继续使用应用程序之前应该检查它是否匹配。这可以确保我们的应用程序不会被欺骗向GitHub发送攻击者的授权代码。</p>
<pre><code class="php">// When Github redirects the user back here,
// there will be a &quot;code&quot; and &quot;state&quot; parameter in the query string
if(isset($_GET[&#39;code&#39;])) {
  // Verify the state matches our stored state
  if(!isset($_GET[&#39;state&#39;])
    || $_SESSION[&#39;state&#39;] != $_GET[&#39;state&#39;]) {

    header(&#39;Location: &#39; . $baseURL . &#39;?error=invalid_state&#39;);
    die();
  }

  // Exchange the auth code for an access token
  $token = apiRequest($tokenURL, array(
    &#39;grant_type&#39; =&gt; &#39;authorization_code&#39;,
    &#39;client_id&#39; =&gt; $githubClientID,
    &#39;client_secret&#39; =&gt; $githubClientSecret,
    &#39;redirect_uri&#39; =&gt; $baseURL,
    &#39;code&#39; =&gt; $_GET[&#39;code&#39;]
  ));
  $_SESSION[&#39;access_token&#39;] = $token[&#39;access_token&#39;];

  header(&#39;Location: &#39; . $baseURL);
  die();
}
</code></pre>
<p>在这里，我们向Github的令牌endpoint发送请求，用授权码来交换访问令牌。该请求包含我们的公共客户端ID以及私密客户端密钥。我们还发送与之前相同的重定向URL以及授权码。</p>
<p>如果一切都检出，Github会生成一个访问令牌并在响应中返回它。我们将访问令牌存储在会话中并重定向到主页，并且用户已登录。</p>
<p>GitHub的回复如下所示。</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;e2f8c8e136c73b1e909bb1021b3b4c29&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;scope&quot;: &quot;public_repo,user&quot;
}
</code></pre>
<p>我们的代码已经提取了访问令牌并将其保存在会话中。下次访问该页面时，它会识别出已存在访问令牌并显示我们之前创建的登录页面。</p>
<p>注意：为简单起见，我们在此示例中未包含任何错误处理代码。实际上，您将检查从GitHub返回的错误并向用户显示相应的消息。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--准备工作]]></title>
      <url>/2018/07/13/oauth-guide-1/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<blockquote>
<p>前言：</p>
<p>最近在看SSO相关的内容，发现自己对OAuth2.0只是一知半解，阮一峰的文章不错，但是真正用在开发上就远远不够了，于是决定花点时间翻译一下<a href="https://www.oauth.com/" target="_blank" rel="noopener">www.oauth.com</a>上的教程，加深理解。</p>
<p>我真是无语了，文档翻译到一半的时候，oauth.com更新了，醉了醉了，白翻译了十八个章节。</p>
</blockquote>
<p>在本书的第一部分中，我们将介绍在构建与现有OAuth 2.0 API对话的应用程序时需要了解的内容。无论您是构建网络应用程序还是移动应用程序，在开始使用时都需要记住一些事项。</p>
<p>每个OAuth 2.0服务都要求您首先注册一个新应用程序，这通常还要求您首先注册为该服务的开发人员。</p>
<h3 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h3><p>注册过程通常涉及在服务的网站上创建一个帐户，然后输入有关应用程序的基本信息，如名称，网站，logo等。注册申请后，您将获得client_id（在某些情况下也有client_secret），当您的应用与服务互动时，您将使用它们。</p>
<p>创建应用程序时最重要的事情之一是注册应用程序将使用的一个或多个重定向URL。重定向URL是OAuth 2.0服务在应用程序授权之后，将用户返回的位置。注册这些是至关重要的，否则很容易创建可以窃取用户数据的恶意应用程序。本书稍后将对此进行更详细的介绍。</p>
<h3 id="重定向网址和状态"><a href="#重定向网址和状态" class="headerlink" title="重定向网址和状态"></a>重定向网址和状态</h3><p>OAuth 2.0 API仅将用户重定向到已注册的URL，以防止攻击者拦截授权码或访问令牌的重定向攻击。某些服务可能允许您注册多个重定向URL，这在Web应用程序和移动应用程序使用相同的客户端ID、或者在开发和生产服务中使用相同的客户端ID时，将为开发者提供帮助。</p>
<p>为了安全起见，重定向URL必须是https端点，以防止在授权过程中拦截代码。如果您的重定向URL不是https，则攻击者可能能够拦截授权代码并使用它来劫持会话。如果服务允许使用非https重定向，则必须采取额外的预防措施以确保无法进行此类攻击。</p>
<p>大多数服务将重定向URL验证视为完全匹配。这意味着重定向网址<code>https://example.com/auth</code>不匹配<code>https://example.com/auth?destination=account</code>。最佳做法是避免在重定向URL中使用查询字符串参数，并使其仅包含路径。</p>
<p>某些应用程序可能有多个他们想要启动OAuth进程的位置，例如主页上的登录链接以及查看某些公共项目时的登录链接。对于这些应用程序，尝试注册多个重定向URL可能很诱人，或者您可能认为需要能够根据请求更改重定向URL。但请不要这么做，因为OAuth 2.0为此提供了一种机制，即“state”参数。</p>
<p>“state”参数可以用于任何你想要的服务，它是一个对OAuth 2.0服务不透明的字符串。在用户授权应用程序后，将返回您在初始授权请求期间传递的state值。其中一个常见的应用场景是包括一个随机字符串来防止CSRF攻击。您还可以使用JWT之类的技术对重定向URL进行编码，并在用户重定向回应用程序后对其进行解析，以便您在登录后将用户带回适当的位置。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[什么是OAuth？]]></title>
      <url>/2018/06/19/what-is-oauth/</url>
      <content type="html"><![CDATA[<p><strong>本文是Matt Raible的What the Heck is OAuth?的翻译。（<a href="https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<blockquote>
<p>围绕OAuth的实际情况存在很多混淆。</p>
<p>有些人认为OAuth是一种登录流程（就像当您使用Google登录登录应用程序时一样），有些人不假思索的认为OAuth是一种“安全事物”。</p>
<p>我将向您展示OAuth是什么，解释它的工作原理，并希望让您了解OAuth是如何使您的应用受益的。</p>
</blockquote>
<h3 id="什么是OAuth？"><a href="#什么是OAuth？" class="headerlink" title="什么是OAuth？"></a>什么是OAuth？</h3><p>我们先从最顶层的描述说起，OAuth 不是 API或服务：它是授权的开放标准，任何人都可以实施。</p>
<p>更具体地说，OAuth是应用程序可以用来为客户端提供“安全授权访问”的标准。OAuth通过HTTPS工作，并使用access tokens为设备，API，服务器和应用程序授权，而非credentials。</p>
<p>有两种版本的OAuth：<a href="https://tools.ietf.org/html/rfc5849" target="_blank" rel="noopener">OAuth 1.0a</a>和<a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">OAuth 2.0</a>。这些规范是完全不同的，不能一起使用：它们之间没有向后兼容性。</p>
<p>哪一个更受欢迎？如今，OAuth 2.0是最广泛使用的OAuth形式。所以从现在开始，每当我说“OAuth”时，我都在谈论OAuth 2.0–因为它很可能是您将要使用的。</p>
<h3 id="为什么使用OAuth？"><a href="#为什么使用OAuth？" class="headerlink" title="为什么使用OAuth？"></a>为什么使用OAuth？</h3><p>OAuth是对直接身份验证模式的响应。这种模式因HTTP基本认证（Basic Authentication）而闻名，用户会被提示输入用户名和密码。基本身份验证仍然是服务器端应用程序的API身份验证的基本形式：用户发送API密钥ID和密钥，而不是通过每个请求向服务器发送用户名和密码。在OAuth之前，网站会提示您直接在表单中输入用户名和密码，他们会像您一样登录您的数据（例如您的Gmail帐户）。这通常被称为<a href="https://arstechnica.com/information-technology/2010/01/oauth-and-oauth-wrap-defeating-the-password-anti-pattern/" target="_blank" rel="noopener">反密码模式(the password anti-pattern)</a>。</p>
<p>为了为网络创建更好的系统，联合身份为单点登录（SSO）的场景所创建。在这种情况下，终端用户与他们的身份提供者交谈，并且身份提供者生成一个加密签名的token，交给应用程序对用户进行身份验证。应用程序信任身份提供者。只要这种信任关系与登录的断言一起工作，你就登陆成功了。下图显示了这是如何工作的。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/browser_spa_implicit_flow-9f0d10069f4363030e4283679bd4914f9aa47e192b32a166d1e186bdb929e1d2.png" alt="oauth工作流程"></p>
<h3 id="浏览器隐式流程"><a href="#浏览器隐式流程" class="headerlink" title="浏览器隐式流程"></a>浏览器隐式流程</h3><p>联合身份因为由2005年3月15日发布的OASIS标准SAML 2.0而变得知名。它是一个很大的规范，但主要的两个组件是它的身份验证请求协议（又名Web SSO）以及它打包身份属性和签名的方式，称为SAML断言。Okta用SSO chiclets做到这一点。我们发送一条消息，我们在断言中签名，在断言中记录着用户是谁，来自Okta。再加上一个数字签名，你就登录成功了。</p>
<h3 id="SAML"><a href="#SAML" class="headerlink" title="SAML"></a>SAML</h3><p>SAML基本上是浏览器中的会话cookie，可让您访问webapps。如果您想要在Web浏览器之外的各种设备和场景中使用，它将会受到限制。</p>
<p>当SAML 2.0于2005年推出时，它是有道理的。不过，自那以后发生了很多变化。现在我们拥有现代化的网页和原生应用程序开发平台，有单页面应用程序（SPA），如Gmail / Google收件箱，Facebook和Twitter。它们与传统的Web应用程序有不同的行为，因为它们会对API进行AJAX（后台HTTP调用）。移动电话也进行API调用，电视，游戏控制台和物联网设备也一样。SAML SSO在这方面并不是特别优秀。</p>
<h3 id="OAuth和API"><a href="#OAuth和API" class="headerlink" title="OAuth和API"></a>OAuth和API</h3><p>我们构建API的方式也发生了很大变化。在2005年，人们投资于WS- *来构建Web服务。现在，大多数开发人员已经转移到REST和无状态API。简而言之，REST是通过网络推送JSON包的HTTP命令。</p>
<p>开发人员构建了很多API。API经济是您今天可能在会议室听到的常见流行词。公司需要保护其REST API，以允许许多设备访问它们。在过去，您需要输入您的用户名/密码，该应用程序将直接以您的身份登录。这引起了委托授权问题。</p>
<p>“我怎样才能允许应用程序访问我的数据，而不必给我的密码？”</p>
<p>如果您见过以下对话框之一，那就是我们正在谈论的内容。这是一个应用程序，询问您是否可以代表您访问数据。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/biketoworkday-fb-login-f00e39aabbf3e44bc3570333643cbf5d966fc27367dbffd2623ff4a3694831c3.png" alt="Facebook OAuth"></p>
<p>这是OAuth。</p>
<p>OAuth是REST / API的委托授权框架。它使应用程序可以在不泄露用户密码的情况下获取用户数据的有限访问权限（范围）。它将认证(authentication)与授权(authorization)分离开来，并支持多种用例来满足不同的设备功能。它支持服务器到服务器应用程序，基于浏览器的应用程序，移动/本机应用程序和控制台/电视。</p>
<p>对于应用程序来说，你可以把它想成酒店钥匙卡。如果你有酒店钥匙卡，你可以进入你的房间。你如何获得酒店钥匙卡？您必须在前台进行身份验证才能获得。在认证并获得钥匙卡后，您可以访问整个酒店的资源。</p>
<p>简单地说，OAuth就是：</p>
<ul>
<li>应用程序向用户请求授权</li>
<li>用户授权应用程序并提供证据</li>
<li>应用程序向服务器提供授权证明以获取令牌（token）</li>
<li>令牌（token）仅限于访问用户为特定应用程序授权的内容</li>
</ul>
<h3 id="OAuth中央组件"><a href="#OAuth中央组件" class="headerlink" title="OAuth中央组件"></a>OAuth中央组件</h3><p>OAuth建立在以下中心组件之上：</p>
<ul>
<li>作用域和同意书（Scopes and Consent）</li>
<li>扮演者（Actors）</li>
<li>客户端（Clients）</li>
<li>令牌（Tokens）</li>
<li>授权服务器（Authorization Server）</li>
<li>流程（Flows）</li>
</ul>
<h3 id="OAuth作用域"><a href="#OAuth作用域" class="headerlink" title="OAuth作用域"></a>OAuth作用域</h3><p>作用域是您在应用程序请求权限时在授权屏幕上看到的内容。它们是客户在请求令牌时所需求的权限包。这些由应用程序开发人员在编写应用程序时进行编码。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/auth-scope.png" alt="OAuth作用域"></p>
<p>作用域将授权策略的决策与执行分离。这是OAuth的第一个关键方面。权限是中心。它们不会隐藏在应用程序层后面。它们经常在API文档中列出：以下是这个应用程序需要的范围。</p>
<p>你必须获得这一同意。这被称为首次使用的信任。这是网络上非常重要的用户体验变化。OAuth之前的大多数人只是用id和密码对话框。现在你有了这个新的屏幕，你必须训练用户使用。重新调整互联网人口是困难的。从熟悉技术的年轻人到祖父母都有各种各样的用户，他们不熟悉这种流程。这是网络上的一个新概念，现在是前沿和中心。现在你必须授权并征得同意。</p>
<p>同意书可以根据应用程序而有所不同。它可以是时间敏感的作用域范围（日，周，月），但并非所有平台都允许您选择持续时间。当您同意时，需要注意的一点是，该应用程序可以代表您执行某些操作 - 例如，LinkedIn会将您网络中的每个人都发送出去。</p>
<p>OAuth是互联网规模的解决方案，因为它应用于每个应用程序。您经常可以登录到仪表板，查看您授予访问权的应用程序并撤消同意。</p>
<h3 id="OAuth扮演者"><a href="#OAuth扮演者" class="headerlink" title="OAuth扮演者"></a>OAuth扮演者</h3><p>OAuth流程中的角色如下所示：</p>
<ul>
<li>资源所有者：拥有资源服务器中的数据。例如，我是我的Facebook个人资料的资源所有者。</li>
<li>资源服务器：存储应用程序想要访问的数据的API</li>
<li>客户端：想要访问您的数据的应用程序</li>
<li>授权服务器：OAuth的主要引擎<br><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-actor.png" alt="OAuth演员"></li>
</ul>
<p>资源所有者是一个可以使用不同凭据更改的角色。它可以是最终用户，也可以是公司。</p>
<p>客户端可以公开和保密。OAuth命名法中两者之间存在显着的区别。受信任的客户端可以信任存储秘钥。它们不是在桌面上运行，或通过应用商店分发。人们无法对其进行逆向工程并获得密钥。他们在最终用户无法访问的受保护区域运行。</p>
<p>公共客户端是浏览器，移动应用程序和物联网设备。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-client.png" alt="OAuth客户端"></p>
<p>客户端注册也是OAuth的关键组件。这就像OAuth的DMV（车辆管理局）。您需要获取应用程序的牌照。这是您的应用在授权对话框中显示的方式。</p>
<h3 id="OAuth令牌"><a href="#OAuth令牌" class="headerlink" title="OAuth令牌"></a>OAuth令牌</h3><p>访问令牌是客户用来访问资源服务器（API）的令牌。他们的目的是短暂的。想象他们在几个小时和几分钟内，而不是几个月和几个月。你不需要一个机密的客户端来获得访问令牌。您可以使用公共客户端来获取访问令牌。它们旨在优化互联网规模问题。因为这些令牌可以短暂存在并扩展出来，所以它们不能被撤销，你只能等待它们超时。</p>
<p>另一个令牌是刷新令牌。这种寿命要长得多。几天，几个月，几年。这可以用来获得新的令牌。要获得刷新令牌，应用程序通常需要受信任客户端进行身份验证。</p>
<p>刷新令牌可以被撤消。当在仪表板中撤销应用程序的访问时，您正在刷新它的刷新令牌。这使您能够强制客户更新秘钥。您使用刷新令牌获取新的访问令牌，访问令牌通过线路打所有的API资源。当你每次刷新访问令牌时，都会得到一个新的加密签名令牌。更新的开关内置于系统中。</p>
<p>OAuth规范并未定义令牌的含义。它可以以任何你想要的格式。通常情况下，您希望这些令牌是JSON Web Token（一种标准）。简而言之，JWT（发音为“jot”）是令牌认证的安全可靠标准。JWT允许您使用签名对信息进行数字签名(claims)，并可以在稍后使用一个秘密的签名密钥进行验证。要了解关于JWT的更多信息，请参阅<a href="https://stormpath.com/blog/beginners-guide-jwts-in-java" target="_blank" rel="noopener">Java中的JWT初学者指南</a>。</p>
<p>令牌从授权服务器上的endpoint上取回。两个主要endpoint是授权endpoint和令牌endpoint。它们分开用于不同的用例。授权endpoint是您去哪里获得用户同意和授权的地方。这将返回一个授权，表示用户已同意。然后授权被传递给令牌端点。令牌端点处理授权并说“很好，这是您的刷新令牌和您的访问令牌”。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-server.png" alt="授权服务器"></p>
<p>您可以使用访问令牌访问API。一旦到期，您将必须返回带有刷新令牌的令牌端点以获取新的访问令牌。</p>
<p>缺点是这导致了很多开发者的反对。开发人员对OAuth最大的难点之一就是你必须管理刷新令牌。你将状态管理推给每个客户端开发者。你获得了关键轮换的好处，但是你为开发者创造了很多痛苦。这就是开发人员喜欢API密钥的原因。他们可以复制/粘贴它们，将它们放在文本文件中，然后用它们完成。API密钥对开发人员非常方便，但对安全性非常不利。</p>
<p>这是一个代价问题。让开发人员执行OAuth流程可提高安全性，但存在更多的摩擦。工具包和平台有机会简化事情并帮助进行令牌管理。幸运的是，现在OAuth已经非常成熟了，您最喜欢的语言或框架都可能用用于简化OAuth的工具。</p>
<p>我们已经谈了一些关于客户端类型，令牌类型和授权服务器的endpoint以及我们如何将其传递给资源服务器的内容。我提到了两种不同的流程：获得授权和获取令牌。这些不必在同一个通道上发生。前向通道是浏览器的内容。浏览器将用户重定向到授权服务器，用户表示同意。这发生在用户的浏览器上。一旦用户获得授权许可并将其交给应用程序，客户端应用程序就不再需要使用浏览器来完成OAuth流程以获取令牌。</p>
<p>令牌旨在被客户端应用程序使用，以便它可以代表您访问资源。我们称之为后向通道。后向的通道是直接从客户端应用程序到资源服务器的HTTP调用，用于交换令牌的授权许可。这些通道用于不同的流程，具体取决于您拥有的设备功能。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-channel.png" alt="流动通道"></p>
<p>例如，您通过用户代理进行授权的前向通道可能如下所示：</p>
<ul>
<li>资源所有者启动流程来委派对受保护资源的访问</li>
<li>客户端通过浏览器重定向到授权服务器上的授权端点，向所需范围发送授权请求</li>
<li>授权服务器返回一个同意对话框，指出“您是否允许此应用程序访问这些范围？”当然，您需要向应用程序进行身份验证，所以如果您未通过资源服务器的身份验证，它会询问你登录。如果您已经有了一个缓存的会话cookie，您只会看到同意对话框。查看同意对话框，并同意。</li>
<li>授权许可通过浏览器重定向传递回应用程序。这一切都发生在前向通道。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/front-channel.png" alt="前向通道"></p>
<p>这种流程中也存在一种称为隐式流程的变化。我们稍后再讨论。</p>
<p>这就是它在请求中的样子。</p>
<p><strong>Request</strong></p>
<blockquote>
<p>GET <a href="https://accounts.google.com/o/oauth2/auth?scope=gmail.insert" target="_blank" rel="noopener">https://accounts.google.com/o/oauth2/auth?scope=gmail.insert</a> gmail.send<br>&amp;redirect_uri=<a href="https://app.example.com/oauth2/callback" target="_blank" rel="noopener">https://app.example.com/oauth2/callback</a><br>&amp;response_type=code&amp;client_id=812741506391<br>&amp;state=af0ifjsldkj</p>
</blockquote>
<p>这是一个带有一堆查询参数的GET请求（不是出于示例目的的URL编码）。范围来自Gmail的API。redirect_uri是当授权完成时，所返回的客户端应用程序的URL。这应该与客户注册过程（在DMV处）的值相匹配。您不希望授权被退回到外部应用程序。响应类型会改变OAuth流向。客户端ID也来自注册过程。国家是一个安全标志，类似于XRSF。要了解有关XRSF的更多信息，请参阅<a href="https://dzone.com/articles/cross-site-request-forgery" target="_blank" rel="noopener">DZone的“跨站请求伪造解释”</a>。</p>
<p><strong>Response</strong></p>
<blockquote>
<p>HTTP/1.1 302 Found<br>Location: <a href="https://app.example.com/oauth2/callback?" target="_blank" rel="noopener">https://app.example.com/oauth2/callback?</a><br>code=MsCeLvIaQm6bTrgtp7&amp;state=af0ifjsldkj</p>
<p><em>code</em>返回授权认证，<em>state</em>确保它不是伪造的，即它是由同一个请求发出。</p>
</blockquote>
<p>前向通道完成后，会进行前向通道，并将授权码交换为访问令牌。</p>
<p>客户端应用程序使用受信任的客户端凭证和客户端ID访问授权服务器上的令牌endpoint，并发送访问令牌请求。该过程交换访问令牌和（可选）刷新令牌的授权代码授权。客户端使用访问令牌访问受保护的资源。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/back-channel.png" alt="后向通道流"></p>
<p>下面是其在HTTP中的样子。</p>
<p><strong>Request</strong></p>
<blockquote>
<p>POST /oauth2/v3/token HTTP/1.1<br>Host: www.googleapis.com<br>Content-Type: application/x-www-form-urlencoded</p>
<p>code=MsCeLvIaQm6bTrgtp7&amp;client_id=812741506391&amp;client_secret={client_secret}&amp;redirect_uri=<a href="https://app.example.com/oauth2/callback&amp;grant_type=authorization_code" target="_blank" rel="noopener">https://app.example.com/oauth2/callback&amp;grant_type=authorization_code</a></p>
</blockquote>
<p>grant_type是OAuth的可扩展性部分。这是来自预先获得的授权代码。它开辟了用不同方式来描述这些授权的灵活性。这是最常见的OAuth流程类型。</p>
<p><strong>Response</strong></p>
<blockquote>
<p>{<br>  “access_token”: “2YotnFZFEjr1zCsicMWpAA”,<br>  “token_type”: “Bearer”,<br>  “expires_in”: 3600,<br>  “refresh_token”: “tGzv3JOkF0XG5Qx2TlKWIA”<br>}</p>
</blockquote>
<p>响应是JSON。您可以在使用令牌时具有反应性或主动性。主动性是在你的客户端有一个计时器。反应性是捕捉一个错误，然后尝试获取新的令牌。</p>
<p>一旦获得访问令牌，就可以在验证头中使用访问令牌（使用token_type前缀）来提出受保护的资源请求。</p>
<blockquote>
<p>curl -H “Authorization: Bearer 2YotnFZFEjr1zCsicMWpAA” \<br>  <a href="https://www.googleapis.com/gmail/v1/users/1444587525/messages" target="_blank" rel="noopener">https://www.googleapis.com/gmail/v1/users/1444587525/messages</a></p>
</blockquote>
<p>所以现在你有一个前向通道，一个后向通道，不同的终端和不同的客户端。你必须为不同的用例进行混合和匹配。这增加了OAuth的复杂性，并且可能会引起混淆。</p>
<h3 id="OAuth流程"><a href="#OAuth流程" class="headerlink" title="OAuth流程"></a>OAuth流程</h3><p>第一个流程就是我们所说的<strong>隐式流程（Implicit Flow）</strong>。它被称为隐式流的原因是因为所有的通信都是通过浏览器进行的。没有后端服务器为访问令牌兑换授权许可。SPA是这个流程用例的一个很好的例子。该流程也称为2 Legged OAuth。</p>
<p>隐式流程针对仅限于浏览器的公共客户端进行了优化。访问令牌直接从授权请求中返回（仅限于前向通道）。它通常不支持刷新标记。它假定资源所有者和公共客户端位于同一设备上。由于所有事情都发生在浏览器上，它最容易受到安全威胁的影响。</p>
<p>黄金标准是<strong>授权代码流程（Authorization Code Flow）</strong>，又名3 Legged，它同时使用前向通道和后向通道。这就是我们在本文中讨论最多的内容。客户端应用程序使用前向通道流获取授权码授权。客户端应用程序使用后向通道交换访问令牌（以及可选的刷新令牌）的授权代码授权。它假定资源所有者和客户端应用程序位于不同的设备上。这是最安全的流程，因为您可以验证客户端以兑换授权授权，令牌永远不会通过用户代理。不仅有隐式流程和授权码流程，您还可以使用OAuth执行额外的流程。因此，OAuth更像是一个框架。</p>
<p>对于服务器到服务器方案，您可能需要使用<strong>客户端凭证流程（Client Credential Flow）</strong>。在这种情况下，客户端应用程序是一个受信任的客户端，它自己独立运行，而不是代表用户。它更像是一种服务帐户类型的场景。您所需要的只是客户的凭证来完成整个流程。这是一个仅使用客户凭证获取访问令牌的后向通道。它支持共享秘钥或断言，作为使用对称或非对称密钥签名的客户端凭证。</p>
<p>对称密钥算法是加密算法，只要您有密码，就可以解密任何内容。这通常在保护PDF或.zip文件时发现。</p>
<p>公钥加密或非对称加密是使用密钥对的任何加密系统：公钥和私钥。公钥可以被任何人读取，私钥对于所有者来说是神圣的。这使得数据安全无需分享密码。</p>
<p>还有一种传统模式称为<strong>资源所有者密码流程（Resource Owner Password Flow）</strong>。这与使用用户名和密码方案的直接身份验证非常相似，不推荐使用。它是原生用户名/密码应用程序（如桌面应用程序）的传统授权类型。在此流程中，您向客户端应用程序发送用户名和密码，并从授权服务器返回访问令牌。它通常不支持刷新令牌，并且假定资源所有者和公共客户端位于同一设备上。</p>
<p>对OAuth的最新补充是<strong>断言流程（Assertion Flow）</strong>，它与客户端证书流程类似。这是为了打开联合认证的想法。该流程允许授权服务器信任来自第三方的授权许可，如SAML IdP。授权服务器信任身份提供商。该断言用于从令牌endpoint获取访问令牌。这对于那些投资SAML或SAML相关技术并允许他们与OAuth集成的公司来说非常有用。由于SAML断言是短暂的，因此此流程中不存在刷新标记，并且每次断言到期时都必须继续检索访问标记。</p>
<p>不在OAuth规范中的，是<strong>设备流程（Device Flow）</strong>。没有网络浏览器，只有一个像电视一样的控制器。用户code是从授权请求返回的，必须通过浏览器上的URL访问授权请求才能进行授权。客户端应用程序使用后向通道流程来轮询访问令牌和可选刷新令牌的授权许可。这种方式也在CLI客户端中很受欢迎。</p>
<p>我们已经使用不同的角色和标记类型介绍了六种不同的流程。由于客户端的能力，我们需要获得客户端的同意书，以及了解谁正在征求同意，这些都是必要的，并且为OAuth增加了很多复杂性。</p>
<p>当人们问你是否支持OAuth时，你必须澄清他们要求的东西。他们问你是支持全部六个流程，还是只支持主流程？在所有不同的流程之间有很多可用的粒度。</p>
<h3 id="安全和企业"><a href="#安全和企业" class="headerlink" title="安全和企业"></a>安全和企业</h3><p>OAuth有很大的覆盖面。有了隐式流程，就有很多重定向和很多错误空间。有很多人试图在应用程序之间利用OAuth，如果你不遵循推荐的网络安全101准则，就很容易做到。例如：</p>
<ul>
<li>始终使用带state参数的CSRF令牌来确保流程完整性</li>
<li>始终将重定向URI列入白名单，以确保正确的URI验证</li>
<li>将同一客户端绑定到具有客户端ID的授权许可和令牌请求</li>
<li>对于受信任的客户，确保客户机密不泄露。不要把你的应用程序中的客户端秘密通过App Store分发！</li>
</ul>
<p>关于OAuth的最大抱怨一般来自安全人员。这是关于Bearer tokens，并且他们可以像会话cookie一样传递。您可以将它传递出去，而且您可以很好地进行操作，而不是以加密方式绑定到用户。使用JWT有助于避免被篡改。但是，最终，JWT只是一串字符，因此它们可以轻松复制并用于Authorization标题中。</p>
<h3 id="企业OAuth-2-0使用案例"><a href="#企业OAuth-2-0使用案例" class="headerlink" title="企业OAuth 2.0使用案例"></a>企业OAuth 2.0使用案例</h3><p>OAuth将授权策略决策与身份验证分离开来。它可以正确地混合细粒度和粗粒度的授权。它可以取代传统的Web访问管理（WAM）策略。在构建可访问特定API的应用程序时，限制和撤销权限也很好。它确保只有托管或兼容的设备才能访问特定的API。它与身份取消配置工作流程深度集成，以撤消用户或设备的所有令牌。最后，它支持与身份提供者的联合。</p>
<h3 id="OAuth不是身份验证协议"><a href="#OAuth不是身份验证协议" class="headerlink" title="OAuth不是身份验证协议"></a>OAuth不是身份验证协议</h3><p>总结一下OAuth 2.0的一些误解：它不与OAuth 1.0向后兼容。它用HTTPS替代所有通信的签名。今天人们谈论OAuth时，他们正在谈论OAuth 2.0。</p>
<p>由于OAuth是授权框架而不是协议，因此您可能会遇到互操作性问题。团队如何实施OAuth有很多差异，您可能需要自定义代码才能与供应商进行集成。</p>
<p>OAuth 2.0不是身份验证协议。它甚至在<a href="https://oauth.net/articles/authentication/" target="_blank" rel="noopener">文档</a>中都这么说。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-not-authentication.png" alt="OAuth 2.0不是身份验证协议"></p>
<p>我们一直在谈论授权。这不是关于验证用户，这是关键。仅对于OAuth 2.0来说，用户是不存在的。您只需拥有一个令牌即可访问资源。</p>
<p>在过去的几年中，OAuth发生了大量的增加。这些增加了OAuth之上的复杂性，以完成各种企业方案。例如，JWT可以用作可签名和加密的互操作令牌。</p>
<h3 id="使用OAuth-2-0进行伪身份验证"><a href="#使用OAuth-2-0进行伪身份验证" class="headerlink" title="使用OAuth 2.0进行伪身份验证"></a>使用OAuth 2.0进行伪身份验证</h3><p>Facebook Connect和Twitter让着名的OAuth登录成为了热门话题。在此流程中，客户端使用/me的endpoint访问获取令牌。它所说的是，客户端可以使用令牌访问资源。人们发明了这个假端点，作为用访问令牌取回用户配置文件的一种方式。这是获取用户信息的非标准方式。标准中没有任何人说每个人都必须实现这个端点。访问令牌意味着不透明。它们是为了API而设计的，它们不是为了包含用户信息而设计的。</p>
<p>你真正尝试验证与回答的问题应该是：这是谁的用户，有没有对用户进行认证，以及如何做的用户进行身份验证。您通常可以通过SAML断言来回答这些问题，而不是使用访问令牌和授权许可。这就是我们称之为伪认证的原因。</p>
<h3 id="输入OpenID-Connect"><a href="#输入OpenID-Connect" class="headerlink" title="输入OpenID Connect"></a>输入OpenID Connect</h3><p>为解决伪身份验证问题，将OAuth 2.0，Facebook Connect和SAML 2.0的最佳部分组合在一起，创建OpenID Connect。OpenID Connect（OIDC）扩展了OAuth 2.0，id_token为客户端和UserInfo endpoint提供了新的用户属性签名。与SAML不同，OIDC为身份提供了一套标准范围和声明。例子包括：profile，email，address，和phone。</p>
<p>OIDC的创建是为了使网络具有完全动态的可扩展性。不再需要像SAML那样下载元数据和联合认证。内置的动态联合认证可以注册，发现元数据。您可以输入您的电子邮件地址，然后它动态地发现您的OIDC提供商，动态下载元数据，动态地知道它将使用的证书，并允许BYOI(Bring Your Own Identity)。它支持企业的高保证级别和关键SAML使用案例。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/openid-connect-protocol.png" alt="OpenID连接协议套件"></p>
<p>OIDC因谷歌和微软两大早期使用者而闻名。Okta也在OIDC上投入了大量资金。</p>
<p>初始请求中的变化就是它包含标准作用域（如openid和email）：</p>
<p><strong>Request</strong></p>
<blockquote>
<p>GET <a href="https://accounts.google.com/o/oauth2/auth?" target="_blank" rel="noopener">https://accounts.google.com/o/oauth2/auth?</a><br>scope=openid email&amp;<br>redirect_uri=<a href="https://app.example.com/oauth2/callback&amp;" target="_blank" rel="noopener">https://app.example.com/oauth2/callback&amp;</a><br>response_type=code&amp;<br>client_id=812741506391&amp;<br>state=af0ifjsldkj</p>
</blockquote>
<p><strong>Response</strong></p>
<blockquote>
<p>HTTP/1.1 302 Found<br>Location: <a href="https://app.example.com/oauth2/callback?" target="_blank" rel="noopener">https://app.example.com/oauth2/callback?</a><br>code=MsCeLvIaQm6bTrgtp7&amp;state=af0ifjsldkj</p>
<p><em>code</em>返回授权认证，<em>state</em>确保它不是伪造的，即它是由同一个请求发出。</p>
</blockquote>
<p>而授权获取令牌的响应包含一个ID令牌。</p>
<p><strong>Request</strong>    </p>
<blockquote>
<p>POST /oauth2/v3/token HTTP/1.1<br>Host: www.googleapis.com<br>Content-Type: application/x-www-form-urlencoded</p>
<p>code=MsCeLvIaQm6bTrgtp7&amp;client_id=812741506391&amp;<br>  client_secret={client_secret}&amp;<br>  redirect_uri=<a href="https://app.example.com/oauth2/callback&amp;" target="_blank" rel="noopener">https://app.example.com/oauth2/callback&amp;</a><br>  grant_type=authorization_code</p>
</blockquote>
<p><strong>Response</strong></p>
<blockquote>
<p>{<br>  “access_token”: “2YotnFZFEjr1zCsicMWpAA”,<br>  “token_type”: “Bearer”,<br>  “expires_in”: 3600,<br>  “refresh_token”: “tGzv3JOkF0XG5Qx2TlKWIA”,<br>  “id_token”: “eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ…”<br>}</p>
</blockquote>
<p>您可以看到，在OAuth之上很好地分层，将ID令牌作为结构化令牌返回。一个ID令牌是一个JSON Web令牌（JWT）。JWT（aka“jot”）比基于XML的巨大SAML断言小得多，可以在不同设备之间高效传递。JWT有三部分：标题(header)，正文(body)和签名(signature)。标题说明使用什么算法对它进行签名，声明(claims)在正文中，并且在签名中签名。</p>
<p>Open ID Connect流程涉及以下步骤：</p>
<ul>
<li>发现OIDC元数据</li>
<li>执行OAuth流程以获取id令牌和访问令牌</li>
<li>获取JWT签名密钥并可选择动态注册客户端应用程序</li>
<li>根据内置日期和签名在本地验证JWT ID令牌</li>
<li>根据需要使用访问令牌获取其他用户属性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oidc-flow.png" alt="OIDC流程"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OAuth 2.0是委托访问API的授权框架。它涉及请求资源所有者授权/同意的范围的客户端。授权授予交换访问令牌和刷新令牌（取决于流程）。有多种流程来解决不同的客户端和授权方案。JWT可用于授权服务器和资源服务器之间的结构化令牌。</p>
<p>OAuth具有非常大的安全覆盖面。确保使用安全工具包并验证所有输入！</p>
<p>OAuth不是身份验证协议。OpenID Connect针对身份验证方案扩展了OAuth 2.0，通常称为“带花括号的SAML”。如果您希望进一步深入了解OAuth 2.0，我建议您查看<a href="https://www.oauth.com/" target="_blank" rel="noopener">OAuth.com</a>，使用Okta的Auth SDK进行测试，然后尝试自己的OAuth流程。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
            <category> OIDC </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
            <tag> OIDC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用gradle构建Java 9模块化系统快速指南]]></title>
      <url>/2018/04/11/gradle-guide-java9/</url>
      <content type="html"><![CDATA[<p><strong>本文是gradle官方的构建Java 9模块化系统的入门指南的翻译。（<a href="https://guides.gradle.org/building-java-9-modules/?_ga=2.174270880.30455902.1522735364-1287880600.1513842256" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>Java 9最令人兴奋的特性之一是它支持开发和部署Java模块化系统。在本指南中，您将了解到如何用gradle实现模块化功能，你所要做的事情：</p>
<ol>
<li>为您的Java库生成Java 9模块。</li>
<li>使用Java 9模块作为您的依赖。</li>
<li>在Java 9模块中使用Java的ServiceLoader模式。</li>
<li>使用Java 9模块运行应用程序。</li>
<li>使用一个插件来更简单地完成以上功能。</li>
</ol>
<p>虽然Gradle 4.6版尚未对Java 9模块提供一流的支持，本指南仍将向您介绍如何在支持完成之前对Java 9进行试验性的工作。</p>
<h3 id="你需要什么"><a href="#你需要什么" class="headerlink" title="你需要什么"></a>你需要什么</h3><ol>
<li>大约41分钟</li>
<li>一个文本编辑器</li>
<li>一个命令提示符</li>
<li>Java开发工具包（JDK），版本1.9（版本174）+</li>
</ol>
<h3 id="了解示例项目"><a href="#了解示例项目" class="headerlink" title="了解示例项目"></a>了解示例项目</h3><p>本指南逐步说明，如何将不使用任何Java 9功能的Java应用程序，转换为完全模块化的Java 9应用程序。原始版本的应用程序的源代码位于src/0-original目录中。它是由六个子项目组成的gradle多项目程序：</p>
<ol>
<li>fairy - java应用程序storyteller的入口点。</li>
<li>tale - 公共Tale接口的库。</li>
<li>formula - 帮助改造Tale接口的库。</li>
<li>actors - fairy tale中所有characters的库。</li>
<li>pigs - 代表三个小猪的Tale实例的库。</li>
<li>bears - 代表金发姑娘和三只熊的Tale实例的库。</li>
</ol>
<p>六个项目之间依赖关系的项目层次结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/gradle_guide_java9/project-graph.png" alt="gradle-java9-1"></p>
<p>如果你对api和implementation不熟悉，请参阅在Gradle 3.5中加入的<a href="https://docs.gradle.org/current/userguide/java_library_plugin.html?_ga=2.204456536.934686470.1523424544-1287880600.1513842256" target="_blank" rel="noopener">Java Library Plugin</a></p>
<p>你可以克隆源代码来查看原始项目的输出：</p>
<pre><code class="bash">$ git clone https://github.com/gradle-guides/building-java-9-modules.git
$ cd building-java-9-modules/src/0-original
$ ./gradlew run

&gt; Task :fairy:run
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

&lt;... elided ...&gt;

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.


BUILD SUCCESSFUL
</code></pre>
<p>在开始修改此项目以使其使用Java 9模块之前，您需要了解项目结构的两个重要细节，就是，它使用 ServiceLoader API来在运行时加载fairy tale，并且它包含一个测试类来显示在使用Java 9之前，软件的模块封装是多么的脆弱。</p>
<h4 id="ServiceLoader的用法"><a href="#ServiceLoader的用法" class="headerlink" title="ServiceLoader的用法"></a>ServiceLoader的用法</h4><p>Java 1.6引入了一种简单的机制，用于在运行时将一些接口（“Service”）的一组实现绑定到一个消费类。有关该特性的<a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html" target="_blank" rel="noopener">Oracle教程</a>有点冗长，下面是它在示例应用程序中的使用方式：</p>
<pre><code class="java">public static void main(String[] args) {
        ServiceLoader&lt;Tale&gt; loader = ServiceLoader.load(Tale.class);
        if (!loader.iterator().hasNext()) {
            System.out.println(&quot;Alas, I have no tales to tell!&quot;);
        }
        for (Tale tale : loader) {
            tale.tell();
        }
    }
</code></pre>
<p>JVM中的类加载器用ServiceLoader来找出，类路径上META-INF/services文件夹中的，名为org.gradle.fairy.tale.Tale的指定Tale类。</p>
<p>ears/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale:</p>
<pre><code class="java">org.gradle.fairy.tale.bears.GoldilocksAndTheThreeBears
</code></pre>
<p>pigs/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale:</p>
<pre><code class="java">org.gradle.fairy.tale.pigs.ThreeLittlePigs
</code></pre>
<p>在运行时加载这些实例,会使StoryTeller类以松耦合的方式连接到实现该Tale接口的两个库。你可以在应用程序的build.gradle文件的dependencies块中看到它。</p>
<p>fairy/build.gradle:</p>
<pre><code class="gradle">dependencies {
    implementation project(&#39;:tale&#39;)

    runtimeOnly project(&#39;:pigs&#39;)
    runtimeOnly project(&#39;:bears&#39;)
}
</code></pre>
<p>注释掉以runtimeOnly开头的两行，并注意Gradle run任务的输出是如何改变的：</p>
<pre><code class="bash">$ ./gradlew run

&gt; Task :fairy:run
Alas, I have no tales to tell!


BUILD SUCCESSFUL
</code></pre>
<h4 id="模块化测试讨论"><a href="#模块化测试讨论" class="headerlink" title="模块化测试讨论"></a>模块化测试讨论</h4><p>在最初的项目中，有一个测试类，展现了在Java 9之前的Java版本中，未实施模块化的一些问题。<br>formula/src/test/java/org/gradle/fairy/tale/formula/ModularityTest.java：</p>
<pre><code class="java">    @Test
    public void canReachActor() {
        Actor actor = Imagination.createActor(&quot;Sean Connery&quot;);
        assertEquals(&quot;Sean Connery&quot;, actor.toString());
    }

    @Test
    public void canDynamicallyReachDefaultActor() throws Exception {
        Class clazz = ModularityTest
            .class.getClassLoader()
            .loadClass(&quot;org.gradle.actors.impl.DefaultActor&quot;);
        Actor actor = (Actor) clazz.getConstructor(String.class)
            .newInstance(&quot;Kevin Costner&quot;);
        assertEquals(&quot;Kevin Costner&quot;, actor.toString());
    }

    @Test
    public void canReachDefaultActor() {
        Actor actor = new org.gradle.actors.impl.DefaultActor(&quot;Kevin Costner&quot;);
        assertEquals(&quot;Kevin Costner&quot;, actor.toString());
    }

    /*
    @Test
    public void canReachGuavaClasses() {
        // This line would throw a compiler error because gradle has kept the implementation dependency &quot;guava&quot;
        // from leaking into the formula project.
        Set&lt;String&gt; strings = com.google.common.collect.ImmutableSet.of(&quot;Hello&quot;, &quot;Goodbye&quot;);
        assertTrue(strings.contains(&quot;Hello&quot;));
        assertTrue(strings.contains(&quot;Goodbye&quot;));
    }
    */
</code></pre>
<p>这个类的四个测试有不同的目的：</p>
<ol>
<li>canReachActor - 通过调用actors项目的公共api来表明formula项目的访问权限。</li>
<li>canDynamicallyReachDefaultActor - 尝试在运行时使用反射来加载actors子项目的私有类。这在Java 9之前是可能的，因为类路径会将应用程序的所有的实现细节暴露给其他所有的应用。</li>
<li>canReachDefaultActor - 尝试直接使用actors子项目的私有类。这只在Java 9之前可行，因为actors子项目的私有实现细节与该子项目的公共API构建在相同的位置。所以，它们在编译时和运行时都可用。</li>
<li>canReachGuavaClasses - 尝试使用actors子项目所依赖的类。需要注意的是，从Gradle 3.4开始，使用implementation关键字的依赖关系不包含在Java项目的消费者的编译类路径（compileClasspath）中。因此，这个测试被注释掉了，因为它不能用Gradle 3.4或更新的版本编译。</li>
</ol>
<p>遵循本指南，你会看到Java 9将对于模块细节的访问权限变得更加紧密，并导致测试，canDynamicallyReachDefaultActor和canReachDefaultActor在运行时或编译时失败。</p>
<p>你可以运行Gradle的check任务，来认证这三个测试是否通过了0-original项目（尽管其中两个测试 打破了良好的模块化设计。）</p>
<pre><code class="bash">$ ./gradlew check

BUILD SUCCESSFUL
</code></pre>
<p>您可以在<a href="https://scans.gradle.com/s/l76lgbuizu4pm/tests/byProject?toggled=W1sxXSxbMSwwXSxbMSwwLDBdLFsxLDAsMCwwXV0" target="_blank" rel="noopener">建构扫描</a>中查看此次调用gradle task任务的结果。</p>
<h3 id="第1步-为单个子项目生成Java-9模块"><a href="#第1步-为单个子项目生成Java-9模块" class="headerlink" title="第1步 - 为单个子项目生成Java 9模块"></a>第1步 - 为单个子项目生成Java 9模块</h3><p>如果您还不熟悉Java 9模块系统，请阅读：</p>
<ol>
<li><a href="http://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener">模块系统快速入门指南</a> / <a href="http://seanthefish.com/2018/03/29/java9-quick-guide/">(原文翻译)</a></li>
<li><a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">模块系统综述</a> / <a href="http://seanthefish.com/2018/03/29/module-system/">(原文翻译)</a></li>
</ol>
<p>本指南假定您已经熟悉以下概念：</p>
<ol>
<li>模块路径</li>
<li>自动模块</li>
<li>module-info.java文件的基本语法</li>
</ol>
<p>Java 9中模块系统的一个很好的功能就是可以以自下而上的方式将项目的所有代码库转换为Java 9模块。无论是从类路径还是模块路径中，我们都可以获取Java 9模块化jar包，所以我们可以在多项目构建中，转换单个叶节点以生成Java 9模块，但是在编译时使用该模块化的jar包或在类路径上使用该模块化jar包来运行该节点的输出。</p>
<p>将java-library项目转换为Java 9模块时，应该对项目进行五项更改:</p>
<ol>
<li>添加一个module-info.java文件来描述模块。</li>
<li>修改compileJava任务以生成模块。</li>
<li>修改compileTestJava任务以在本地修改模块。</li>
<li>修改test任务以使用本地更改的模块。</li>
<li>（可选）在所有其他项目的清单条目（MANIFEST.MF）中添加Automatic-Module-Name属性。</li>
</ol>
<p>我们建议为组成应用程序的所有项在META-INF/MANIFEST.MF文件中主动添加目Automatic-Module-Name清单条目 。提供Automatic-Module-Name允许库作者为未来预留模块名称，而不必将库转换为模块。这确保了库的消费者现在就可以知道模块名称将来会是什么。</p>
<p>在下面的小节中将介绍这些变化，并讨论为什么要进行变更。您还可以通过浏览src/1-single-module库中的示例项目来查看这些更改的结果。</p>
<p>我们做出以下五项改变的目标是让actors项目生成一个Java 9模块。前四项变更需要一起完成，第五项（可选）变更可以独立完成。</p>
<blockquote>
<p>提醒一下，从这一点开始，所有的构建都需要在Java 9上运行</p>
</blockquote>
<h4 id="添加一个module-info-java文件来描述模块。"><a href="#添加一个module-info-java文件来描述模块。" class="headerlink" title="添加一个module-info.java文件来描述模块。"></a>添加一个module-info.java文件来描述模块。</h4><p>将module-info.java文件添加到项目的actors/src/main/java目录。</p>
<p>actors/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.actors {
    exports org.gradle.actors;
    requires guava;
}
</code></pre>
<p>该文件声明org.gradle.actors模块导出org.gradle.actors包（但不org.gradle.actors.impl包），并需要guava模块。Guava jar文件还不是Java 9模块，所以当你需要它们时，你必须使用JVM通过jar文件的文件名来推断生成的自动模块的名称。对于guava来说，jar文件的名称是<a href="http://central.maven.org/maven2/com/google/guava/guava/22.0/" target="_blank" rel="noopener">guava-22.0.jar</a>，因此根据<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/#automatic-modules" target="_blank" rel="noopener">自动模块名称的规则</a>，您需要的模块叫guava。</p>
<h4 id="修改compileJava任务以生成模块。"><a href="#修改compileJava任务以生成模块。" class="headerlink" title="修改compileJava任务以生成模块。"></a>修改compileJava任务以生成模块。</h4><p>在actors子项目的build.gradle文件中添加以下内容。</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">ext.moduleName = &#39;org.gradle.actors&#39; //(1)

compileJava {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        options.compilerArgs = [
            &#39;--module-path&#39;, classpath.asPath,
        ]
        classpath = files()  //(2)
    }
}
</code></pre>
<ol>
<li>为模块名称定义一个变量，该变量允许您稍后为其他模块重复使用相同的代码，而无需对其进行更改。</li>
<li>通过创建一个空文件集合来清除classpath属性。</li>
</ol>
<p>编译Java 9模块时，您想使用–module-path而不是 –classpath读取您的依赖关系。因此，在该doFirst块中，您将清除该任务的classpath属性并添加一个编译器参数。</p>
<blockquote>
<p>–module-path被设置为原来的值classpath。这样做是因为，classpath已经有你所依赖的库的所有jar包和类输出目录。</p>
<p>在doFirst代码块内而不是在compileJava任务中修改options.compilerArgs参数的原因是，在执行这个任务时，你只需要重构compileClasspath（编译时的类路径）的配置。</p>
</blockquote>
<h4 id="修改compileJava任务以生成模块。-1"><a href="#修改compileJava任务以生成模块。-1" class="headerlink" title="修改compileJava任务以生成模块。"></a>修改compileJava任务以生成模块。</h4><p>Java 9模块系统的一个稍微混淆的方面是如何对Java 9模块内的代码运行单元测试。推荐的方法是在测试过程中“修补”模块。修补模块意味着向组成模块的包添加额外的类。在运行测试所需要的修补模块步骤中，您将使用相同的包来把测试类添加到模块中，以便测试类可以访问被测模块中的所有其他模块。</p>
<p>将以下内容添加到您build.gradle文件中，来实现在编译时对org.gradle.actors模块的修补。</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">compileTestJava {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        options.compilerArgs = [
            &#39;--module-path&#39;, classpath.asPath, \\(1)
            &#39;--add-modules&#39;, &#39;junit&#39;,  \\(2)
            &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;, \\(3)
            &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.srcDirs).asPath, \\(4)
        ]
        classpath = files()
    }
}
</code></pre>
<ol>
<li>用–module-path参数来作为classpath属性的默认值。</li>
<li>显式地将junit自动模块添加为可观察模块。</li>
<li>声明junit模块读取org.gradle.actors模块。</li>
<li>将测试源文件添加到org.gradle.actors模块。</li>
</ol>
<p>这些选项的添加将会导致测试源的输出目录中的生成类文件包含合适的元数据来修补org.gradle.actors模块，这些类文件会在接下来的更改中被使用。</p>
<h4 id="修改test任务以使用本地更改的模块。"><a href="#修改test任务以使用本地更改的模块。" class="headerlink" title="修改test任务以使用本地更改的模块。"></a>修改test任务以使用本地更改的模块。</h4><p>运行测试时，我们必须配置运行测试的JVM使其发现我们的模块，并修补org.gradle.actors模块来引入测试类。</p>
<p>将以下内容添加到actors项目中的build.gradle文件中。</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">test {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        jvmArgs = [
            &#39;--module-path&#39;, classpath.asPath, \\(1)
            &#39;--add-modules&#39;, &#39;ALL-MODULE-PATH&#39;, \\(2)
            &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;, \\(3)
            &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.outputDir).asPath, \\(4)
        ]
        classpath = files()
    }
}
</code></pre>
<ol>
<li>这是测试运行时的classpath属性的默认值。</li>
<li>使用特殊的ALL-MODULE-PATH，因为运行测试的JVM的main class不是Java 9模块的一部分。它是Gradle的测试运行器，因此它没有声明它需要使用的模块。该参数使模块路径中的所有模块都可以被测试类访问。</li>
<li>声明junit读取org.gradle.actors模块。</li>
<li>将测试类添加到org.gradle.actors模块。</li>
</ol>
<h4 id="（可选）在所有其他项目的清单条目（MANIFEST-MF）中添加Automatic-Module-Name属性。"><a href="#（可选）在所有其他项目的清单条目（MANIFEST-MF）中添加Automatic-Module-Name属性。" class="headerlink" title="（可选）在所有其他项目的清单条目（MANIFEST.MF）中添加Automatic-Module-Name属性。"></a>（可选）在所有其他项目的清单条目（MANIFEST.MF）中添加Automatic-Module-Name属性。</h4><p>为了向后兼容，Java 9的模块系统允许非模块化的jar文件出现在模块路径中。默认情况下，这些jar文件将被转换为自动模块，其名称基于jar文件的文件名。但是这会导致一些冗杂。许多jar文件名已经创建，但没有任何规则能保证这个jar的名字是唯一的。所以当负责维护一些常用jar的开发人员在将该jar转换为Java 9模块时，他们更希望会选择一个新的模块名称，而非由自动模块转换所自动生成的名称。</p>
<p>例如，你现在可以在module-info.java文件中通过requires guava子句指定模块，但稍后负责该项目的开发人员决定为其模块命名com.google.guava。现在，任何指定requires guava或任何依赖此模块的用户，都必须改变它们依赖的模块为requires com.google.guava，如此才能使用这些新模块，因为Java 9只允许模块路径上的模块包含特定的包。</p>
<p>因此，整个情况可能会变得非常混乱。这就是为什么<a href="http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html" target="_blank" rel="noopener">Stephen Colebourne认为</a>我们应该立即开始更新我们发布到公共存储库的所有jar,（至少要在jar的清单中指定Automatic-Module-Name属性），而且也不要发布任何未指定Automatic-Module-Name属性并且包含需要自动模块的模块的工件。</p>
<p>因此，在每个子项目的build.gradle文件中指定一个moduleName变量。例如：</p>
<p>fairy/build.gradle:</p>
<pre><code class="gradle">ext.moduleName = &#39;org.gradle.fairy.app&#39;
</code></pre>
<p>另外，在顶层build.gradle文件中的afterEvaluate代码块中的jar任务中添加manifest属性。</p>
<pre><code class="gradle">jar {
        inputs.property(&quot;moduleName&quot;, moduleName)
        manifest {
            attributes(&#39;Automatic-Module-Name&#39;: moduleName)
        }
    }
</code></pre>
<p>现在，当您将jar文件发布到像Maven Central这样的工件存储库时，你发布的jar包的文件名就不再重要了; 你一定会（通过Automatic-Module-Name）得到你想要的Java 9模块名称。</p>
<blockquote>
<p>在下一步中，您将摆脱这些清单属性，因为您已将每个子项目都转换为适当的Java 9模块。</p>
</blockquote>
<h4 id="第1步-总结"><a href="#第1步-总结" class="headerlink" title="第1步 - 总结"></a>第1步 - 总结</h4><p>这第一步是最复杂的，但现在您已经将第一个java-library项目转换为Java 9模块。所有其他子项目都在类路径上使用该模块。我们并没有真正解决在<a href="#模块化测试讨论">模块化测试讨论</a>中演示的任何模块化违规问题 ，但是我们不必中断项目，将其逻辑体系结构转换为适当的Java 9模块。接下来，我们将根目录的build.gradle项目中来集中gradle更改，并将其应用于所有子项目中。</p>
<h3 id="第2步-为所有子项目生成Java-9模块"><a href="#第2步-为所有子项目生成Java-9模块" class="headerlink" title="第2步 - 为所有子项目生成Java 9模块"></a>第2步 - 为所有子项目生成Java 9模块</h3><p>这一步的目标是让我们的Gradle构建中的所有子项目都生成Java 9模块，并将它们的依赖作为Java 9模块使用。由于您已将actors子项目中的build.gradle文件中的moduleName变量声明与其他改变分离，因此只需将该文件中的moduleName声明以后的所有内容剪切并粘贴到根目录build.gradle文件中的afterEvaluate代码块中即可。</p>
<p>build.gradle：</p>
<pre><code class="gradle">subprojects {
    afterEvaluate {
        repositories {
            jcenter()
        }

        compileJava {
            inputs.property(&quot;moduleName&quot;, moduleName)
            doFirst {
                options.compilerArgs = [
                    &#39;--module-path&#39;, classpath.asPath,
                ]
                classpath = files()
            }
        }

        compileTestJava {
            inputs.property(&quot;moduleName&quot;, moduleName)
            doFirst {
                options.compilerArgs = [
                    &#39;--module-path&#39;, classpath.asPath,
                    &#39;--add-modules&#39;, &#39;junit&#39;,
                    &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;,
                    &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.srcDirs).asPath,
                ]
                classpath = files()
            }
        }

        test {
            inputs.property(&quot;moduleName&quot;, moduleName)
            doFirst {
                jvmArgs = [
                    &#39;--module-path&#39;, classpath.asPath,
                    &#39;--add-modules&#39;, &#39;ALL-MODULE-PATH&#39;,
                    &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;,
                    &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.outputDir).asPath,
                ]
                classpath = files()
            }
        }
    }
}
</code></pre>
<blockquote>
<p>如果你做了步骤1的最后一步，则应在粘贴之前删除jar代码块。</p>
</blockquote>
<p>如果您还没有为每个子项目添加moduleName变量声明，那么现在应该这样做。例如：</p>
<p>pigs/build.gradle：</p>
<pre><code class="gradle">ext.moduleName = &#39;org.gradle.fairy.tale.pigs&#39;
</code></pre>
<p>您还需要为每个子项目添加一个module-info.java文件。例如：</p>
<p>bears/src/main/java/module-info.java:</p>
<pre><code class="gradle">module org.gradle.fairy.tale.bears {
    requires org.gradle.actors;
    requires transitive org.gradle.fairy.tale;
    requires org.gradle.fairy.tale.formula;

    exports org.gradle.fairy.tale.bears;
}
</code></pre>
<blockquote>
<p>您还需要为pigs， formula，fairy，和tale子项目添加这些module-info.java文件。最终结果应该看起来像src/2-all-modules中的代码。</p>
</blockquote>
<p>现在，Gradle的test任务将无法编译，除非您已将canReachDefaultActor测试注释掉。另外，canDynamicallyReachDefaultActor测试将在测试运行时失败，除非你添加@Ignore注释。</p>
<pre><code class="bash">$ ./gradlew test

&gt; Task :formula:test

org.gradle.fairy.tale.formula.ModularityTest &gt; canDynamicallyReachDefaultActor FAILED
    java.lang.IllegalAccessException at ModularityTest.java:28

2 tests completed, 1 failed


FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task &#39;:formula:test&#39;.
&gt; There were failing tests. See the report at: &lt;link-to-report&gt;

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
</code></pre>
<p>如果你注释掉canReachDefaultActor测试并为canDynamicallyReachDefaultActor添加@Ignore注解，剩下的测试应该通过，你可以在src/2-all-modules中得到完整的代码。</p>
<h4 id="第2步-总结"><a href="#第2步-总结" class="headerlink" title="第2步 - 总结"></a>第2步 - 总结</h4><p>到目前为止，你已经在使用Java 9模块来编译和运行所有六个子项目和测试。这些子项目被适当地封装，并且没有一个包下的测试可以看到这个包所依赖的任何实现细节。但是，<a href="https://docs.gradle.org/4.6/userguide/application_plugin.html?_ga=2.21328251.1136812865.1523857970-1287880600.1513842256" target="_blank" rel="noopener">Gradle的应用程序插件</a>的一些特性依赖于类路径来加载和编译类，而不是模块路径。</p>
<p>此外，Java 9增加了一种更方便的方式来使用ServiceLoader功能。您将在第3步中了解如何处理这些问题。</p>
<h3 id="第3步-在run和assemble任务中使用Java-9模块"><a href="#第3步-在run和assemble任务中使用Java-9模块" class="headerlink" title="第3步 - 在run和assemble任务中使用Java 9模块"></a>第3步 - 在run和assemble任务中使用Java 9模块</h3><p>现在所有子项目都已经转化为为Java 9模块，现在该学习fairy项目中的main class（org.gradle.fairy.app.StoryTeller）在运行时是如何使用这些模块的 。</p>
<p>运行本指南中介绍的应用程序有两种方式。首先是使用由<a href="https://docs.gradle.org/4.6/userguide/application_plugin.html?_ga=2.28841596.1136812865.1523857970-1287880600.1513842256" target="_blank" rel="noopener">应用程序插件</a>添加的Gradle run任务 。</p>
<pre><code class="bash">$ ./gradlew run

&gt; Task :fairy:run
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

&lt;... elided ...&gt;

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.


BUILD SUCCESSFUL
</code></pre>
<p>另一种方法是使用Gradle的assemble任务来分别打包各个应用程序，然后提取到某个目录并在那里运行。</p>
<pre><code class="bash">$ ./gradlew assemble

BUILD SUCCESSFUL
$ cp fairy/build/distributions/fair.tar /tmp
$ cd /tmp
$ tar xvf fairy.tar
x fairy/
x fairy/lib/
x fairy/lib/fairy.jar
x fairy/lib/pigs.jar
x fairy/lib/bears.jar
x fairy/lib/formula.jar
x fairy/lib/tale.jar
x fairy/lib/actors.jar
x fairy/lib/guava-22.0.jar
x fairy/lib/jsr305-1.3.9.jar
x fairy/lib/error_prone_annotations-2.0.18.jar
x fairy/lib/j2objc-annotations-1.1.jar
x fairy/lib/animal-sniffer-annotations-1.14.jar
x fairy/bin/
x fairy/bin/fairy
x fairy/bin/fairy.bat
$ ./bin/fairy
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

&lt;... elided ...&gt;

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.
</code></pre>
<p>在步骤2之后，这两种机制都依赖于出现在类路径上的模块。这样也就会跳过了Java 9模块系统的模块化特性。在这一步中，您将：</p>
<ol>
<li>修改run任务以使用模块。</li>
<li>修改startScript任务来使*nix和Windows系统使用模块。</li>
<li>将ServiceLoader机制更新为Java 9语法。</li>
</ol>
<p>一旦进行了更改1和2，运行该程序的两种机制都应该能直接运行，因此请随时再次运行这些命令以确认您已正确实施每项更改。</p>
<p>您依旧可以在资源代码库中的src/3-application目录中看到所有更改 。</p>
<h3 id="修改run任务以使用模块"><a href="#修改run任务以使用模块" class="headerlink" title="修改run任务以使用模块"></a>修改run任务以使用模块</h3><p>要在run任务中使用Java 9模块，你需要将以下内容添加到fairy项目中的build.gradle文件中。</p>
<p>fairy/build.gradle</p>
<pre><code class="gradle">mainClassName = &quot;$moduleName/org.gradle.fairy.app.StoryTeller&quot; //(1)

run {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        jvmArgs = [
            &#39;--module-path&#39;, classpath.asPath,
            &#39;--module&#39;, mainClassName //(2)
        ]
        classpath = files()
    }
}
</code></pre>
<ol>
<li>设置mainClassName属性包含moduleName。</li>
<li>明确告诉Java 9使用该模块。</li>
</ol>
<h4 id="修改startScript任务来使-nix和Windows系统使用模块。"><a href="#修改startScript任务来使-nix和Windows系统使用模块。" class="headerlink" title="修改startScript任务来使*nix和Windows系统使用模块。"></a>修改startScript任务来使*nix和Windows系统使用模块。</h4><p>在fairy/build/distributions目录中创建的tar和zip文件会包含启动脚本 ，这些脚本允许在所有支持的操作系统上，以可预测的方式启动JVM。</p>
<p>要修改已生成的startScripts，请将以下内容添加到您的fairy/build.gradle文件中：</p>
<p>fairy/build.gradle：</p>
<pre><code class="gradle">startScripts {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        classpath = files()
        defaultJvmOpts = [
            &#39;--module-path&#39;, &#39;APP_HOME_LIBS&#39;,  \\(1)
            &#39;--module&#39;, mainClassName
        ]
    }
    doLast{
        def bashFile = new File(outputDir, applicationName)
        String bashContent = bashFile.text
        bashFile.text = bashContent.replaceFirst(&#39;APP_HOME_LIBS&#39;, Matcher.quoteReplacement(&#39;$APP_HOME/lib&#39;))

        def batFile = new File(outputDir, applicationName + &quot;.bat&quot;)
        String batContent = batFile.text
        batFile.text = batContent.replaceFirst(&#39;APP_HOME_LIBS&#39;, Matcher.quoteReplacement(&#39;%APP_HOME%\\lib&#39;))
    }
}
</code></pre>
<ol>
<li>将模块路径设置为独立于平台的占位符值，稍后将以特定于平台的方式替换*nix shell脚本和Windows .bat文件。</li>
</ol>
<h3 id="将ServiceLoader机制更新为Java-9语法。"><a href="#将ServiceLoader机制更新为Java-9语法。" class="headerlink" title="将ServiceLoader机制更新为Java 9语法。"></a>将ServiceLoader机制更新为Java 9语法。</h3><p>Java 9模块系统引入了一种更好的方式来指定哪些模块为ServiceLoader机制提供服务的实现。首先，从两个目录bears/src/main和pigs/src/main中，删除resources文件夹，因为新机制不需要META-INF/services文件。</p>
<p>然后，调整每个项目的module-info.java文件。</p>
<p>fairy/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.fairy.app {
    requires org.gradle.fairy.tale;
    uses org.gradle.fairy.tale.Tale;
}
</code></pre>
<p>bears/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.fairy.tale.bears {
    requires org.gradle.actors;
    requires transitive org.gradle.fairy.tale;
    requires org.gradle.fairy.tale.formula;

    provides org.gradle.fairy.tale.Tale
        with org.gradle.fairy.tale.bears.GoldilocksAndTheThreeBears;
}
</code></pre>
<p>pigs/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.fairy.tale.pigs {
    requires org.gradle.actors;
    requires transitive org.gradle.fairy.tale;
    requires org.gradle.fairy.tale.formula;

    provides org.gradle.fairy.tale.Tale
            with org.gradle.fairy.tale.pigs.ThreeLittlePigs;
}
</code></pre>
<p>由于fairy项目中的module-info.java声明它使用org.gradle.fairy.tale.Tale服务，所以该模块中的ServiceLoader实例将有权访问，所有由Java 9模块声明的在运行时提供的org.gradle.fairy.tale.Tale服务实现。</p>
<h3 id="第4步-使用experimental-jigsaw插件来做与我们之间所做的同样的事情"><a href="#第4步-使用experimental-jigsaw插件来做与我们之间所做的同样的事情" class="headerlink" title="第4步 - 使用experimental-jigsaw插件来做与我们之间所做的同样的事情"></a>第4步 - 使用experimental-jigsaw插件来做与我们之间所做的同样的事情</h3><p>虽然Gradle尚未将Java 9模块构建作为Java插件的一级特性加以支持，实验性插件也可让您在项目中尝试使用Java 9模块。</p>
<p>org.gradle.java.experimental-jigsaw插件只是一个简便的机制，可以在一个步骤中，提供本指南步骤1至3中的所有更改。它可能适用于您的项目，但您应该考虑到它是实验性的，不适合生产版本。</p>
<p>以下是如何使用插件：</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">plugins {
    id &#39;java-library&#39;
    id &#39;org.gradle.java.experimental-jigsaw&#39; version &#39;0.1.1&#39;  \\(1)
}
</code></pre>
<ol>
<li>使用插件</li>
</ol>
<p>actors/build.gradle：</p>
<pre><code class="gradle">javaModule.name = &#39;org.gradle.actors&#39;  \\(1)
</code></pre>
<ol>
<li>使用新javaModule.name设置来指定模块名称。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时，您的应用程序正在利用Java 9模块系统的大部分功能。本指南向您展示了如何修改常规插件java-library和application所添加的任务，来方便你使用Java 9模块进行工作。未来，Gradle团队将为模块系统添加一流的支持，但您现在就已经可以开始尝试！</p>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
            <category> gradle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
            <tag> gradle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java模块系统综述]]></title>
      <url>/2018/03/29/module-system/</url>
      <content type="html"><![CDATA[<p><strong>本文是Mark Reinhold的The State of the Module System最新版的翻译。（<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<blockquote>
<p>这份文档略有过时。其基本概念没有任何改变，但requires public关键字已被重新命名为requires transitive，并增加了几项附加功能。更新正在准备中，准备就绪后会在这里发布。</p>
</blockquote>
<p>本文是对<a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Jigsaw项目</a>中对Java SE平台所做的增强的一个非正式的概述，并针对<a href="http://openjdk.java.net/projects/jigsaw/spec/" target="_blank" rel="noopener">JSR 376：Java平台模块系统</a>所提出。有<a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">相关的文档</a>描述了对特定于JDK工具和API的增强，这些超出了JSR的范围。</p>
<p>正如JSR所述，模块系统是为了提供可靠的配置，使程序组件相互显式的声明依赖，配合其强大的封装能力，使组件允许声明其中哪些公共类型可供其他组件访问，哪些不可以，并以此来替换脆弱，容易出错的类路径机制。</p>
<p>这些功能将直接对Java SE平台本身、Java应用程序开发人员，Java类库开发人员有利，而且也会间接地实现可伸缩平台、更高的平台完整性和更高的性能。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#定义模块">定义模块</a><ul>
<li><a href="#模块声明">模块声明</a></li>
<li><a href="#模块打包">模块打包</a></li>
<li><a href="#模块描述符">模块描述符</a></li>
<li><a href="#平台模块">平台模块</a></li>
</ul>
</li>
<li><a href="#使用模块">使用模块</a><ul>
<li><a href="#模块路径">模块路径</a></li>
<li><a href="#解决依赖">解决依赖</a></li>
<li><a href="#可读性">可读性</a></li>
<li><a href="#可访问性">可访问性</a></li>
<li><a href="#隐含的可读性">隐含的可读性</a></li>
</ul>
</li>
<li><a href="#兼容性和迁移">兼容性和迁移</a><ul>
<li><a href="#未命名模块">未命名模块</a></li>
<li><a href="#自下而上的迁移">自下而上的迁移</a></li>
<li><a href="#自动模块">自动模块</a></li>
<li><a href="#与类路径建立联系">与类路径建立联系</a></li>
</ul>
</li>
<li><a href="#服务">服务</a></li>
<li><a href="#高级特性">高级特性</a><ul>
<li><a href="#反射">反射</a></li>
<li><a href="#反射的可读性">反射的可读性</a></li>
<li><a href="#类加载器">类加载器</a></li>
<li><a href="#未命名模块与类加载器">未命名模块与类加载器</a></li>
<li><a href="#层">层</a></li>
<li><a href="#限制性导出">限制性导出</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<p>这是本文档的第二版。相对于<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/2015-09-08" target="_blank" rel="noopener">最初版本</a>，本版引入了兼容性和迁移的解释，修改了反射可读性的描述，进行了重新排序以改善叙述的流程，并且组织了更容易定位的目录。</p>
<p>文中仍然存在许多未解决的问题，其解决方案将反映在本文档的未来版本中。</p>
<h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>为了提供可靠的配置和强大的封装，使其既能接近开发人员，又能被现有工具链支持，我们将模块视为一种基本的新型Java程序组件。一个模块是一个命名的，能自我描述的代码和数据的集合。其代码被组织为一组包（package），包中包含Java类和接口。</p>
<h4 id="模块声明"><a href="#模块声明" class="headerlink" title="模块声明"></a>模块声明</h4><p>模块的自我描述体现在它的声明中，这是一种Java编程语言的新构造。最简单的模块声明只是指定其模块的名称：</p>
<pre><code class="java">module com.foo.bar { }
</code></pre>
<p>可以添加一个或多个require子句来声明该模块在编译时和运行时依赖于其他名称的某些模块：</p>
<pre><code class="java">module com.foo.bar {
    requires org.baz.qux;
}
</code></pre>
<p>最后，可以添加exports子句来声明该模块中仅有特定包中的公共类型可供其他模块使用：</p>
<pre><code class="java">module com.foo.bar {
    requires org.baz.qux;
    exports com.foo.bar.alpha;
    exports com.foo.bar.beta;
}
</code></pre>
<p>如果一个模块的声明不包含任何exports子句，那么它将不会导出任何类型到其他模块。</p>
<p>按照惯例，模块声明的源代码放置在名为module-info.java的文件中，该文件位于模块的源文件层次结构的根目录下。 com.foo.bar模块的源文件可能包括：</p>
<pre><code class="java">module-info.java
com/foo/bar/alpha/AlphaFactory.java
com/foo/bar/alpha/Alpha.java
...
</code></pre>
<p>按照惯例，模块声明被编译成名为module-info.class的文件，并放置在.class文件输出目录中。</p>
<p>模块名称跟包名称一样，不得相互冲突。命名模块的推荐方法是使用长期用于命名软件包的反向域名模式。因此，模块的名称通常就是其导出包名称的前缀，但这种关系不是强制性的。</p>
<p>模块的声明不包括其版本号，也不包括它所依赖的子模块的版本号。这样做是<a href="http://openjdk.java.net/projects/jigsaw/spec/reqs/02#version-selection" target="_blank" rel="noopener">故意为之</a>的：模块系统的目标不是解决版本选择问题，这最好留给构建工具和容器应用程序来做。</p>
<p>模块声明是Java编程语言的一部分，这其中的原因有几个。其中最重要的一点是，模块必须在编译时和运行时都可用，以实现各个阶段的确定性，即确保模块系统在编译时和运行时都以相同的方式工作。这反过来又能防止多种错误的发生，或者至少在编译时更早地报告错误使其更容易诊断和修复。</p>
<p>源文件中的模块声明文件和模块中的其他源文件，将会一起编译为.class文件供Java虚拟机使用，这是建立确定性的自然方式。这种方法将立即为开发人员所熟悉，并且IDE和构建工具也会很容易支持。尤其是IDE，可以依照依赖需要为现有组件提供模块声明的提示。</p>
<h4 id="模块打包"><a href="#模块打包" class="headerlink" title="模块打包"></a>模块打包</h4><p>现有工具已经可以创建，操作和使用JAR文件，因此为了便于使用和迁移，我们定义了模块化JAR文件。除了根目录中还包含了一个module-info.class文件之外，模块化的JAR文件就像普通的JAR文件一样。上述com.foo.bar模块的模块化JAR文件可能具有以下内容：</p>
<pre><code>META-INF/
META-INF/MANIFEST.MF
module-info.class
com/foo/bar/alpha/AlphaFactory.class
com/foo/bar/alpha/Alpha.class
...
</code></pre><p>模块化的JAR文件可以被当作模块，在这种情况下，它的module-info.class文件被用来作为模块的声明。它也可以被放在普通的类路径上，在这种情况下，它的module-info.class文件将被忽略。模块化JAR文件允许库的维护者在所有版本上发布工件（artifacts），该工件既可作为Java SE 9及更高版本的模块，也可作为类路径上的常规JAR文件。我们期望包含jar工具的Java SE 9的实现将增强该工具，以便轻松创建模块化JAR文件。</p>
<p>为了模块化Java SE平台的JDK，我们将引入一种新的打包机制（artifact format），它将超越JAR文件来容纳原生代码、配置文件和其他类型的数据（如果这种数据真的存在）。这种机制利用了在源文件中的模块声明并将它们编译成.class文件，此.class文件与其他的打包方式都不同。这种被临时命名为“JMOD”的新格式是否应该成为标准化仍旧是一个悬而未决的问题。（已成为Java9的标准格式之一，请查看<a href="https://docs.oracle.com/javase/9/tools/jmod.htm" target="_blank" rel="noopener">oracle官方文档</a>）</p>
<h4 id="模块描述符"><a href="#模块描述符" class="headerlink" title="模块描述符"></a>模块描述符</h4><p>将模块声明编译到.class文件中的最后一个优点是.class文件已经具有精确定义和可扩展的格式。因此，我们可以将module-info.class文件视为更通用的模块描述符，其中包括源代码级模块声明的编译形式，还包括在声明最初编译之后插入的.class文件中的附加信息。</p>
<p>例如，IDE、或者记录打包时间的工具，可以插入包含文档信息的属性，例如模块的版本、标题、说明和许可证。这些信息可以在编译时和运行时通过模块系统的反射来读取，以用于写文档，程序诊断和调试。它也可以被下游工具用于构建跨操作系统的程序包。特定的属性将被标准化，但由于Java类文件格式是可扩展的，所以其他工具和框架将能够根据需要来定义附加属性。非标准的属性不会影响模块系统本身的行为。</p>
<h3 id="平台模块"><a href="#平台模块" class="headerlink" title="平台模块"></a>平台模块</h3><p>Java SE 9的平台规范，使用模块系统将平台划分为一组模块。Java SE 9平台的实现可能包含所有的平台模块，或者可能仅包含其中的一部分。</p>
<p>在任何情况下，模块系统专用的唯一模块是已命名的基础模块java.base。基本模块定义并导出所有平台的核心软件包，包括模块系统本身：</p>
<pre><code class="java">module java.base {
    exports java.io;
    exports java.lang;
    exports java.lang.annotation;
    exports java.lang.invoke;
    exports java.lang.module;
    exports java.lang.ref;
    exports java.lang.reflect;
    exports java.math;
    exports java.net;
    ...
}
</code></pre>
<p>基本模块始终存在。每个其他模块都隐式的建立在基本模块之上，而基本模块则不依赖于其他模块。</p>
<p>其余的平台模块将共享“ java.”名称前缀，并有可能包括，例如，模块java.sql用于数据库连接， 模块java.xml用于XML处理，模块java.logging进行记录日志。按照惯例，尽管没有在Java SE 9平台规范中定义，但是专用于JDK的模块将共享“ jdk.”名称前缀。</p>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>单个模块可以在模块工件（artifacts）中定义，或者内嵌于编译时或运行时环境。要在任一阶段使用它们，模块系统必须定位它们，然后确定它们如何相互关联的，并以此提供可靠的配置和强大的封装。</p>
<h4 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h4><p>为了定位包中定义的模块，模块系统搜索由系统定义的模块路径（module path）。模块路径是一个序列，其中的每个元素都是模块工件或包含模块工件的目录。系统会按顺序搜索模块路径的元素，以找到定义合适的第一个模块工件。</p>
<p>模块路径（module path）与类路径（class path）有着很大的不同，它更加健壮。类路径的固有脆弱性是基于这样一个事实：即它是一种在所有包中通过路径来定位各个类型的工作方式，它不会在不同的包文件本身之间进行区分。这使得它无法预先知道程序什么时候缺少了某个包。它还允许不同的程序包（artifacts）在相同的包（package）中定义类型，即使这些程序包是只是版本不同，或者就是完全不同的组件（jar hell）。</p>
<p>相反，模块路径是定位整个模块、而不是某个类型的一种手段。如果模块系统无法满足来自模块路径的模块工件的特定依赖性，或者如果在同一目录中遇到定义相同名称模块的两个模块工件，则编译器或虚拟机将报告错误并退出。</p>
<p>内置于编译时或运行时环境的模块以及模块路径中的模块工件定义的模块统称为可观察模块的范围。</p>
<h4 id="解决依赖"><a href="#解决依赖" class="headerlink" title="解决依赖"></a>解决依赖</h4><p>假设我们有一个使用上述com.foo.bar模块和平台java.sql模块的应用程序。包含应用程序核心的模块声明如下：</p>
<pre><code class="java">module com.foo.app {
    requires com.foo.bar;
    requires java.sql;
}
</code></pre>
<p>鉴于这种初始应用程序模块，该模块系统可通过表达依赖性的requires来定位额外观察到的模块，以满足这些依赖关系，然后解决这些模块的依赖关系，并依此类推，直到每个模块的每一个的依赖都被满足。这个传递闭包计算的结果是一个模块图，对于每个依赖其他模块的模块，它包含从第一个模块到第二个模块的有向边。</p>
<p>要为模块com.foo.app构建模块图，模块系统将检查模块的声明java.sql，即：</p>
<pre><code class="java">module java.sql {
    requires java.logging;
    requires java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
</code></pre>
<p>它还会循环检查其声明的com.foo.bar模块（上面的模块定义中已经示出），包括org.baz.qux模块，java.logging模块和 java.xml模块; 为简洁起见，最后三个这里没有显示，因为它们没有声明对任何其他模块的依赖。</p>
<p>根据所有这些模块声明，为com.foo.app模块画出的模块图，包含以下节点和边：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-1.png" alt="module-pic-1"></p>
<p>在该图中，深蓝色线条表示显式依赖关系，如requires，而浅蓝色线条表示每个模块对基本模块的隐式依赖关系。</p>
<h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p>当一个模块直接依赖于模块图中的另一个模块时，则第一个模块中的代码将能够引用第二个模块中的类型。因此，我们说第一个模块读取第二个模块，或者等同地，第二个模块可以被第一个模块读取。因此，在上述的曲线图中，com.foo.app模块读取com.foo.bar和 java.sql模块，但并不读取org.baz.qux模块，java.xml模块或 java.logging模块。java.logging模块可由java.sql模块读取，但不能被其他模块读取。（根据定义，每个模块都会自行读取自己本身。）</p>
<p>在模块图中定义的可读性关系是可靠配置的基础 ：模块系统能确保每个依赖是由另一个模块完成的，模块图是非循环的，每个模块最多只能读取一个包含制定包的模块，这样定义相同名称包的模块就不会相互干扰。</p>
<p>这样的配置不仅更可靠，也可以更快。当模块中的代码引用包中的某个类型时，那么该包将保证在该模块中定义，或者只在该模块读取的模块中定义一个。因此，在寻找特定类型的定义时，不需要在多个模块中搜索它，或者更糟糕的，沿着整个路径搜索它。</p>
<h4 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h4><p>在模块图中定义的可读性关系与exports模块声明中的子句相结合，是强封装的基础：只有当某个模块被另一个模块读取时，Java编译器和虚拟机才会将这个模块中的包中的公共类型视为只能被另一个模块所访问，同时还需要这个模块导出该包。即，如果两种类型的S和T在不同的模块中定义的，并且T是 public，则如果代码S 可以存取 T，必须满足以下条件：</p>
<ol>
<li>S的模块读取T的模块，</li>
<li>T的模块导出T包。</li>
</ol>
<p>跨越模块边界的类型引用以及私有的方法和字段在这种情况下都是不可用的：任何尝试使用它的操作都将导致编译器报告错误，或者由Java虚拟机报出的IllegalAccessError，或者由反射运行时API引发的IllegalAccessException。因此，即使声明了一个类型public，如果它的包没有在其模块的声明中导出，那么它将只能被该模块中的代码访问。</p>
<p>如果模块中的封闭类型是可访问的，并且其成员本身也被声明成允许访问，那么跨模块也可以访问并引用到其方法或字段。</p>
<p>要了解上述模块图的封装是如何工作的，我们标记出每个模块导出的包：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-2.png" alt="module-pic-2"></p>
<p>模块com.foo.app中的代码可以访问com.foo.bar.alpha包中声明的公共类型， 因为模块com.foo.app依赖于模块com.foo.bar，并且因为模块com.foo.bar导出com.foo.bar.alpha包。如果com.foo.bar包含内部程序包（internal package），即com.foo.bar.internal包，则模块com.foo.app不能访问该com.foo.bar.internal包中的任何类型，因为com.foo.bar并没有导出这个内部包。模块com.foo.app中的代码也不能引用org.baz.qux包中的类型，因为模块com.foo.app不依赖于模块org.baz.qux，因此不会读取它（在这个例子中，模块的依赖并不能传递）。</p>
<h4 id="隐含的可读性"><a href="#隐含的可读性" class="headerlink" title="隐含的可读性"></a>隐含的可读性</h4><p>如果一个模块读取另一个模块，则在某些情况下，它也能符合逻辑地读取其他一些模块。</p>
<p>例如，平台的java.sql模块依赖于java.logging模块和java.xml模块，不仅因为它包含了这些模块中的类型的代码实现，还因为它直接声明使用了这些模块中的类型。java.sql.Driver接口声明了一个公共的方法：</p>
<pre><code class="java">public Logger getParentLogger();
</code></pre>
<p>其中Logger是在java.logging模块所导出的包java.util.logging中声明的类型。</p>
<p>假设，例如，com.foo.app模块中的代码调用此方法来获取日志，然后记录一条消息：</p>
<pre><code class="java">String url = ...;
Properties props = ...;
Driver d = DriverManager.getDriver(url);
Connection c = d.connect(url, props);
d.getParentLogger().info(&quot;Connection acquired&quot;);
</code></pre>
<p>如果com.foo.app模块像为如上所述声明，那么这样的代码将不起作用：该getParentLogger方法返回另一个模块java.logging中所声明的Logger类型，而模块com.foo.app并没有读取模块java.logging ，因此调用java.logging模块中Logger类的info方法将会失败，因为该类以及该方法无法访问。</p>
<p>解决这个问题的一个方法寄希望于每一位开发者在依赖java.sql模块并使用getParentLogger方法Logger类的同时，还必须记得声明对java.logging模块的依赖。当然，这样的方式是不可靠的，因为它违反了最小意外原则（principle of least surprise）：如果一个模块依赖于第二个模块，那么很自然的我们会期望去使用第一个模块中的所有属性，包括在第二的模块中声明的属性，也会在我们依赖第一个模块是变得立即可见（即模块依赖的传递性）。</p>
<p>因此，我们扩展了模块声明，以便一个模块可以将附加模块的可读性授予依赖它的任何模块。这种隐含的可读性通过requires public子句来表达（在正式版的jdk中已经被更新为requires transitive）。java.sql模块的声明实际上是这样的：</p>
<pre><code class="java">module java.sql {
    requires public java.logging;
    requires public java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
</code></pre>
<p>该public关键字是指，任何依赖于模块java.sql的模块，不仅仅会读取java.sql模块，也会读取java.logging模块和java.xml模块。因此，上述com.foo.app模块的模块图，包含两个额外的深蓝色边缘，通过绿色边缘链接到java.sql模块，因为java.logging模块和java.xml模块被该模块隐性的依赖：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-moudle-3.png" alt="module-pic-3"></p>
<p>com.foo.app模块现在可以包含访问java.logging模块和java.xml模块的导出包中的所有公共类型的代码，即使其声明中没有提及这些模块。</p>
<p>一般而言，如果一个模块的导出包引用了了另一个模块中的包的类型，则第一个模块应该使用requires public子句来声明对第二个模块的依赖。这将确保依赖于第一个模块的其他模块将自动读取第二个模块，从而访问该模块的导出包中的所有类型。</p>
<h3 id="兼容性和迁移"><a href="#兼容性和迁移" class="headerlink" title="兼容性和迁移"></a>兼容性和迁移</h3><p>到目前为止，我们已经看到如何从头开始定义模块，将它们打包到模块工件中，并将它们与其他模块一起使用，这些模块既可以嵌入到平台中，也可以直接在包中定义。</p>
<p>当然，大多数Java代码是在引入模块系统之前编写的，并且必须继续像现在一样继续工作，而不用更改（向下兼容）。因此，即使平台本身由模块组成，模块系统也应该可以在类路径上编译和运行由JAR文件组成的应用程序。它还允许将现有应用程序以灵活和渐进的方式迁移到模块化形式。</p>
<h4 id="未命名模块"><a href="#未命名模块" class="headerlink" title="未命名模块"></a>未命名模块</h4><p>如果我们的需求时在加载一个其所在的包未再任何已知的模块中声明的类型，则模块系统将尝试从类路径加载它。如果成功，那么该类型会被认为成为一个，被称为未命名模块的特殊模块中的成员，以确保每个类型都与某个模块相关联。未命名模块在高层次上类似于现有概念中的未命名包。当然，所有其他模块都有名称，所以我们今后将把它们称为命名模块。</p>
<p>未命名模块读取所有的其他模块。因此，从类路径加载的任何类型的代码，都将能够访问所有其他可读模块的导出类型，默认情况下，该模块将包含所有内置的已命名平台模块。因此，编译并在Java SE 8上运行的现有类路径应用程序将在Java SE 9上以完全相同的方式进行编译和运行，只要它使用的是标准的，未弃用的Java SE API即可。</p>
<p>未命名的模块默认导出其所有软件包。这可以实现灵活的迁移。但是，它并不意味着命名模块中的代码可以访问未命名模块中的类型。实际上，命名模块甚至不能声明对未命名模块的依赖。这种限制是故意的，因为如果允许命名模块依赖于类路径的任意内容，就不可能实现可靠的配置。</p>
<p>如果在命名模块和未命名模块中都定义了同样名字的包，那么未命名模块中的包将被忽略。即使类路径十分混乱，这种可靠的配置，仍能确保每个模块最多只能读取一个模块来提供你所需要的包。如果在上面的示例中，类路径上的JAR文件，包含一个名为，com/foo/bar/alpha/AlphaFactory.class的.class文件，那么该文件将永远不会被加载，因为包com.foo.bar.alpha 是由模块com.foo.bar导出的。</p>
<h4 id="自下而上的迁移"><a href="#自下而上的迁移" class="headerlink" title="自下而上的迁移"></a>自下而上的迁移</h4><p>从类路径加载的类型作为未命名模块中的成员，这种处理将允许我们自下而上的，将现有的应用程序从JAR文件形式迁移到模块化的形式。</p>
<p>例如，上面显示的应用程序最初是为Java SE 8构建的，因为它是放置在类路径上的一组JAR文件。如果我们在Java SE 9上按原样运行它，那么JAR文件中的类型将在未命名的模块中定义。该模块将读取所有其他模块，包括所有内置平台模块; 为简单起见，假设那些被读取的模块被限制为java.sql模块，java.xml模块， java.logging模块和java.base模块。因此我们获得如下的模块图：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-4.png" alt="module-pic-4"></p>
<p>我们可以立即将org-baz-qux.jar转换为命名模块，因为我们知道它不会引用其他两个JAR文件中的任何类型，因此作为命名模块，它也不会引用未命名模块中的任何类型。（这是因为我们刚刚从最初的例子中知道了这一点。如果我们不知道它时候引用未命名模块的话，我们可以借助诸如类似jdeps的工具来发现它。）</p>
<p>我们编写一个模块声明为org.baz.qux，将其添加到模块的源代码中，编译并将结果打包为模块化JAR包。如果我们将该JAR文件放在模块路径上，并将其他类放在类路径上，我们将获得改进的模块图：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-5.png" alt="module-pic-5"></p>
<p>com-foo-bar.jar和com-foo-app.jar中的代码会继续工作，因为未命名的模块会读取每个已命名的模块，这个未命名模块现在包含新模块org.baz.qux。</p>
<p>我们可以类似地进行模块化com-foo-bar.jar，然后接着模块化com-foo-app.jar最终结束预期的模块图，如前所示：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-6.png" alt="module-pic-6"></p>
<p>如果我们了解原始JAR文件中的类型所做的工作，我们当然可以在一个步骤中将它们全部三个模块化。然而，如果 org-baz-qux.jar是独立维护的，或许由完全不同的团队或组织来维护，那么它可以在其他两个组件之前模块化，并且在com-foo-app.jar模块化之前也可以模块化com-foo-bar.jar。</p>
<h4 id="自动模块"><a href="#自动模块" class="headerlink" title="自动模块"></a>自动模块</h4><p>自下而上的迁移很简单，但并非总是可行的。即使org-baz-qux.jar的维护者尚未将其转换为适当的模块，或者可能永远不会，我们仍然可能想要将模块化com-foo-app.jar和com-foo-bar.jar。</p>
<p>我们已经知道代码是com-foo-bar.jar依赖org-baz-qux.jar。但是，如果我们转换com-foo-bar.jar为命名模块com.foo.bar，但留org-baz-qux.jar在类路径中，那么该代码将不再起作用：org-baz-qux.jar将继续在未命名模块中定义，但com.foo.bar是一个命名模块，它不能声明依赖于未命名模块。</p>
<p>那么，我们必须以某种方式安排org-baz-qux.jar作为一个命名模块出现，以便com.foo.bar可以依赖它。我们可以fork org.baz.qux的源代码并将其模块化，但是如果维护人员不愿意将该更改合并到上游存储库中，那么只要我们需要它，我们就必须维护这个分支。</p>
<p>因此，我们将把org-baz-qux.jar作为一个自动模块，不加修改地放在模块路径上，而不是类路径上。这将定义一个可观察模块，其模块名称，org.baz.qux来源于JAR文件的名称，以便其他非自动模块可以通常的方式依赖它：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-7.png" alt="module-pic-7"></p>
<p>自动模块是一个隐式定义的命名模块，因为它没有模块声明。相比之下，普通的命名模块是通过模块声明明确定义的; 我们今后将把它们称为显式模块。</p>
<p>没有方法可以预先告诉自动模块可能依赖哪些其他模块。因此，在模块图解析完成后，自动模块将读取每个其他命名模块，无论是自动模块还是显式模块：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-8.png" alt="module-pic-8"></p>
<p>（这些新的可读性边在模块图中创建了循环，这使得推理起来有些困难，但我们认为这些是可以容忍的，而且通常是为了实现更灵活迁移所导致的临时结果。）</p>
<p>类似地，没有方法可以告诉自动模块中的哪些包打算供其他模块使用，或者仍旧是通过类路径上的类继续使用。因此，即使自动模块中的每个软件包只用于内部使用，也会被视为导出：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-9.png" alt="module-pic-9"></p>
<p>现在com.foo.app中的代码可以访问org.baz.qux中的类型，尽管我们知道它实际上并没有这样做。</p>
<p>自动模块提供了混乱的类路径和显式模块规则之间的中间地带。它们允许将由JAR文件组成的现有应用程序从上到下迁移到模块，如上所示，或者以自上而下和自下而上的方法组合来迁移。通常，我们可以从类路径上的任意一组JAR文件开始，使用一个工具jdeps来分析它们之间的依赖关系，将我们控制的源代码组件转换为显式模块，然后将剩余的JAR文件按原样放在模块路径中。我们不控制源代码的JAR文件将被视为自动模块，直到它们也转换为显式模块为止。</p>
<h4 id="与类路径建立联系"><a href="#与类路径建立联系" class="headerlink" title="与类路径建立联系"></a>与类路径建立联系</h4><p>许多现有的JAR文件可以用作自动模块，但有些不能。如果类路径上的两个或多个JAR文件包含同一个包中的类型，那么最多可以有其中的一个来用作自动模块，因为模块系统仍然保证每个命名模块至多读取一个包含了需要的包的命名模块，以保证定义了相同名称包的命名模块不会相互干扰。在这种情况下，我们经常会发现实际上，我们只需要其中一个JAR文件。如果其他的JAR文件重复或接近重复，并以某种方式错误地放在类路径上，则可以将其中一个用作自动模块，其他的JAR文件就会被舍弃。但是，如果类路径上的多个JAR文件有意包含在同一个包中的类型，那么它们必须都保留在类路径中（即作为一个在类路径上的未命名模块而非在模块路径上的自动模块）。</p>
<p>因为这些JAR文件不能用作自动模块，为了启用迁移，我们会将自动模块，视为建立在显式模块和仍然处于类路径上的代码（未命名模块）之间的桥梁：自动模块除了读取其他所有命名模块之外，还将读取未命名的模块。如果我们的应用程序的原始类路径中，包含了JAR文件org-baz-fiz.jar和org-baz-fuz.jar，那么我们将有图：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-10.png" alt="module-pic-10"></p>
<p>如前所述，未命名模块导出其所有软件包，因此自动模块中的代码将能够访问所有从类路径加载的公用类型（即未命名模块中的所用公共类型）。</p>
<p>使用类路径中的类型的自动模块，不能将这些类型暴露给其他依赖于它的显式模块，因为显式模块无法声明对未命名模块的依赖关系。如果显式模块com.foo.app中的代码引用了一个自动模块com.foo.bar中的公共类型，并且自动模块com.foo.bar明确声明使用了仍在类路径上的一个JAR文件中的类型，则com.foo.app中的代码将无法访问该类路径上的类型，因为命名模块com.foo.bar不能依赖于未命名的模块。这可以通过将模块com.foo.app暂时视为自动模块来解决，以便其代码可以访问类路径中的类型，直到类路径上的相关JAR文件（未命名模块）可以被视为自动模块或转换为显式模块为止。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>利用服务接口和服务提供者的松散耦合是构建大型软件系统的强大工具。Java通过<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_blank" rel="noopener">java.util.ServiceLoader</a>类来支持服务，该类在运行时通过搜索类路径来定位服务提供者。对于在模块中定义的服务提供者，我们必须考虑如何在一组可观察模块中找到这些模块，解决它们的依赖性，并使提供者可以使用使用相应服务的代码。</p>
<p>假设，例如，我们的com.foo.app模块使用MySQL数据库，并且在具有声明的可观察模块中提供MySQL JDBC驱动程序</p>
<pre><code class="java">module com.mysql.jdbc {
    requires java.sql;
    requires org.slf4j;
    exports com.mysql.jdbc;
}
</code></pre>
<p>其中org.slf4j是驱动程序（jdbc driver）使用的日志记录库，并且com.mysql.jdbc是包含java.sql.Driver这一服务接口的具体实现的包。（实际上并不需要导出驱动程序包，我们这样做是为了使代码清晰可见。）</p>
<p>为了让java.sql模块使用这个驱动程序， ServiceLoader类必须能够通过反射来实例化驱动程序类; 为了实现这一点，模块系统必须将驱动模块添加到模块图中并解决其依赖性，因此：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-11.png" alt="module-pic-11"></p>
<p>为了实现这一点，模块系统必须能够识别所有使用服务的模块，然后从一组可观察模块中找到服务的提供者。</p>
<p>模块系统可以通过，扫描模包中的类文件并调用ServiceLoader::load方法，来识别对服务的使用，但是这样做不仅会很慢，而且并不可靠。模块使用特定服务应该是是模块的一个基本定义，所以为了效率和清晰度，我们在模块的声明中用一个uses子句来表示对服务的使用：</p>
<pre><code class="java">module java.sql {
    requires public java.logging;
    requires public java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
    uses java.sql.Driver;
}
</code></pre>
<p>模块系统可以通过扫描META-INF/services资源条目来识别服务提供者，就像现在ServiceLoader类所做的那样。但是，模块提供特定服务借口的具体实现同样很重要，所以我们在模块的声明中用一个provides子句表示模块的提供者：</p>
<pre><code class="java">module com.mysql.jdbc {
    requires java.sql;
    requires org.slf4j;
    exports com.mysql.jdbc;
    provides java.sql.Driver with com.mysql.jdbc.Driver;
}
</code></pre>
<p>现在，只要阅读这些模块的声明，就很容易看出来，其中一个m模块使用另一个提供的服务。</p>
<p>在模块声明中声明服务提供者和服务使用者的关系具有提高效率和代码清晰度的优势。这两种服务声明都可以在编译时进行解释，以确保服务提供者和服务使用者都可以访问服务接口（例如，java.sql.Driver）。服务提供者声明可以进一步解释，以确保提供者（例如，com.mysql.jdbc.Driver）确定实现其宣称的服务接口。服务使用的声明可以通过工具来提前编译，以确保在运行之前服务提供者能恰当的被编译。</p>
<p>出于迁移目的，如果定义自动模块的JAR文件包含META-INF/services资源条目，则将每个这样的条目视为该模块中的provides关键字的对应子句。自动模块被认为可以使用每一种可用的服务。</p>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p>本文档的其余部分讨论了高级特性，这些特性虽然很重要，但大多数开发人员可能并不感兴趣。</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>为了使模块图在运行时反射也可用，我们在java.lang.reflect包中定义了一个叫Module类，并在一个新的包java.lang.module中定义一些相关类型。Module类的一个实例在运行时代表一个单独的模块。每个类型都在一个模块中，因此每个Class对象都有一个关联的Module对象，该对象由新Class::getModule方法返回。</p>
<p>Module对象的基本操作是：</p>
<pre><code class="java">package java.lang.reflect;

public final class Module {
    public String getName();
    public ModuleDescriptor getDescriptor();
    public ClassLoader getClassLoader();
    public boolean canRead(Module target);
    public boolean isExported(String packageName);
}
</code></pre>
<p>其中ModuleDescriptor是java.lang.module包中的类，它的实例表示模块描述符; getClassLoader方法返回模块的类加载器; canRead方法告诉模块是否可以读取目标模块; isExported方法告诉模块是否导出给定的包。</p>
<p>java.lang.reflect包并不是平台上唯一的反射工具。相似的工具也被添加到javax.lang.model模块，为了支持编译时的注释处理和文档生成工具。</p>
<h4 id="反射的可读性"><a href="#反射的可读性" class="headerlink" title="反射的可读性"></a>反射的可读性</h4><p>框架是使用反射来加载，检查，并在运行时实例化的其他类的工具。Java SE平台本身的框架示例是服务加载器，资源包，动态代理和序列化，当然还有许多流行的外部框架库，用于数据库持久性，依赖注入和测试等多种用途。</p>
<p>鉴于需要在运行时发现类，框架必须能够访问其构造函数之一以实例化它。但事实表明，情况通常不会如此。</p>
<p>Java平台的<a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/package-summary.html" target="_blank" rel="noopener">XML解析器</a>，如果<a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/XMLInputFactory.html#newFactory--" target="_blank" rel="noopener">加载和实例化</a>由系统配置命名为javax.xml.stream.XMLInputFactory的<a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/XMLInputFactory.html" target="_blank" rel="noopener">XMLInputFactory</a>的服务实现，它就将通过ServiceLoader类，优先于所有服务提供者发现被发现。忽略异常处理和安全检查的代码大致如下所示：</p>
<pre><code class="java">String providerName
    = System.getProperty(&quot;javax.xml.stream.XMLInputFactory&quot;);
if (providerName != null) {
    Class providerClass = Class.forName(providerName, false,
                                        Thread.getContextClassLoader());
    Object ob = providerClass.newInstance();
    return (XMLInputFactory)ob;
}
// Otherwise use ServiceLoader
...
</code></pre>
<p>在模块化设置中，只要包含的服务提供者的类为上下文类加载器所知，Class::forName就仍将继续工作。但是，通过反射的方式调用服务提供者的newInstance方法将不起作用：服务提供者可能会从类路径加载，在这种情况下，它将位于未命名的模块中，或者它可能位于某个已命名的模块中，无论是哪种情况，我们的框架本身都在java.xml模块中。该模块仅依赖于基本模块，因此也只读取基本模块，此框架将无法访问任何其他模块中的服务提供者类。</p>
<p>为了使框架可以访问服务提供者类，我们需要使框架的模块可以读取服务提供者的模块。我们可以要求每个框架在运行时都明确地，将必要的可读性边缘添加到模块图中，就像本文档的早期版本一样，但是经验表明这种方法很麻烦并且会导致迁移的障碍。</p>
<p>因此，我们需要修改反射API，我们假设任何反射其他类型的代码，都位于一个可以访问到被反射类型所在模块的模块中。这使得上面的例子和其他类似的代码可以毫无改变地工作。这种方法不会削弱强封装：公开类型仍然必须位于导出的包中，以便从其所在模块外部进行访问，无论是通过编译代码还是通过反射。</p>
<blockquote>
<p>事实上，在这种需要发射其他模块的情况下，如果我们只想要反射共有类型，那只要在模块中导出相应的包就可以；但如果我们想要通过setAccessible(true)方法来反射私有类型是，必须在模块声明时添加open关键字或者opens子句，来使模块成为一个开放模块或者开放模块中的软件包，使反射对私有类型可见，否则就会在运行报出Accessing Error。这一点原作者并未提及，我个人认为这种设计很好的保证了模块的强封装的特性</p>
</blockquote>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>每个类型都在一个模块中，并且在运行时每个模块都有一个类加载器，但是类加载器是否只加载一个模块呢？事实上，模块系统对模块和类加载器之间的关系几乎没有限制。一个类加载器可以从一个模块或多个模块加载类型，只要这些模块不相互干扰，并且只有一个加载器加载了特定模块中的所有类型。</p>
<p>这种灵活性对于兼容性至关重要，因为它允许我们保留平台现有的内置类加载器的层次结构。引导类加载器（bootstrap classloader）和扩展类加载器（extension classloader）仍然存在，并用于从平台模块加载类型。应用程序类加载器（application classloader）仍然存在，用于从工件的模块路径中找到加载类型。</p>
<p>这种灵活性还会使模块化现有应用程序变得更加容易，这些应用程序已经构建了复杂的层次结构甚至自定义类加载器，因次我们可以将这些加载器升级到模块中的加载类型，而无需更改其委托模式。</p>
<blockquote>
<p>事实上，Java9的classloader是有改变的，这一部分我以后会单独写一篇文章来总结。如现在想了解请参考<a href="http://www.cnblogs.com/IcanFixIt/p/7131676.html" target="_blank" rel="noopener">此链接</a>中的扩展机制部分</p>
</blockquote>
<h4 id="未命名模块与类加载器"><a href="#未命名模块与类加载器" class="headerlink" title="未命名模块与类加载器"></a>未命名模块与类加载器</h4><p>我们之前了解到，如果某个类型未在命名模块中定义，那么它将被视为未命名模块的成员，但与未命名模块相关的是哪个类加载器呢？</p>
<p>事实证明，每个类加载器都有自己独特的未命名模块，它是由新ClassLoader::getUnnamedModule方法返回的。如果一个类加载器加载了一个没有在命名模块中定义的类型，那么该类型就被认为是在该加载器的未命名模块中。例如，Class类中的getModule方法将返回其加载器的未命名模块。应用加载器（application classloader）的未命名模块，会从类路径中加载不在任何模块下定义的包中的类型。</p>
<h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>模块系统并不指定模块和类加载器之间的关系，但为了加载特定的类型，它必须以某种方式能够找到合适的加载器。因此，在运行时，模块图的实例化会生成一个层（layer），这个层将图中的每个模块映射到负责加载该模块中的类型的唯一类加载器上。与可被发现的模块相反，引导层（boot layer）是由Java虚拟机在启动时通过解析应用程序的初始模块所创建的。</p>
<p>大多数应用程序以及几乎当前所有的应用程序都不会使用引导层以外的层。然而，多个层可用于带有插件的复杂应用程序或容器体系结构（如应用程序服务器，IDE和测试框架）。这样的应用程序可以使用动态的类加载和模块系统的反射API，来加载和运行由一个或多个模块组成的应用程序。然而，这通常需要添加两种额外的灵活性：</p>
<ol>
<li><p>使用模块的应用程序可能需要不同版本的已存在的模块。例如，Java EE Web应用程序可能需要java.xml.ws模块中的不同版本的JAX-WS，而不是内置于运行时环境的版本。</p>
</li>
<li><p>使用模块的应用程序可能需要已经被发现的服务提供者以外的服务提供者。应用程序甚至可能嵌入自己的首选服务提供者。Web应用程序，可能包含一个它所期望的<a href="https://github.com/FasterXML/woodstox" target="_blank" rel="noopener">Woodstox XML解析器</a>版本，在这种情况下，ServiceLoader类应优先返回它需要的服务提供者而不是任何其他的服务提供者。</p>
</li>
</ol>
<p>与可被发现的模块的环境相反，一个容器应用程序可以为一个使用模块的应用程序的初始模块，在其已有的层上创建一个新的层。这样的环境可以包含可升级平台模块的替代版本以及其他已存在于较低层的非平台模块，解析器优先解析这些备用模块。这种环境也可以在那些已经在较低层被发现的服务提供者之外发现不同的服务提供者; ServiceLoader类将在较低层返回服务提供者之前去加载这些服务提供者。</p>
<p>层可以堆叠：我们可以在引导层之上构建新层，然后再在其上创建另一个层。作为正常解析过程的结果，所指定的层中的模块可以读取该层中或下层中的模块。因此，层的模块图可以通过引用包括其下的每个层的模块图来表示。</p>
<blockquote>
<p>上面这一节翻译的不太好，事实上我也不太理解这一节的内容。以后会仔细研究一下，目前只知道现在JDK中已经有了ModuleLayer类，可以通过Module.getLayer()获得。</p>
</blockquote>
<h4 id="限制性导出"><a href="#限制性导出" class="headerlink" title="限制性导出"></a>限制性导出</h4><p>偶尔有必要安排某些类型在一组模块中可访问，但其他模块无法访问。</p>
<p>在标准JDK的java.sql模块和 java.xml模块的代码实现中，使用了java.base模块中的sun.reflect包下定义的类型 。为了让代码访问sun.reflect包中的类型，我们可以简单地从java.base模块中导出该包：</p>
<pre><code class="java">module java.base {
    ...
    exports sun.reflect;
}
</code></pre>
<p>然而，这将使得每个sun.reflect包中的类型对所有模块都可见（因为每个模块都读取java.base），而这是不合理的，因为该包中的一些类定义了有特权的，安全敏感的方法。</p>
<p>因此，我们扩展了模块声明以允许将包导出到一个或多个特定命名的模块，而不被其他模块可见。java.base模块的声明实际上只将sun.reflect包导出到特定的一组JDK模块：</p>
<pre><code class="java">module java.base {
    ...
    exports sun.reflect to
        java.corba,
        java.logging,
        java.sql,
        java.sql.rowset,
        jdk.scripting.nashorn;
}
</code></pre>
<p>通过在模块图中添加另一种类型的边缘（此处为彩色金色），可以将这些限制性的导出显示在模块图中：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-12.png" alt="module-pic-12"></p>
<p>前面提到的可访问性规则如下所述：如果两种类型S并且T在不同模块中定义，并且T是public，则代码S可以在以下情况下访问T：</p>
<ol>
<li>S的模块读取T的模块，和</li>
<li>T的模块直接导出T的包到S的模块，亦或是导出到所有模块。</li>
</ol>
<p>我们为用于反射的Module类提供了一种方法，来确定是否将包导出到特定模块，而非所有模块：</p>
<pre><code class="java">public final class Module {
    ...
    public boolean isExported(String packageName, Module target);
}
</code></pre>
<p>限制性的导出可能会意外地将内部的类型到处到预期之外的模块，因此我们必须小心使用它们。例如命名一个名为java.corba的模块以访问sun.reflect包中的类型。为了防止这种情况，我们可以在构建时分析相关模块，并在每个模块的描述符中记录允许依赖它的模块内容的哈希值，并使用限制性导出。在分析期间，我们需要验证，那些使用限制性导出到其他命名模块的模块，其模块内容的哈希值，与引用该模块的模块中记录的该模块的哈希值匹配。只要声明和使用限制性的导出的模块以这种方式绑定在一起，限制性的导出就可以安全地在不受信任的环境中使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里描述了模块系统的很多方面，但大多数开发人员只需要使用其中的一部分。我们期望在未来几年内，大多数Java开发人员都会熟悉模块声明，模块化JAR文件，模块路径，可读性，可访问性，未命名模块，自动模块和模块化服务等基本概念。相比之下，反射可读性，层和限制性的导出等更高级功能可能被使用的可能性比较小。</p>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Project Jigsaw:Java模块系统快速入门指南]]></title>
      <url>/2018/03/29/java9-quick-guide/</url>
      <content type="html"><![CDATA[<p><strong>本文为openjdk官方java模块入门指南的翻译。(<a href="http://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener">原文地址</a>)</strong></p>
<p>本文档提供了一些让开发者快速上手Java模块系统的简单例子。<br>例子中的文件路径用/划分，文件分隔符是：，windows开发者请用\和；替换以上分隔符。</p>
<h3 id="Greetings"><a href="#Greetings" class="headerlink" title="Greetings"></a>Greetings</h3><p>第一个例子展示了一个打印”Greetings!”字符串的简单模块。这个模块由两个源文件组成（module-info.java和Main.java）。按照惯例，模块的源文件应该在一个以模块名字为命名的目录中。</p>
<pre><code class="java">src/com.greetings/com/greetings/Main.java
src/com.greetings/module-info.java

$ cat src/com.greetings/module-info.java
module com.greetings { }

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;
public class Main {
    public static void main(String[] args) {
        System.out.println(&quot;Greetings!&quot;);
    }
}
</code></pre>
<p>以下命令会将源文件编译到mods/com.greetings目录中：</p>
<pre><code class="bash">$ mkdir -p mods/com.greetings

$ javac -d mods/com.greetings \
    src/com.greetings/module-info.java \
    src/com.greetings/com/greetings/Main.java
</code></pre>
<p>现在我们用以下命令来运行这个例子：</p>
<pre><code class="bash">$ java --module-path mods -m com.greetings/com.greetings.Main
</code></pre>
<p>–module-path 是模块的路径，他的值是包含模块的一个或多个目录。<br>-m 指定了主模块，/后面的值是模块里包含main方法的全类名。</p>
<h3 id="Greetings-world"><a href="#Greetings-world" class="headerlink" title="Greetings world"></a>Greetings world</h3><p>第二个例子更新了第一个例子中的模块声明，它声明了需要一个名为org.astro的模块的依赖。<br>模块org.astro导出了名为org.astro的api包。</p>
<pre><code class="java">src/org.astro/module-info.java
src/org.astro/org/astro/World.java
src/com.greetings/com/greetings/Main.java
src/com.greetings/module-info.java

$ cat src/org.astro/module-info.java
module org.astro {
    exports org.astro;
}

$ cat src/org.astro/org/astro/World.java
package org.astro;
public class World {
    public static String name() {
        return &quot;world&quot;;
    }
}

$ cat src/com.greetings/module-info.java
module com.greetings {
    requires org.astro;
}

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;
import org.astro.World;
public class Main {
    public static void main(String[] args) {
        System.out.format(&quot;Greetings %s!%n&quot;, World.name());
    }
}
</code></pre>
<p>依次编译这两个模块，用javac命令在编译com.greetings模块时指定模块的路径，使得org.astro模块中的引用和其导出包中的类型可以被引用。</p>
<pre><code class="bash">$ mkdir -p mods/org.astro mods/com.greetings

$ javac -d mods/org.astro \
    src/org.astro/module-info.java src/org.astro/org/astro/World.java

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
</code></pre>
<p>使用与第一个例子相同的方式来运行这个例子：</p>
<pre><code class="bash">$ java --module-path mods -m com.greetings/com.greetings.Main
Greetings world!
</code></pre>
<h3 id="多模块编译"><a href="#多模块编译" class="headerlink" title="多模块编译"></a>多模块编译</h3><p>在上面的例子中，模块com.greetings和模块org.astro是分开编译的，我们也可以用一条javac命令来编译多个模块</p>
<pre><code class="bash">$ mkdir mods

$ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)

$ find mods -type f
mods/com.greetings/com/greetings/Main.class
mods/com.greetings/module-info.class
mods/org.astro/module-info.class
mods/org.astro/org/astro/World.class
</code></pre>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在目前的实例中，编译好的模块都分散在文件系统中，为了调度和部署，我们通常会把模块打包成模块化jar包，模块化jar包就是在jar包最顶层目录包含module-info.class的普通jar包。</p>
<p>以下命令将会在mlib目录中创建org.astro@1.0.jar和com.greetings.jar</p>
<pre><code class="bash">$ mkdir mlib

$ jar --create --file=mlib/org.astro@1.0.jar \
    --module-version=1.0 -C mods/org.astro .

$ jar --create --file=mlib/com.greetings.jar \
    --main-class=com.greetings.Main -C mods/com.greetings .

$ ls mlib
com.greetings.jar   org.astro@1.0.jar
</code></pre>
<p>在这个例子中，模块org.astro在打包时被指定了其版本号1.0，模块com.greetings在打包时被制定了其main方法主类com.greetings.Main。</p>
<p>现在，我们可以直接运行模块com.greetings而无需制定其main class</p>
<pre><code class="bash">$ java -p mlib -m com.greetings
Greetings world!
</code></pre>
<p>命令可以用-p来替代–module-path。</p>
<p>jar命令拥有许多新选项，其中一个就是打印模块化jar包中声明的模块。</p>
<pre><code class="bash">$ jar --describe-module --file=mlib/org.astro@1.0.jar
org.astro@1.0 jar:file:///d/mlib/org.astro@1.0.jar/!module-info.class
exports org.astro
requires java.base mandated
</code></pre>
<h3 id="缺少requires或者exports关键字"><a href="#缺少requires或者exports关键字" class="headerlink" title="缺少requires或者exports关键字"></a>缺少requires或者exports关键字</h3><p>如果我们在com.greetings模块中遗漏了requires关键字：</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    // requires org.astro;
}

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
    import org.astro.World;
                ^
    (package org.astro is declared in module org.astro, but module com.greetings does not read it)
1 error
</code></pre>
<p>如果我们在org.astro模块中遗漏了exports关键字：</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    requires org.astro;
}
$ cat src/org.astro/module-info.java
module org.astro {
    // exports org.astro;
}

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
    import org.astro.World;
                ^
    (package org.astro is declared in module org.astro, which does not export it)
1 error
</code></pre>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务允许服务提供者和服务消费者中建立松散的耦合结构。在这个例子中，存在这一个服务提供者和一个服务消费者：模块com.socket提供了API用来做network socket；模块org.fastsocket是一个服务提供模块，它提供了com.socket.spi.NetworkSocketProvider的实现，并且不导出任何包。</p>
<p>下面是模块com.socket的代码：</p>
<pre><code class="java">$ cat src/com.socket/module-info.java
module com.socket {
    exports com.socket;
    exports com.socket.spi;
    uses com.socket.spi.NetworkSocketProvider;
}

$ cat src/com.socket/com/socket/NetworkSocket.java
package com.socket;

import java.io.Closeable;
import java.util.Iterator;
import java.util.ServiceLoader;

import com.socket.spi.NetworkSocketProvider;

public abstract class NetworkSocket implements Closeable {
    protected NetworkSocket() { }

    public static NetworkSocket open() {
        ServiceLoader&lt;NetworkSocketProvider&gt; sl
            = ServiceLoader.load(NetworkSocketProvider.class);
        Iterator&lt;NetworkSocketProvider&gt; iter = sl.iterator();
        if (!iter.hasNext())
            throw new RuntimeException(&quot;No service providers found!&quot;);
        NetworkSocketProvider provider = iter.next();
        return provider.openNetworkSocket();
    }
}


$ cat src/com.socket/com/socket/spi/NetworkSocketProvider.java
package com.socket.spi;

import com.socket.NetworkSocket;

public abstract class NetworkSocketProvider {
    protected NetworkSocketProvider() { }

    public abstract NetworkSocket openNetworkSocket();
}
</code></pre>
<p>以下是模块org.fastsocket的代码</p>
<pre><code class="java">$ cat src/org.fastsocket/module-info.java
module org.fastsocket {
    requires com.socket;
    provides com.socket.spi.NetworkSocketProvider
        with org.fastsocket.FastNetworkSocketProvider;
}

$ cat src/org.fastsocket/org/fastsocket/FastNetworkSocketProvider.java
package org.fastsocket;

import com.socket.NetworkSocket;
import com.socket.spi.NetworkSocketProvider;

public class FastNetworkSocketProvider extends NetworkSocketProvider {
    public FastNetworkSocketProvider() { }

    @Override
    public NetworkSocket openNetworkSocket() {
        return new FastNetworkSocket();
    }
}

$ cat src/org.fastsocket/org/fastsocket/FastNetworkSocket.java
package org.fastsocket;

import com.socket.NetworkSocket;

class FastNetworkSocket extends NetworkSocket {
    FastNetworkSocket() { }
    public void close() { }
}
</code></pre>
<p>为了简单化，我们同时编译两个模块，但事实上，服务提供者和服务消费者几乎总是分开编译的</p>
<pre><code class="bash">$ mkdir mods
$ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)
</code></pre>
<p>最后我们对模块com.greetings用新的模块的api做更改</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    requires com.socket;
}

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;

import com.socket.NetworkSocket;

public class Main {
    public static void main(String[] args) {
        NetworkSocket s = NetworkSocket.open();
        System.out.println(s.getClass());
    }
}


$ javac -d mods/com.greetings/ -p mods $(find src/com.greetings/ -name &quot;*.java&quot;)
</code></pre>
<p>最后，我们运行com.greetings模块</p>
<pre><code class="bash">$ java -p mods -m com.greetings/com.greetings.Main
class org.fastsocket.FastNetworkSocket
</code></pre>
<p>输出结果确认服务提供者已经被定位成功。</p>
<h3 id="The-linker"><a href="#The-linker" class="headerlink" title="The linker"></a>The linker</h3><p>jlink是一个用来在一组拥有传递性依赖的模块之中，建立一个自定义的模块化可运行镜像的工具。</p>
<p>此工具目前需要制定模块路径的模块化jar包或者jmod格式。jdk会将标准的或jdk指定的模块以jmod格式打包。</p>
<p>以下命令会创建一个包含模块com.greetings和其传递性依赖的可运行镜像。</p>
<pre><code class="bash">jlink --module-path $JAVA_HOME/jmods:mlib --add-modules com.greetings --output greetingsapp
</code></pre>
<p>–module-path的值是包含打包后的模块的路径。在windows下需要将’:’替换成’;’。<br>$JAVA_HOME/jmods是包含java.base.jmod和其他标准化jdk模块的路径。mlib路径包含模块com.greetings的artifact。</p>
<p>jlink工具也包含许多高级的选项来自定义镜像，详见jlink –help</p>
<h3 id="–patch-module"><a href="#–patch-module" class="headerlink" title="–patch-module"></a>–patch-module</h3><p>开发者常会从Doug Lea的CVS中checkout出java.util.concurrent下的类并用-Xbootclasspath/p来替换源文件编译。(我都不知道Doug Lea还在更新juc的代码，膜拜大神)</p>
<p>现在-Xbootclasspath/p已经被舍弃，它在模块化系统中替代是–patch-module，用来替换模块中的类，它也可以被用来增大模块的内容。</p>
<p>javac命令同样也支持–patch-module选项用来编译模块中的as if部分。</p>
<p>以下是用新版本的java.util.concurrent.ConcurrentHashMap来编译并用其运行的例子</p>
<pre><code class="bash">javac --patch-module java.base=src -d mypatches/java.base \
    src/java.base/java/util/concurrent/ConcurrentHashMap.java

java --patch-module java.base=mypatches/java.base ...
</code></pre>
<h3 id="更多链接"><a href="#更多链接" class="headerlink" title="更多链接"></a>更多链接</h3><ul>
<li><a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">The State of the Module System</a></li>
<li><a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">JEP 261: Module System</a></li>
<li><a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Project Jigsaw</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[也来谈谈classloader和classpath hell问题]]></title>
      <url>/2018/01/11/classloader-classpath-hell/</url>
      <content type="html"><![CDATA[<p>classpath hell, 也叫 <a href="https://en.wikipedia.org/wiki/Java_Classloader#JAR_hell" target="_blank" rel="noopener">jar hell</a>。<br>先来简单翻译一下wiki：<br>Java Classloader 是 Java Runtime Environment 的一部分，它动态地将 Java 类加载到 jvm 中。类通常是按需加载的（即只有在需要实例化这个类时才会被加载）。因为有了 classloader 的存在，java runtime 不再需要知道有哪些文件。一个 java 类通常只会被加载一次。<br>当jvm启动时，会用到三个 classloader：</p>
<ol>
<li>Bootstrap class loader</li>
<li>Extensions class loader</li>
<li>System class loader</li>
</ol>
<p>bootstrap class loader是 jvm 的一部分，会加载 <java_home>/jre/lib 下的所有类。</java_home></p>
]]></content>
      
        <categories>
            
            <category> classLoader </category>
            
        </categories>
        
        
        <tags>
            
            <tag> classLoader </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>不是所有的树</p>
<p>都能在自己的家乡终老</p>
<p>不是所有的轨道</p>
<p>都通往春暖花开的地方</p>
<p>不是所有的花都会盛开</p>
<p>不是所有的约定的人都会到来</p>
<p>我知道，是流星赞美了黑夜</p>
<p>鲸鱼安慰了大海</p>
<hr>
<p><strong>Sean the Fish</strong></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=4882391&auto=0&height=66"></iframe>

<p>Java码农，目前供职于IBM。</p>
<p>博客刚刚建立，希望自己能坚持写下去。</p>
<p>Email：a728976009@hotmail.com</p>
<hr>
<p>想在天井里盛一只玻璃杯</p>
<p>明朝看天下雨今夜落几寸</p>
]]></content>
    </entry>
    
  
</search>
