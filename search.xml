<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Java模块系统综述]]></title>
      <url>/2018/03/29/module-system/</url>
      <content type="html"><![CDATA[<p><strong>本文是Mark Reinhold的The State of the Module System最新版的翻译。（<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>这份文档略有过时。其基本概念没有任何改变，但requires public关键字已被重新命名为requires transitive，并增加了几项附加功能。更新正在准备中，准备就绪后会在这里发布。</p>
<p>本文是对<a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Jigsaw项目</a>中对Java SE平台所做的增强的一个非正式的概述，并针对<a href="http://openjdk.java.net/projects/jigsaw/spec/" target="_blank" rel="noopener">JSR 376：Java平台模块系统</a>所提出。有<a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">相关的文档</a>描述了对特定于JDK工具和API的增强，这些超出了JSR的范围。</p>
<p>正如JSR所述，模块系统是为了提供可靠的配置，使程序组件相互显式的声明依赖，配合其强大的封装能力，使组件允许声明其中哪些公共类型可供其他组件访问，哪些不可以，并以此来替换脆弱，容易出错的类路径机制。</p>
<p>这些功能将直接对Java SE平台本身、Java应用程序开发人员，Java类库开发人员有利，而且也会间接地实现可伸缩平台、更高的平台完整性和更高的性能。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#定义模块">定义模块</a><ul>
<li><a href="#模块声明">模块声明</a></li>
<li><a href="#模块打包">模块打包</a></li>
<li><a href="#模块描述符">模块描述符</a></li>
<li><a href="#平台模块">平台模块</a></li>
</ul>
</li>
<li><a href="#使用模块">使用模块</a><ul>
<li><a href="#模块路径">模块路径</a></li>
<li><a href="#解决依赖">解决依赖</a></li>
<li><a href="#可读性">可读性</a></li>
<li><a href="#可访问性">可访问性</a></li>
<li><a href="#隐含的可读性">隐含的可读性</a></li>
</ul>
</li>
<li><a href="#兼容性和迁移">兼容性和迁移</a><ul>
<li><a href="#未命名模块">未命名模块</a></li>
<li><a href="#自下而上的迁移">自下而上的迁移</a></li>
<li><a href="#自动模块">自动模块</a></li>
<li><a href="#与类路径建立联系">与类路径建立联系</a></li>
</ul>
</li>
<li><a href="#服务">服务</a></li>
<li><a href="#高级特性">高级特性</a><ul>
<li><a href="#反射">反射</a></li>
<li><a href="#反射的可读性">反射的可读性</a></li>
<li><a href="#classloader">classloader</a></li>
<li><a href="#未命名模块">未命名模块</a></li>
<li><a href="#"></a></li>
<li><a href="#限制性导出">限制性导出</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<p>这是本文档的第二版。相对于<a href="#http://openjdk.java.net/projects/jigsaw/spec/sotms/2015-09-08">最初版本</a>，本版引入了兼容性和迁移的解释，修改了反射可读性的描述，进行了重新排序以改善叙述的流程，并且组织了更容易定位的目录。</p>
<p>文中仍然存在许多未解决的问题，其解决方案将反映在本文档的未来版本中。</p>
<h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>为了提供可靠的配置和强大的封装，使其既能接近开发人员，又能被现有工具链支持，我们将模块视为一种基本的新型Java程序组件。一个模块是一个命名的，能自我描述的代码和数据的集合。其代码被组织为一组包（package），包中包含Java类和接口。</p>
<h4 id="模块声明"><a href="#模块声明" class="headerlink" title="模块声明"></a>模块声明</h4><p>模块的自我描述体现在它的声明中，这是一种Java编程语言的新构造。最简单的模块声明只是指定其模块的名称：</p>
<pre><code class="java">module com.foo.bar { }
</code></pre>
<p>可以添加一个或多个require子句来声明该模块在编译时和运行时依赖于其他名称的某些模块：</p>
<pre><code class="java">module com.foo.bar {
    requires org.baz.qux;
}
</code></pre>
<p>最后，可以添加exports子句来声明该模块中仅有特定包中的公共类型可供其他模块使用：</p>
<pre><code class="java">module com.foo.bar {
    requires org.baz.qux;
    exports com.foo.bar.alpha;
    exports com.foo.bar.beta;
}
</code></pre>
<p>如果一个模块的声明不包含任何exports子句，那么它将不会导出任何类型到其他模块。</p>
<p>按照惯例，模块声明的源代码放置在名为module-info.java的文件中，该文件位于模块的源文件层次结构的根目录下。 com.foo.bar模块的源文件可能包括：</p>
<pre><code class="java">module-info.java
com/foo/bar/alpha/AlphaFactory.java
com/foo/bar/alpha/Alpha.java
...
</code></pre>
<p>按照惯例，模块声明被编译成名为module-info.class的文件，并放置在类文件输出目录中。</p>
<p>模块名称跟包名称一样，不得相互冲突。命名模块的推荐方法是使用长期用于命名软件包的反向域名模式。因此，模块的名称通常就是其导出包名称的前缀，但这种关系不是强制性的。</p>
<p>模块的声明不包括其版本号，也不包括它所依赖的子模块的版本号。这样做是故意为之的：模块系统的目标不是解决版本选择问题，这最好留给构建工具和容器应用程序来做。</p>
<p>模块声明是Java编程语言的一部分，这其中的原因有几个。其中最重要的一点是，模块必须在编译时和运行时都可用，以实现各个阶段的确定性，即确保模块系统在编译时和运行时都以相同的方式工作。这反过来又能防止多种错误的发生，或者至少在编译时更早地报告错误使其更容易诊断和修复。</p>
<p>源文件中的模块声明文件和模块中的其他源文件，将会一起编译为.class文件供Java虚拟机使用，这是建立确定性的自然方式。这种方法将立即为开发人员所熟悉，并且IDE和构建工具也会很容易支持。尤其是IDE，可以依照依赖需要为现有组件提供模块声明的提示。</p>
<h4 id="模块打包"><a href="#模块打包" class="headerlink" title="模块打包"></a>模块打包</h4><p>现有工具已经可以创建，操作和使用JAR包，因此为了便于使用和迁移，我们定义了模块化JAR包。除了根目录中还包含了一个module-info.class文件之外，模块化的JAR包就像普通的JAR包一样。上述com.foo.bar模块的模块化JAR包（例如）可能具有以下内容：</p>
<pre><code>META-INF/
META-INF/MANIFEST.MF
module-info.class
com/foo/bar/alpha/AlphaFactory.class
com/foo/bar/alpha/Alpha.class
...
</code></pre><p>模块化的JAR包可以被当作模块，在这种情况下，它的module-info.class文件被用来作为模块的声明。它也可以被放在普通的类路径上，在这种情况下，它的module-info.class文件将被忽略。模块化JAR包允许库的维护者在所有版本上发布包，该工件既可作为Java SE 9及更高版本的模块，也可作为类路径上的常规JAR包。我们期望包含jar工具的Java SE 9的实现将增强该工具，以便轻松创建模块化JAR包。</p>
<p>为了模块化Java SE平台的JDK，我们将引入一种新的打包机制，它将超越JAR包来容纳原生代码、配置文件和其他类型的数据（如果这种数据真的存在）。这种机制利用了在源文件中的模块声明并将它们编译成.class文件，此.class文件与其他的打包方式都不同。这种被临时命名为“JMOD”的新格式是否应该成为标准化仍旧是一个悬而未决的问题。</p>
<h4 id="模块描述符"><a href="#模块描述符" class="headerlink" title="模块描述符"></a>模块描述符</h4><p>将模块声明编译到.class文件中的最后一个优点是.class文件已经具有精确定义和可扩展的格式。因此，我们可以将module-info.class文件视为更通用的模块描述符，其中包括源代码级模块声明的编译形式，还包括在声明最初编译之后插入的.class文件中的附加信息。</p>
<p>例如，IDE、或者记录打包时间的工具，可以插入包含文档信息的属性，例如模块的版本、标题、说明和许可证。这些信息可以在编译时和运行时通过模块系统的反射来读取，以用于写文档，程序诊断和调试。它也可以被下游工具用于构建跨操作系统的程序包。特定的属性将被标准化，但由于Java类文件格式是可扩展的，所以其他工具和框架将能够根据需要来定义附加属性。非标准的属性不会影响模块系统本身的行为。</p>
<h3 id="平台模块"><a href="#平台模块" class="headerlink" title="平台模块"></a>平台模块</h3><p>Java SE 9的平台规范，使用模块系统将平台划分为一组模块。Java SE 9平台的实现可能包含所有的平台模块，或者可能仅包含其中的一部分。</p>
<p>在任何情况下，模块系统专用的唯一模块是已命名的基础模块java.base。基本模块定义并导出所有平台的核心软件包，包括模块系统本身：</p>
<pre><code class="java">module java.base {
    exports java.io;
    exports java.lang;
    exports java.lang.annotation;
    exports java.lang.invoke;
    exports java.lang.module;
    exports java.lang.ref;
    exports java.lang.reflect;
    exports java.math;
    exports java.net;
    ...
}
</code></pre>
<p>基本模块始终存在。每个其他模块都隐式的建立在基本模块之上，而基本模块则不依赖于其他模块。</p>
<p>其余的平台模块将共享“ java.”名称前缀，并有可能包括，例如，模块java.sql用于数据库连接， 模块java.xml用于XML处理，模块java.logging进行记录日志。按照惯例，尽管没有在Java SE 9平台规范中定义，但是专用于JDK的模块将共享“ jdk.”名称前缀。</p>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>单个模块可以在模块包中定义，或者内嵌于编译时或运行时环境。要在任一阶段使用它们，模块系统必须定位它们，然后确定它们如何相互关联的，并以此提供可靠的配置和强大的封装。</p>
<h4 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h4><p>为了定位包中定义的模块，模块系统搜索由系统定义的模块路径（module path）。模块路径是一个序列，其中的每个元素都是模块包或包含模块包的目录。系统会按顺序搜索模块路径的元素，以找到定义合适的第一个模块包。</p>
<p>模块路径（module path）与类路径（class path）有着很大的不同，它更加健壮。类路径的固有脆弱性是基于这样一个事实：即它是一种在所有包中通过路径来定位各个类型的工作方式，它不会在不同的包文件本身之间进行区分。这使得它无法预先知道程序什么时候缺少了某个包。它还允许不同的程序包（artifacts）在相同的包（package）中定义类型，即使这些程序包是只是版本不同，或者就是完全不同的组件（jar hell）。</p>
<p>相反，模块路径是定位整个模块、而不是某个类型的一种手段。如果模块系统无法满足来自模块路径的模块包的特定依赖性，或者如果在同一目录中遇到定义相同名称模块的两个模块包，则编译器或虚拟机将报告错误并退出。</p>
<p>内置于编译时或运行时环境的模块以及模块路径中的模块包定义的模块统称为可观察模块的范围。</p>
<h4 id="解决依赖"><a href="#解决依赖" class="headerlink" title="解决依赖"></a>解决依赖</h4><p>假设我们有一个使用上述com.foo.bar模块和平台java.sql模块的应用程序。包含应用程序核心的模块声明如下：</p>
<pre><code class="java">module com.foo.app {
    requires com.foo.bar;
    requires java.sql;
}
</code></pre>
<p>鉴于这种初始应用程序模块，该模块系统可通过表达依赖性的requires来定位额外观察到的模块，以满足这些依赖关系，然后解决这些模块的依赖关系，并依此类推，直到每个模块的每一个的依赖都被满足。这个传递闭包计算的结果是一个模块图，对于每个依赖其他模块的模块，它包含从第一个模块到第二个模块的有向边。</p>
<p>要为模块com.foo.app构建模块图，模块系统将检查模块的声明java.sql，即：</p>
<pre><code class="java">module java.sql {
    requires java.logging;
    requires java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
</code></pre>
<p>它还会循环检查其声明的com.foo.bar模块（上面的模块定义中已经示出），包括org.baz.qux模块，java.logging模块和 java.xml模块; 为简洁起见，最后三个这里没有显示，因为它们没有声明对任何其他模块的依赖。</p>
<p>根据所有这些模块声明，为com.foo.app模块画出的模块图，包含以下节点和边：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/jdk-module.png" alt="module-pic"></p>
<p>在该图中，深蓝色线条表示显式依赖关系，如requires，而浅蓝色线条表示每个模块对基本模块的隐式依赖关系。</p>
<h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p>当一个模块直接依赖于模块图中的另一个模块时，则第一个模块中的代码将能够引用第二个模块中的类型。因此，我们说第一个模块读取第二个模块，或者等同地，第二个模块可以被第一个模块读取。因此，在上述的曲线图中，com.foo.app模块读取com.foo.bar和 java.sql模块，但并不读取org.baz.qux模块，java.xml模块或 java.logging模块。java.logging模块可由java.sql模块读取，但不能被其他模块读取。（根据定义，每个模块都会自行读取自己本身。）</p>
<p>在模块图中定义的可读性关系是可靠配置的基础 ：模块系统能确保每个依赖是由另一个模块完成的，模块图是非循环的，每个模块最多只能读取一个包含制定包的模块，这样定义相同名称包的模块就不会相互干扰。</p>
<p>这样的配置不仅更可靠，也可以更快。当模块中的代码引用包中的某个类型时，那么该包将保证在该模块中定义，或者只在该模块读取的模块中定义一个。因此，在寻找特定类型的定义时，不需要在多个模块中搜索它，或者更糟糕的，沿着整个路径搜索它。</p>
<h4 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h4><p>在模块图中定义的可读性关系与exports模块声明中的子句相结合，是强封装的基础：只有当某个模块被另一个模块读取时，Java编译器和虚拟机才会将这个模块中的包中的公共类型视为只能被另一个模块所访问，同时还需要这个模块导出该包。即，如果两种类型的S和T在不同的模块中定义的，并且T是 public，则如果代码S 可以存取 T，必须满足以下条件：</p>
<ol>
<li>S的模块读取T的模块，</li>
<li>T的模块导出T包。</li>
</ol>
<p>以这种方式无法访问的跨模块边界引用的类型以与私有方法或字段不可用相同的方式不可用：任何尝试使用它的操作都将导致编译器报告错误，或者IllegalAccessError由Java虚拟机或IllegalAccessException由反射式运行时API引发。因此，即使声明了一个类型public，如果它的包没有在其模块的声明中导出，那么它将只能被该模块中的代码访问。</p>
<p>如果它的封闭类型是可访问的，并且如果成员本身的声明也允许访问，那么跨模块边界引用的方法或字段是可访问的。</p>
<p>要了解上述模块图的封装是如何工作的，我们使用它导出的包标记每个模块：</p>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Project Jigsaw:Java模块系统快速入门指南]]></title>
      <url>/2018/03/29/java9-quick-guide/</url>
      <content type="html"><![CDATA[<p><strong>本文为openjdk官方java模块入门指南的翻译。(<a href="http://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener">原文地址</a>)</strong></p>
<p>本文档提供了一些让开发者快速上手Java模块系统的简单例子。<br>例子中的文件路径用/划分，文件分隔符是：，windows开发者请用\和；替换以上分隔符。</p>
<h3 id="Greetings"><a href="#Greetings" class="headerlink" title="Greetings"></a>Greetings</h3><p>第一个例子展示了一个打印”Greetings!”字符串的简单模块。这个模块由两个源文件组成（module-info.java和Main.java）。按照惯例，模块的源文件应该在一个以模块名字为命名的目录中。</p>
<pre><code class="java">src/com.greetings/com/greetings/Main.java
src/com.greetings/module-info.java

$ cat src/com.greetings/module-info.java
module com.greetings { }

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;
public class Main {
    public static void main(String[] args) {
        System.out.println(&quot;Greetings!&quot;);
    }
}
</code></pre>
<p>以下命令会讲源文件编译到mods/com.greetings目录中：</p>
<pre><code class="bash">$ mkdir -p mods/com.greetings

$ javac -d mods/com.greetings \
    src/com.greetings/module-info.java \
    src/com.greetings/com/greetings/Main.java
</code></pre>
<p>现在我们用以下命令来运行这个例子：</p>
<pre><code class="bash">$ java --module-path mods -m com.greetings/com.greetings.Main
</code></pre>
<p>–module-path 是模块的路径，他的值是包含模块的一个或多个目录。<br>-m 指定了主模块，/后面的值是模块里包含main方法的全类名。</p>
<h3 id="Greetings-world"><a href="#Greetings-world" class="headerlink" title="Greetings world"></a>Greetings world</h3><p>第二个例子更新了第一个例子中的模块声明，它声明了需要一个名为org.astro的模块的依赖<br>模块org.astro导出了名为org.astro的api包。</p>
<pre><code class="java">src/org.astro/module-info.java
src/org.astro/org/astro/World.java
src/com.greetings/com/greetings/Main.java
src/com.greetings/module-info.java

$ cat src/org.astro/module-info.java
module org.astro {
    exports org.astro;
}

$ cat src/org.astro/org/astro/World.java
package org.astro;
public class World {
    public static String name() {
        return &quot;world&quot;;
    }
}

$ cat src/com.greetings/module-info.java
module com.greetings {
    requires org.astro;
}

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;
import org.astro.World;
public class Main {
    public static void main(String[] args) {
        System.out.format(&quot;Greetings %s!%n&quot;, World.name());
    }
}
</code></pre>
<p>依次编译这两个模块，用javac命令在编译com.greetings模块时指定模块的路径，使得org.astro模块中的引用和其导出包中的类型可以被引用。</p>
<pre><code class="bash">$ mkdir -p mods/org.astro mods/com.greetings

$ javac -d mods/org.astro \
    src/org.astro/module-info.java src/org.astro/org/astro/World.java

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
</code></pre>
<p>使用与第一个例子相同的方式来运行这个例子：</p>
<pre><code class="bash">$ java --module-path mods -m com.greetings/com.greetings.Main
Greetings world!
</code></pre>
<h3 id="多模块编译"><a href="#多模块编译" class="headerlink" title="多模块编译"></a>多模块编译</h3><p>在上面的例子中，模块com.greetings和模块org.astro是分开编译的，我们也可以用一条javac命令来编译多个模块</p>
<pre><code class="bash">$ mkdir mods

$ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)

$ find mods -type f
mods/com.greetings/com/greetings/Main.class
mods/com.greetings/module-info.class
mods/org.astro/module-info.class
mods/org.astro/org/astro/World.class
</code></pre>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在目前的实例中，编译好的模块都分散在文件系统中，为了调度和部署，我们通常会把模块打包成模块化jar包，模块化jar包就是在jar包最顶层目录包含module-info.class的普通jar包。</p>
<p>以下命令将会在mlib目录中创建org.astro@1.0.jar和com.greetings.jar</p>
<pre><code class="bash">$ mkdir mlib

$ jar --create --file=mlib/org.astro@1.0.jar \
    --module-version=1.0 -C mods/org.astro .

$ jar --create --file=mlib/com.greetings.jar \
    --main-class=com.greetings.Main -C mods/com.greetings .

$ ls mlib
com.greetings.jar   org.astro@1.0.jar
</code></pre>
<p>在这个例子中，模块org.astro在打包时被指定了其版本号1.0，模块com.greetings在打包时被制定了其main方法主类com.greetings.Main。</p>
<p>现在，我们可以直接运行模块com.greetings而无需制定其main class</p>
<pre><code class="bash">$ java -p mlib -m com.greetings
Greetings world!
</code></pre>
<p>命令可以用-p来替代–module-path。</p>
<p>jar命令拥有许多新选项，其中一个就是打印模块化jar包中声明的模块。</p>
<pre><code class="bash">$ jar --describe-module --file=mlib/org.astro@1.0.jar
org.astro@1.0 jar:file:///d/mlib/org.astro@1.0.jar/!module-info.class
exports org.astro
requires java.base mandated
</code></pre>
<h3 id="缺少requires或者exports关键字"><a href="#缺少requires或者exports关键字" class="headerlink" title="缺少requires或者exports关键字"></a>缺少requires或者exports关键字</h3><p>如果我们在com.greetings模块中遗漏了requires关键字：</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    // requires org.astro;
}

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
    import org.astro.World;
                ^
    (package org.astro is declared in module org.astro, but module com.greetings does not read it)
1 error
</code></pre>
<p>如果我们在org.astro模块中遗漏了exports关键字：</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    requires org.astro;
}
$ cat src/org.astro/module-info.java
module org.astro {
    // exports org.astro;
}

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
    import org.astro.World;
                ^
    (package org.astro is declared in module org.astro, which does not export it)
1 error
</code></pre>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务允许服务提供者和服务消费者中建立松散的耦合结构。在这个例子中，存在这一个服务提供者和一个服务消费者：模块com.socket提供了API用来做network socket；模块org.fastsocket是一个服务提供模块，它提供了com.socket.spi.NetworkSocketProvider的实现，并且不导出任何包。</p>
<p>下面是模块com.socket的代码：</p>
<pre><code class="java">$ cat src/com.socket/module-info.java
module com.socket {
    exports com.socket;
    exports com.socket.spi;
    uses com.socket.spi.NetworkSocketProvider;
}

$ cat src/com.socket/com/socket/NetworkSocket.java
package com.socket;

import java.io.Closeable;
import java.util.Iterator;
import java.util.ServiceLoader;

import com.socket.spi.NetworkSocketProvider;

public abstract class NetworkSocket implements Closeable {
    protected NetworkSocket() { }

    public static NetworkSocket open() {
        ServiceLoader&lt;NetworkSocketProvider&gt; sl
            = ServiceLoader.load(NetworkSocketProvider.class);
        Iterator&lt;NetworkSocketProvider&gt; iter = sl.iterator();
        if (!iter.hasNext())
            throw new RuntimeException(&quot;No service providers found!&quot;);
        NetworkSocketProvider provider = iter.next();
        return provider.openNetworkSocket();
    }
}


$ cat src/com.socket/com/socket/spi/NetworkSocketProvider.java
package com.socket.spi;

import com.socket.NetworkSocket;

public abstract class NetworkSocketProvider {
    protected NetworkSocketProvider() { }

    public abstract NetworkSocket openNetworkSocket();
}
</code></pre>
<p>以下是模块org.fastsocket的代码</p>
<pre><code class="java">$ cat src/org.fastsocket/module-info.java
module org.fastsocket {
    requires com.socket;
    provides com.socket.spi.NetworkSocketProvider
        with org.fastsocket.FastNetworkSocketProvider;
}

$ cat src/org.fastsocket/org/fastsocket/FastNetworkSocketProvider.java
package org.fastsocket;

import com.socket.NetworkSocket;
import com.socket.spi.NetworkSocketProvider;

public class FastNetworkSocketProvider extends NetworkSocketProvider {
    public FastNetworkSocketProvider() { }

    @Override
    public NetworkSocket openNetworkSocket() {
        return new FastNetworkSocket();
    }
}

$ cat src/org.fastsocket/org/fastsocket/FastNetworkSocket.java
package org.fastsocket;

import com.socket.NetworkSocket;

class FastNetworkSocket extends NetworkSocket {
    FastNetworkSocket() { }
    public void close() { }
}
</code></pre>
<p>为了简单化，我们同时编译两个模块，但事实上，服务提供者和服务消费者几乎总是分开编译的</p>
<pre><code class="bash">$ mkdir mods
$ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)
</code></pre>
<p>最后我们对模块com.greetings用新的模块的api做更改</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    requires com.socket;
}

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;

import com.socket.NetworkSocket;

public class Main {
    public static void main(String[] args) {
        NetworkSocket s = NetworkSocket.open();
        System.out.println(s.getClass());
    }
}


$ javac -d mods/com.greetings/ -p mods $(find src/com.greetings/ -name &quot;*.java&quot;)
</code></pre>
<p>最后，我们运行com.greetings模块</p>
<pre><code class="bash">$ java -p mods -m com.greetings/com.greetings.Main
class org.fastsocket.FastNetworkSocket
</code></pre>
<p>输出结果确认服务提供者已经被定位成功。</p>
<h3 id="The-linker"><a href="#The-linker" class="headerlink" title="The linker"></a>The linker</h3><p>jlink是一个用来在一组拥有传递性依赖的模块之中，建立一个自定义的模块化可运行镜像的工具。</p>
<p>此工具目前需要制定模块路径的模块化jar包或者jmod格式。jdk会将标准的或jdk指定的模块以jmod格式打包。</p>
<p>以下命令会创建一个包含模块com.greetings和其传递性依赖的可运行镜像。</p>
<pre><code class="bash">jlink --module-path $JAVA_HOME/jmods:mlib --add-modules com.greetings --output greetingsapp
</code></pre>
<p>–module-path的值是包含打包后的模块的路径。在windows下需要将’:’替换成’;’。<br>$JAVA_HOME/jmods是包含java.base.jmod和其他标准化jdk模块的路径。mlib路径包含模块com.greetings的artifact。</p>
<p>jlink工具也包含许多高级的选项来自定义镜像，详见jlink –help</p>
<h3 id="–patch-module"><a href="#–patch-module" class="headerlink" title="–patch-module"></a>–patch-module</h3><p>开发者常会从Doug Lea的CVS中checkout出java.util.concurrent下的类并用-Xbootclasspath/p来替换源文件编译。(我都不知道Doug Lea还在更新juc的代码，膜拜大神)</p>
<p>现在-Xbootclasspath/p已经被舍弃，它在模块化系统中替代是–patch-module，用来替换模块中的类，它也可以被用来增大模块的内容。</p>
<p>javac命令同样也支持–patch-module选项用来编译模块中的as if部分。</p>
<p>以下是用新版本的java.util.concurrent.ConcurrentHashMap来编译并用其运行的例子</p>
<pre><code class="bash">javac --patch-module java.base=src -d mypatches/java.base \
    src/java.base/java/util/concurrent/ConcurrentHashMap.java

java --patch-module java.base=mypatches/java.base ...
</code></pre>
<h3 id="更多链接"><a href="#更多链接" class="headerlink" title="更多链接"></a>更多链接</h3><ul>
<li><a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">The State of the Module System</a></li>
<li><a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">JEP 261: Module System</a></li>
<li><a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Project Jigsaw</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[也来谈谈classloader和classpath hell问题]]></title>
      <url>/2018/01/11/classloader-classpath-hell/</url>
      <content type="html"><![CDATA[<p>classpath hell, 也叫 <a href="https://en.wikipedia.org/wiki/Java_Classloader#JAR_hell" target="_blank" rel="noopener">jar hell</a>。<br>先来简单翻译一下wiki：<br>Java Classloader 是 Java Runtime Environment 的一部分，它动态地将 Java 类加载到 jvm 中。类通常是按需加载的（即只有在需要实例化这个类时才会被加载）。因为有了 classloader 的存在，java runtime 不再需要知道有哪些文件。一个 java 类通常只会被加载一次。<br>当jvm启动时，会用到三个 classloader：</p>
<ol>
<li>Bootstrap class loader</li>
<li>Extensions class loader</li>
<li>System class loader</li>
</ol>
<p>bootstrap class loader是 jvm 的一部分，会加载 <java_home>/jre/lib 下的所有类。</java_home></p>
]]></content>
      
        <categories>
            
            <category> classLoader </category>
            
        </categories>
        
        
        <tags>
            
            <tag> classLoader </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>不是所有的树</p>
<p>都能在自己的家乡终老</p>
<p>不是所有的轨道</p>
<p>都通往春暖花开的地方</p>
<p>不是所有的花都会盛开</p>
<p>不是所有的约定的人都会到来</p>
<p>我知道，是流星赞美了黑夜</p>
<p>鲸鱼安慰了大海</p>
<hr>
<p><strong>Sean the Fish</strong></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=4882391&auto=0&height=66"></iframe>

<p>Java码农，目前供职于IBM。</p>
<p>博客刚刚建立，希望自己能坚持写下去。</p>
<p>Email：a728976009@hotmail.com</p>
<hr>
<p>想在天井里盛一只玻璃杯</p>
<p>明朝看天下雨今夜落几寸</p>
]]></content>
    </entry>
    
  
</search>
