<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[用gradle构建Java 9模块化系统快速指南]]></title>
      <url>/2018/04/11/gradle-guide-java9/</url>
      <content type="html"><![CDATA[<p><strong>本文是gradle官方的构建Java 9模块化系统的入门指南的翻译。（<a href="https://guides.gradle.org/building-java-9-modules/?_ga=2.174270880.30455902.1522735364-1287880600.1513842256" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>Java 9最令人兴奋的特性之一是它支持开发和部署Java模块化系统。在本指南中，您将了解到如何用gradle实现模块化功能，你所要做的事情：</p>
<ol>
<li>为您的Java库生成Java 9模块。</li>
<li>使用Java 9模块作为您的依赖。</li>
<li>在Java 9模块中使用Java的ServiceLoader模式。</li>
<li>使用Java 9模块运行应用程序。</li>
<li>使用一个插件来更简单地完成以上功能。</li>
</ol>
<p>虽然Gradle 4.6版尚未对Java 9模块提供一流的支持，本指南仍将向您介绍如何在支持完成之前对Java 9进行试验性的工作。</p>
<h3 id="你需要什么"><a href="#你需要什么" class="headerlink" title="你需要什么"></a>你需要什么</h3><ol>
<li>大约41分钟</li>
<li>一个文本编辑器</li>
<li>一个命令提示符</li>
<li>Java开发工具包（JDK），版本1.9（版本174）+</li>
</ol>
<h3 id="了解示例项目"><a href="#了解示例项目" class="headerlink" title="了解示例项目"></a>了解示例项目</h3><p>本指南逐步说明，如何将不使用任何Java 9功能的Java应用程序，转换为完全模块化的Java 9应用程序。原始版本的应用程序的源代码位于src/0-original目录中。它被组织为由六个子项目组成的多项目Gradle构建：</p>
<ol>
<li>fairy - java应用程序storyteller的入口点。</li>
<li>tale - 公共Tale接口的库。</li>
<li>formula - 帮助改造Tale接口的库。</li>
<li>actors - fairy tale中所有characters的库。</li>
<li>pigs - 代表三个小猪的Tale实例的库。</li>
<li>bears - 代表金发姑娘和三只熊的Tale实例的库。</li>
</ol>
<p>六个项目之间依赖关系的项目层次结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/gradle_guide_java9/project-graph.png" alt="gradle-java9-1"></p>
<p>如果你对api和implementation不熟悉，请参阅在Gradle 3.5中加入的<a href="https://docs.gradle.org/current/userguide/java_library_plugin.html?_ga=2.204456536.934686470.1523424544-1287880600.1513842256" target="_blank" rel="noopener">Java Library Plugin</a></p>
<p>你可以克隆源代码来查看原始项目的输出：</p>
<pre><code class="bash">$ git clone https://github.com/gradle-guides/building-java-9-modules.git
$ cd building-java-9-modules/src/0-original
$ ./gradlew run

&gt; Task :fairy:run
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

&lt;... elided ...&gt;

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.


BUILD SUCCESSFUL
</code></pre>
<p>在开始修改此项目以使其使用Java 9模块之前，您需要了解项目结构的两个重要细节，就是，它使用 ServiceLoader API来在运行时加载fairy tale，并且它包含一个测试类来显示在使用Java 9之前，软件模块化是如何被破坏的。</p>
<h4 id="ServiceLoader的用法"><a href="#ServiceLoader的用法" class="headerlink" title="ServiceLoader的用法"></a>ServiceLoader的用法</h4><p>Java 1.6引入了一种简单的机制，用于在运行时将一些接口（“Service”）的一组实现绑定到一个消费类。有关该特性的<a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html" target="_blank" rel="noopener">Oracle教程</a>有点冗长，下面是它在示例应用程序中的使用方式：</p>
<pre><code class="java">public static void main(String[] args) {
        ServiceLoader&lt;Tale&gt; loader = ServiceLoader.load(Tale.class);
        if (!loader.iterator().hasNext()) {
            System.out.println(&quot;Alas, I have no tales to tell!&quot;);
        }
        for (Tale tale : loader) {
            tale.tell();
        }
    }
</code></pre>
<p>JVM中的类加载器用ServiceLoader来找出，类路径上META-INF/services文件夹中的，名为org.gradle.fairy.tale.Tale的指定Tale类。</p>
<p>ears/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale:</p>
<pre><code class="java">org.gradle.fairy.tale.bears.GoldilocksAndTheThreeBears
</code></pre>
<p>pigs/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale:</p>
<pre><code class="java">org.gradle.fairy.tale.pigs.ThreeLittlePigs
</code></pre>
<p>在运行时加载这些实例,会使StoryTeller类以松耦合的方式连接到实现该Tale接口的两个库。你可以在应用程序的build.gradle文件的dependencies块中看到它。</p>
<p>fairy/build.gradle:</p>
<pre><code class="gradle">dependencies {
    implementation project(&#39;:tale&#39;)

    runtimeOnly project(&#39;:pigs&#39;)
    runtimeOnly project(&#39;:bears&#39;)
}
</code></pre>
<p>注释掉以runtimeOnly开头的两行，并注意Gradle run任务的输出是如何改变的：</p>
<pre><code class="bash">$ ./gradlew run

&gt; Task :fairy:run
Alas, I have no tales to tell!


BUILD SUCCESSFUL
</code></pre>
<h4 id="模块化测试讨论"><a href="#模块化测试讨论" class="headerlink" title="模块化测试讨论"></a>模块化测试讨论</h4><p>在最初的项目中，有一个测试类，展现了在Java 9之前的Java版本中，未实施模块化的一些问题。<br>formula/src/test/java/org/gradle/fairy/tale/formula/ModularityTest.java：</p>
<pre><code class="java">    @Test
    public void canReachActor() {
        Actor actor = Imagination.createActor(&quot;Sean Connery&quot;);
        assertEquals(&quot;Sean Connery&quot;, actor.toString());
    }

    @Test
    public void canDynamicallyReachDefaultActor() throws Exception {
        Class clazz = ModularityTest
            .class.getClassLoader()
            .loadClass(&quot;org.gradle.actors.impl.DefaultActor&quot;);
        Actor actor = (Actor) clazz.getConstructor(String.class)
            .newInstance(&quot;Kevin Costner&quot;);
        assertEquals(&quot;Kevin Costner&quot;, actor.toString());
    }

    @Test
    public void canReachDefaultActor() {
        Actor actor = new org.gradle.actors.impl.DefaultActor(&quot;Kevin Costner&quot;);
        assertEquals(&quot;Kevin Costner&quot;, actor.toString());
    }

    /*
    @Test
    public void canReachGuavaClasses() {
        // This line would throw a compiler error because gradle has kept the implementation dependency &quot;guava&quot;
        // from leaking into the formula project.
        Set&lt;String&gt; strings = com.google.common.collect.ImmutableSet.of(&quot;Hello&quot;, &quot;Goodbye&quot;);
        assertTrue(strings.contains(&quot;Hello&quot;));
        assertTrue(strings.contains(&quot;Goodbye&quot;));
    }
    */
</code></pre>
<p>这个类的四个测试有不同的目的：</p>
<ol>
<li>canReachActor - 通过调用actors项目的公共api来表明formula项目的访问权限。</li>
<li>canDynamicallyReachDefaultActor - 尝试在运行时使用反射来加载actors子项目的私有类。这在Java 9之前是可能的，因为类路径会将应用程序的所有的实现细节暴露给其他所有的应用。</li>
<li>canReachDefaultActor - 尝试直接使用actors子项目的私有类。这只在Java 9之前可行，因为actors子项目的私有实现细节与该子项目的公共API构建在相同的位置。所以，它们在编译时和运行时都可用。</li>
<li>canReachGuavaClasses - 尝试使用actors子项目所依赖的类。需要注意的是，从Gradle 3.4开始，使用implementation关键字的依赖关系不包含在Java项目的消费者的编译类路径（compileClasspath）中。因此，这个测试被注释掉了，因为它不能用Gradle 3.4或更新的版本编译。</li>
</ol>
<p>遵循本指南，你会看到Java 9将对于模块细节的访问权限变得更加紧密，并导致测试，canDynamicallyReachDefaultActor和canReachDefaultActor在运行时或编译时失败。</p>
<p>你可以运行Gradle的check任务，来认证这三个测试是否通过了0-original项目（尽管其中两个测试 打破了良好的模块化设计。）</p>
<pre><code class="bash">$ ./gradlew check

BUILD SUCCESSFUL
</code></pre>
<p>您可以在<a href="https://scans.gradle.com/s/l76lgbuizu4pm/tests/byProject?toggled=W1sxXSxbMSwwXSxbMSwwLDBdLFsxLDAsMCwwXV0" target="_blank" rel="noopener">建构扫描</a>中查看此次调用gradle task任务的结果。</p>
<h3 id="第1步-为单个子项目生成Java-9模块"><a href="#第1步-为单个子项目生成Java-9模块" class="headerlink" title="第1步 - 为单个子项目生成Java 9模块"></a>第1步 - 为单个子项目生成Java 9模块</h3><p>如果您还不熟悉Java 9模块系统，请阅读：</p>
<ol>
<li><a href="http://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener">模块系统快速入门指南</a> / <a href="http://seanthefish.com/2018/03/29/java9-quick-guide/">(原文翻译)</a></li>
<li><a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">模块系统综述</a> / <a href="http://seanthefish.com/2018/03/29/module-system/">(原文翻译)</a></li>
</ol>
<p>本指南假定您已经熟悉以下概念：</p>
<ol>
<li>模块路径</li>
<li>自动模块</li>
<li>module-info.java文件的基本语法</li>
</ol>
<p>Java 9中模块系统的一个很好的功能就是可以以自下而上的方式将项目的所有代码库转换为Java 9模块。无论是从类路径还是模块路径中，我们都可以获取Java 9模块化jar包，所以我们可以在多项目构建中，转换单个叶节点以生成Java 9模块，但是在编译时使用该模块化的jar包或在类路径上使用该模块化jar包来运行该节点的输出。</p>
<p>将java-library项目转换为Java 9模块时，应该对项目进行五项更改:</p>
<ol>
<li>添加一个module-info.java文件来描述模块。</li>
<li>修改compileJava任务以生成模块。</li>
<li>修改compileTestJava任务以在本地修改模块。</li>
<li>修改test任务以使用本地更改的模块。</li>
<li>（可选）在所有其他项目的清单条目（MANIFEST.MF）中添加Automatic-Module-Name属性。</li>
</ol>
<p>我们建议为组成应用程序的所有项在META-INF/MANIFEST.MF文件中主动添加目Automatic-Module-Name清单条目 。提供Automatic-Module-Name允许库作者为未来预留模块名称，而不必将库转换为模块。这确保了库的消费者现在就可以知道模块名称将来会是什么。</p>
<p>在下面的小节中将介绍这些变化，并讨论为什么要进行变更。您还可以通过浏览src/1-single-module库中的示例项目来查看这些更改的结果。</p>
<p>我们做出以下五项改变的目标是让actors项目生成一个Java 9模块。前四项变更需要一起完成，第五项（可选）变更可以独立完成。</p>
<blockquote>
<p>提醒一下，从这一点开始，所有的构建都需要在Java 9上运行</p>
</blockquote>
<h4 id="添加一个module-info-java文件来描述模块。"><a href="#添加一个module-info-java文件来描述模块。" class="headerlink" title="添加一个module-info.java文件来描述模块。"></a>添加一个module-info.java文件来描述模块。</h4><p>将module-info.java文件添加到项目的actors/src/main/java目录。</p>
<p>actors/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.actors {
    exports org.gradle.actors;
    requires guava;
}
</code></pre>
<p>该文件声明org.gradle.actors模块导出org.gradle.actors包（但不org.gradle.actors.impl包），并需要guava模块。Guava jar文件还不是Java 9模块，所以当你需要它们时，你必须使用JVM通过jar文件的文件名来推断生成的自动模块的名称。对于guava来说，jar文件的名称是<a href="http://central.maven.org/maven2/com/google/guava/guava/22.0/" target="_blank" rel="noopener">guava-22.0.jar</a>，因此根据<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/#automatic-modules" target="_blank" rel="noopener">自动模块名称的规则</a>，您需要的模块叫guava。</p>
<h4 id="修改compileJava任务以生成模块。"><a href="#修改compileJava任务以生成模块。" class="headerlink" title="修改compileJava任务以生成模块。"></a>修改compileJava任务以生成模块。</h4><p>在actors子项目的build.gradle文件中添加以下内容。</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">ext.moduleName = &#39;org.gradle.actors&#39; //(1)

compileJava {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        options.compilerArgs = [
            &#39;--module-path&#39;, classpath.asPath,
        ]
        classpath = files()  //(2)
    }
}
</code></pre>
<ol>
<li>为模块名称定义一个变量，该变量允许您稍后为其他模块重复使用相同的代码，而无需对其进行更改。</li>
<li>通过创建一个空文件集合来清除classpath属性。</li>
</ol>
<p>编译Java 9模块时，您想使用–module-path而不是 –classpath读取您的依赖关系。因此，在该doFirst块中，您将清除该任务的classpath属性并添加一个编译器参数。</p>
<blockquote>
<p>–module-path被设置为原来的值classpath。这样做是因为，classpath已经有你所依赖的库的所有jar包和类输出目录。</p>
<p>在doFirst代码块内而不是在compileJava任务中修改options.compilerArgs参数的原因是，在执行这个任务时，你只需要重构compileClasspath（编译时的类路径）的配置。</p>
</blockquote>
<h4 id="修改compileJava任务以生成模块。-1"><a href="#修改compileJava任务以生成模块。-1" class="headerlink" title="修改compileJava任务以生成模块。"></a>修改compileJava任务以生成模块。</h4><p>Java 9模块系统的一个稍微混淆的方面是如何对Java 9模块内的代码运行单元测试。推荐的方法是在测试过程中“修补”模块。修补模块意味着向组成模块的包添加额外的类。在运行测试所需要的修补模块步骤中，您将使用相同的包来把测试类添加到模块中，以便测试类可以访问被测模块中的所有其他模块。</p>
<p>将以下内容添加到您build.gradle文件中，来实现在编译时对org.gradle.actors模块的修补。</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">compileTestJava {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        options.compilerArgs = [
            &#39;--module-path&#39;, classpath.asPath, \\(1)
            &#39;--add-modules&#39;, &#39;junit&#39;,  \\(2)
            &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;, \\(3)
            &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.srcDirs).asPath, \\(4)
        ]
        classpath = files()
    }
}
</code></pre>
<ol>
<li>用–module-path参数来作为classpath属性的默认值。</li>
<li>显式地将junit自动模块添加为可观察模块。</li>
<li>声明junit模块读取org.gradle.actors模块。</li>
<li>将测试源文件添加到org.gradle.actors模块。</li>
</ol>
<p>这些选项的添加将会导致测试源的输出目录中的生成类文件包含合适的元数据来修补org.gradle.actors模块，这些类文件会在接下来的更改中被使用。</p>
<h4 id="修改test任务以使用本地更改的模块。"><a href="#修改test任务以使用本地更改的模块。" class="headerlink" title="修改test任务以使用本地更改的模块。"></a>修改test任务以使用本地更改的模块。</h4><p>运行测试时，我们必须配置运行测试的JVM使其发现我们的模块，并修补org.gradle.actors模块来引入测试类。</p>
<p>将以下内容添加到actors项目中的build.gradle文件中。</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">test {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        jvmArgs = [
            &#39;--module-path&#39;, classpath.asPath, \\(1)
            &#39;--add-modules&#39;, &#39;ALL-MODULE-PATH&#39;, \\(2)
            &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;, \\(3)
            &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.outputDir).asPath, \\(4)
        ]
        classpath = files()
    }
}
</code></pre>
<ol>
<li>这是测试运行时的classpath属性的默认值。</li>
<li>使用特殊的ALL-MODULE-PATH，因为运行测试的JVM的main class不是Java 9模块的一部分。它是Gradle的测试运行器，因此它没有声明它需要使用的模块。该参数使模块路径中的所有模块都可以被测试类访问。</li>
<li>声明junit读取org.gradle.actors模块。</li>
<li>将测试类添加到org.gradle.actors模块。</li>
</ol>
<h4 id="（可选）在所有其他项目的清单条目（MANIFEST-MF）中添加Automatic-Module-Name属性。"><a href="#（可选）在所有其他项目的清单条目（MANIFEST-MF）中添加Automatic-Module-Name属性。" class="headerlink" title="（可选）在所有其他项目的清单条目（MANIFEST.MF）中添加Automatic-Module-Name属性。"></a>（可选）在所有其他项目的清单条目（MANIFEST.MF）中添加Automatic-Module-Name属性。</h4><p>为了向后兼容，Java 9的模块系统允许非模块化的jar文件出现在模块路径中。默认情况下，这些jar文件将被转换为自动模块，其名称基于jar文件的文件名。但是这会导致一些冗杂。许多jar文件名已经创建，但没有任何规则能保证这个jar的名字是唯一的。所以当负责维护一些常用jar的开发人员在将该jar转换为Java 9模块时，他们更希望会选择一个新的模块名称，而非由自动模块转换所自动生成的名称。</p>
<p>例如，你现在可以在module-info.java文件中通过requires guava子句指定模块，但稍后负责该项目的开发人员决定为其模块命名com.google.guava。现在，任何指定requires guava或任何依赖此模块的用户，都必须改变它们依赖的模块为requires com.google.guava，如此才能使用这些新模块，因为Java 9只允许模块路径上的模块包含特定的包。</p>
<p>因此，整个情况可能会变得非常混乱。这就是为什么<a href="http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html" target="_blank" rel="noopener">Stephen Colebourne认为</a>我们应该立即开始更新我们发布到公共存储库的所有jar,（至少要在jar的清单中指定Automatic-Module-Name属性），而且也不要发布任何未指定Automatic-Module-Name属性并且包含需要自动模块的模块的工件。</p>
<p>因此，在每个子项目的build.gradle文件中指定一个moduleName变量。例如：</p>
<p>fairy/build.gradle:</p>
<pre><code class="gradle">ext.moduleName = &#39;org.gradle.fairy.app&#39;
</code></pre>
<p>另外，在顶层build.gradle文件中的afterEvaluate代码块中的jar任务中添加manifest属性。</p>
<pre><code class="gradle">jar {
        inputs.property(&quot;moduleName&quot;, moduleName)
        manifest {
            attributes(&#39;Automatic-Module-Name&#39;: moduleName)
        }
    }
</code></pre>
<p>现在，当您将jar文件发布到像Maven Central这样的工件存储库时，你发布的jar包的文件名就不再重要了; 你一定会（通过Automatic-Module-Name）得到你想要的Java 9模块名称。</p>
<blockquote>
<p>在下一步中，您将摆脱这些清单属性，因为您已将每个子项目都转换为适当的Java 9模块。</p>
</blockquote>
<h4 id="第1步-总结"><a href="#第1步-总结" class="headerlink" title="第1步 - 总结"></a>第1步 - 总结</h4><p>这第一步是最复杂的，但现在您已经将第一个java-library项目转换为Java 9模块。所有其他子项目都在类路径上使用该模块。我们并没有真正解决在<a href="#模块化测试讨论">模块化测试讨论</a>中演示的任何模块化违规问题 ，但是我们不必中断项目，将其逻辑体系结构转换为适当的Java 9模块。接下来，我们将根目录的build.gradle项目中来集中gradle更改，并将其应用于所有子项目中。</p>
<h3 id="第2步-为所有子项目生成Java-9模块"><a href="#第2步-为所有子项目生成Java-9模块" class="headerlink" title="第2步 - 为所有子项目生成Java 9模块"></a>第2步 - 为所有子项目生成Java 9模块</h3><p>这一步的目标是让我们的Gradle构建中的所有子项目都生成Java 9模块，并将它们的依赖作为Java 9模块使用。由于您已将actors子项目中的build.gradle文件中的moduleName变量声明与其他改变分离，因此只需将该文件中的moduleName声明以后的所有内容剪切并粘贴到根目录build.gradle文件中的afterEvaluate代码块中即可。</p>
<p>build.gradle：</p>
<pre><code class="gradle">subprojects {
    afterEvaluate {
        repositories {
            jcenter()
        }

        compileJava {
            inputs.property(&quot;moduleName&quot;, moduleName)
            doFirst {
                options.compilerArgs = [
                    &#39;--module-path&#39;, classpath.asPath,
                ]
                classpath = files()
            }
        }

        compileTestJava {
            inputs.property(&quot;moduleName&quot;, moduleName)
            doFirst {
                options.compilerArgs = [
                    &#39;--module-path&#39;, classpath.asPath,
                    &#39;--add-modules&#39;, &#39;junit&#39;,
                    &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;,
                    &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.srcDirs).asPath,
                ]
                classpath = files()
            }
        }

        test {
            inputs.property(&quot;moduleName&quot;, moduleName)
            doFirst {
                jvmArgs = [
                    &#39;--module-path&#39;, classpath.asPath,
                    &#39;--add-modules&#39;, &#39;ALL-MODULE-PATH&#39;,
                    &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;,
                    &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.outputDir).asPath,
                ]
                classpath = files()
            }
        }
    }
}
</code></pre>
<blockquote>
<p>如果你做了步骤1的最后一步，则应在粘贴之前删除jar代码块。</p>
</blockquote>
<p>如果您还没有为每个子项目添加moduleName变量声明，那么现在应该这样做。例如：</p>
<p>pigs/build.gradle：</p>
<pre><code class="gradle">ext.moduleName = &#39;org.gradle.fairy.tale.pigs&#39;
</code></pre>
<p>您还需要为每个子项目添加一个module-info.java文件。例如：</p>
<p>bears/src/main/java/module-info.java:</p>
<pre><code class="gradle">module org.gradle.fairy.tale.bears {
    requires org.gradle.actors;
    requires transitive org.gradle.fairy.tale;
    requires org.gradle.fairy.tale.formula;

    exports org.gradle.fairy.tale.bears;
}
</code></pre>
<blockquote>
<p>您还需要为pigs， formula，fairy，和tale子项目添加这些module-info.java文件。最终结果应该看起来像src/2-all-modules中的代码。</p>
</blockquote>
<p>现在，Gradle的test任务将无法编译，除非您已将canReachDefaultActor测试注释掉。另外，canDynamicallyReachDefaultActor测试将在测试运行时失败，除非你添加@Ignore注释。</p>
<pre><code class="bash">$ ./gradlew test

&gt; Task :formula:test

org.gradle.fairy.tale.formula.ModularityTest &gt; canDynamicallyReachDefaultActor FAILED
    java.lang.IllegalAccessException at ModularityTest.java:28

2 tests completed, 1 failed


FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task &#39;:formula:test&#39;.
&gt; There were failing tests. See the report at: &lt;link-to-report&gt;

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
</code></pre>
<p>如果你注释掉canReachDefaultActor测试并为canDynamicallyReachDefaultActor添加@Ignore注解，剩下的测试应该通过，你可以在src/2-all-modules中得到完整的代码。</p>
<h4 id="第2步-总结"><a href="#第2步-总结" class="headerlink" title="第2步 - 总结"></a>第2步 - 总结</h4><p>到目前为止，你已经在使用Java 9模块来编译和运行所有六个子项目和测试。这些子项目被适当地封装，并且没有一个包下的测试可以看到这个包所依赖的任何实现细节。但是，<a href="https://docs.gradle.org/4.6/userguide/application_plugin.html?_ga=2.21328251.1136812865.1523857970-1287880600.1513842256" target="_blank" rel="noopener">Gradle的应用程序插件</a>的一些特性依赖于类路径来加载和编译类，而不是模块路径。</p>
<p>此外，Java 9增加了一种更方便的方式来使用ServiceLoader功能。您将在第3步中了解如何处理这些问题。</p>
<h3 id="第3步-在run和assemble任务中使用Java-9模块"><a href="#第3步-在run和assemble任务中使用Java-9模块" class="headerlink" title="第3步 - 在run和assemble任务中使用Java 9模块"></a>第3步 - 在run和assemble任务中使用Java 9模块</h3><p>现在所有子项目都已经转化为为Java 9模块，现在该学习fairy项目中的main class（org.gradle.fairy.app.StoryTeller）在运行时是如何使用这些模块的 。</p>
<p>运行本指南中介绍的应用程序有两种方式。首先是使用由<a href="https://docs.gradle.org/4.6/userguide/application_plugin.html?_ga=2.28841596.1136812865.1523857970-1287880600.1513842256" target="_blank" rel="noopener">应用程序插件</a>添加的Gradle run任务 。</p>
<pre><code class="bash">$ ./gradlew run

&gt; Task :fairy:run
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

&lt;... elided ...&gt;

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.


BUILD SUCCESSFUL
</code></pre>
<p>另一种方法是使用Gradle的assemble任务来分别打包各个应用程序，然后提取到某个目录并在那里运行。</p>
<pre><code class="bash">$ ./gradlew assemble

BUILD SUCCESSFUL
$ cp fairy/build/distributions/fair.tar /tmp
$ cd /tmp
$ tar xvf fairy.tar
x fairy/
x fairy/lib/
x fairy/lib/fairy.jar
x fairy/lib/pigs.jar
x fairy/lib/bears.jar
x fairy/lib/formula.jar
x fairy/lib/tale.jar
x fairy/lib/actors.jar
x fairy/lib/guava-22.0.jar
x fairy/lib/jsr305-1.3.9.jar
x fairy/lib/error_prone_annotations-2.0.18.jar
x fairy/lib/j2objc-annotations-1.1.jar
x fairy/lib/animal-sniffer-annotations-1.14.jar
x fairy/bin/
x fairy/bin/fairy
x fairy/bin/fairy.bat
$ ./bin/fairy
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

&lt;... elided ...&gt;

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.
</code></pre>
<p>在步骤2之后，这两种机制都依赖于出现在类路径上的模块。这样也就会跳过了Java 9模块系统的模块化特性。在这一步中，您将：</p>
<ol>
<li>修改run任务以使用模块。</li>
<li>修改startScript任务来使*nix和Windows系统使用模块。</li>
<li>将ServiceLoader机制更新为Java 9语法。</li>
</ol>
<p>一旦进行了更改1和2，运行该程序的两种机制都应该能直接运行，因此请随时再次运行这些命令以确认您已正确实施每项更改。</p>
<p>您依旧可以在资源代码库中的src/3-application目录中看到所有更改 。</p>
<h3 id="修改run任务以使用模块"><a href="#修改run任务以使用模块" class="headerlink" title="修改run任务以使用模块"></a>修改run任务以使用模块</h3><p>要在run任务中使用Java 9模块，你需要将以下内容添加到fairy项目中的build.gradle文件中。</p>
<p>fairy/build.gradle</p>
<pre><code class="gradle">mainClassName = &quot;$moduleName/org.gradle.fairy.app.StoryTeller&quot; //(1)

run {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        jvmArgs = [
            &#39;--module-path&#39;, classpath.asPath,
            &#39;--module&#39;, mainClassName //(2)
        ]
        classpath = files()
    }
}
</code></pre>
<ol>
<li>设置mainClassName属性包含moduleName。</li>
<li>明确告诉Java 9使用该模块。</li>
</ol>
<h4 id="修改startScript任务来使-nix和Windows系统使用模块。"><a href="#修改startScript任务来使-nix和Windows系统使用模块。" class="headerlink" title="修改startScript任务来使*nix和Windows系统使用模块。"></a>修改startScript任务来使*nix和Windows系统使用模块。</h4><p>在fairy/build/distributions目录中创建的tar和zip文件会包含启动脚本 ，这些脚本允许在所有支持的操作系统上，以可预测的方式启动JVM。</p>
<p>要修改已生成的startScripts，请将以下内容添加到您的fairy/build.gradle文件中：</p>
<p>fairy/build.gradle：</p>
<pre><code class="gradle">startScripts {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        classpath = files()
        defaultJvmOpts = [
            &#39;--module-path&#39;, &#39;APP_HOME_LIBS&#39;,  \\(1)
            &#39;--module&#39;, mainClassName
        ]
    }
    doLast{
        def bashFile = new File(outputDir, applicationName)
        String bashContent = bashFile.text
        bashFile.text = bashContent.replaceFirst(&#39;APP_HOME_LIBS&#39;, Matcher.quoteReplacement(&#39;$APP_HOME/lib&#39;))

        def batFile = new File(outputDir, applicationName + &quot;.bat&quot;)
        String batContent = batFile.text
        batFile.text = batContent.replaceFirst(&#39;APP_HOME_LIBS&#39;, Matcher.quoteReplacement(&#39;%APP_HOME%\\lib&#39;))
    }
}
</code></pre>
<ol>
<li>将模块路径设置为独立于平台的占位符值，稍后将以特定于平台的方式替换*nix shell脚本和Windows .bat文件。</li>
</ol>
<h3 id="将ServiceLoader机制更新为Java-9语法。"><a href="#将ServiceLoader机制更新为Java-9语法。" class="headerlink" title="将ServiceLoader机制更新为Java 9语法。"></a>将ServiceLoader机制更新为Java 9语法。</h3><p>Java 9模块系统引入了一种更好的方式来指定哪些模块为ServiceLoader机制提供服务的实现。首先，从两个目录bears/src/main和pigs/src/main中，删除resources文件夹，因为新机制不需要META-INF/services文件。</p>
<p>然后，调整每个项目的module-info.java文件。</p>
<p>fairy/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.fairy.app {
    requires org.gradle.fairy.tale;
    uses org.gradle.fairy.tale.Tale;
}
</code></pre>
<p>bears/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.fairy.tale.bears {
    requires org.gradle.actors;
    requires transitive org.gradle.fairy.tale;
    requires org.gradle.fairy.tale.formula;

    provides org.gradle.fairy.tale.Tale
        with org.gradle.fairy.tale.bears.GoldilocksAndTheThreeBears;
}
</code></pre>
<p>pigs/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.fairy.tale.pigs {
    requires org.gradle.actors;
    requires transitive org.gradle.fairy.tale;
    requires org.gradle.fairy.tale.formula;

    provides org.gradle.fairy.tale.Tale
            with org.gradle.fairy.tale.pigs.ThreeLittlePigs;
}
</code></pre>
<p>由于fairy项目中的module-info.java声明它使用org.gradle.fairy.tale.Tale服务，所以该模块中的ServiceLoader实例将有权访问，所有由Java 9模块声明的在运行时提供的org.gradle.fairy.tale.Tale服务实现。</p>
<h3 id="第4步-使用experimental-jigsaw插件来做与我们之间所做的同样的事情"><a href="#第4步-使用experimental-jigsaw插件来做与我们之间所做的同样的事情" class="headerlink" title="第4步 - 使用experimental-jigsaw插件来做与我们之间所做的同样的事情"></a>第4步 - 使用experimental-jigsaw插件来做与我们之间所做的同样的事情</h3><p>虽然Gradle尚未将Java 9模块构建作为Java插件的一级特性加以支持，实验性插件也可让您在项目中尝试使用Java 9模块。</p>
<p>org.gradle.java.experimental-jigsaw插件只是一个简便的机制，可以在一个步骤中，提供本指南步骤1至3中的所有更改。它可能适用于您的项目，但您应该考虑到它是实验性的，不适合生产版本。</p>
<p>以下是如何使用插件：</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">plugins {
    id &#39;java-library&#39;
    id &#39;org.gradle.java.experimental-jigsaw&#39; version &#39;0.1.1&#39;  \\(1)
}
</code></pre>
<ol>
<li>使用插件</li>
</ol>
<p>actors/build.gradle：</p>
<pre><code class="gradle">javaModule.name = &#39;org.gradle.actors&#39;  \\(1)
</code></pre>
<ol>
<li>使用新javaModule.name设置来指定模块名称。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时，您的应用程序正在利用Java 9模块系统的大部分功能。本指南向您展示了如何修改常规插件java-library和application所添加的任务，来方便你使用Java 9模块进行工作。未来，Gradle团队将为模块系统添加一流的支持，但您现在就已经可以开始尝试！</p>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
            <category> gradle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
            <tag> gradle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java模块系统综述]]></title>
      <url>/2018/03/29/module-system/</url>
      <content type="html"><![CDATA[<p><strong>本文是Mark Reinhold的The State of the Module System最新版的翻译。（<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<blockquote>
<p>这份文档略有过时。其基本概念没有任何改变，但requires public关键字已被重新命名为requires transitive，并增加了几项附加功能。更新正在准备中，准备就绪后会在这里发布。</p>
</blockquote>
<p>本文是对<a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Jigsaw项目</a>中对Java SE平台所做的增强的一个非正式的概述，并针对<a href="http://openjdk.java.net/projects/jigsaw/spec/" target="_blank" rel="noopener">JSR 376：Java平台模块系统</a>所提出。有<a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">相关的文档</a>描述了对特定于JDK工具和API的增强，这些超出了JSR的范围。</p>
<p>正如JSR所述，模块系统是为了提供可靠的配置，使程序组件相互显式的声明依赖，配合其强大的封装能力，使组件允许声明其中哪些公共类型可供其他组件访问，哪些不可以，并以此来替换脆弱，容易出错的类路径机制。</p>
<p>这些功能将直接对Java SE平台本身、Java应用程序开发人员，Java类库开发人员有利，而且也会间接地实现可伸缩平台、更高的平台完整性和更高的性能。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#定义模块">定义模块</a><ul>
<li><a href="#模块声明">模块声明</a></li>
<li><a href="#模块打包">模块打包</a></li>
<li><a href="#模块描述符">模块描述符</a></li>
<li><a href="#平台模块">平台模块</a></li>
</ul>
</li>
<li><a href="#使用模块">使用模块</a><ul>
<li><a href="#模块路径">模块路径</a></li>
<li><a href="#解决依赖">解决依赖</a></li>
<li><a href="#可读性">可读性</a></li>
<li><a href="#可访问性">可访问性</a></li>
<li><a href="#隐含的可读性">隐含的可读性</a></li>
</ul>
</li>
<li><a href="#兼容性和迁移">兼容性和迁移</a><ul>
<li><a href="#未命名模块">未命名模块</a></li>
<li><a href="#自下而上的迁移">自下而上的迁移</a></li>
<li><a href="#自动模块">自动模块</a></li>
<li><a href="#与类路径建立联系">与类路径建立联系</a></li>
</ul>
</li>
<li><a href="#服务">服务</a></li>
<li><a href="#高级特性">高级特性</a><ul>
<li><a href="#反射">反射</a></li>
<li><a href="#反射的可读性">反射的可读性</a></li>
<li><a href="#类加载器">类加载器</a></li>
<li><a href="#未命名模块与类加载器">未命名模块与类加载器</a></li>
<li><a href="#层">层</a></li>
<li><a href="#限制性导出">限制性导出</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<p>这是本文档的第二版。相对于<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/2015-09-08" target="_blank" rel="noopener">最初版本</a>，本版引入了兼容性和迁移的解释，修改了反射可读性的描述，进行了重新排序以改善叙述的流程，并且组织了更容易定位的目录。</p>
<p>文中仍然存在许多未解决的问题，其解决方案将反映在本文档的未来版本中。</p>
<h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>为了提供可靠的配置和强大的封装，使其既能接近开发人员，又能被现有工具链支持，我们将模块视为一种基本的新型Java程序组件。一个模块是一个命名的，能自我描述的代码和数据的集合。其代码被组织为一组包（package），包中包含Java类和接口。</p>
<h4 id="模块声明"><a href="#模块声明" class="headerlink" title="模块声明"></a>模块声明</h4><p>模块的自我描述体现在它的声明中，这是一种Java编程语言的新构造。最简单的模块声明只是指定其模块的名称：</p>
<pre><code class="java">module com.foo.bar { }
</code></pre>
<p>可以添加一个或多个require子句来声明该模块在编译时和运行时依赖于其他名称的某些模块：</p>
<pre><code class="java">module com.foo.bar {
    requires org.baz.qux;
}
</code></pre>
<p>最后，可以添加exports子句来声明该模块中仅有特定包中的公共类型可供其他模块使用：</p>
<pre><code class="java">module com.foo.bar {
    requires org.baz.qux;
    exports com.foo.bar.alpha;
    exports com.foo.bar.beta;
}
</code></pre>
<p>如果一个模块的声明不包含任何exports子句，那么它将不会导出任何类型到其他模块。</p>
<p>按照惯例，模块声明的源代码放置在名为module-info.java的文件中，该文件位于模块的源文件层次结构的根目录下。 com.foo.bar模块的源文件可能包括：</p>
<pre><code class="java">module-info.java
com/foo/bar/alpha/AlphaFactory.java
com/foo/bar/alpha/Alpha.java
...
</code></pre>
<p>按照惯例，模块声明被编译成名为module-info.class的文件，并放置在.class文件输出目录中。</p>
<p>模块名称跟包名称一样，不得相互冲突。命名模块的推荐方法是使用长期用于命名软件包的反向域名模式。因此，模块的名称通常就是其导出包名称的前缀，但这种关系不是强制性的。</p>
<p>模块的声明不包括其版本号，也不包括它所依赖的子模块的版本号。这样做是<a href="http://openjdk.java.net/projects/jigsaw/spec/reqs/02#version-selection" target="_blank" rel="noopener">故意为之</a>的：模块系统的目标不是解决版本选择问题，这最好留给构建工具和容器应用程序来做。</p>
<p>模块声明是Java编程语言的一部分，这其中的原因有几个。其中最重要的一点是，模块必须在编译时和运行时都可用，以实现各个阶段的确定性，即确保模块系统在编译时和运行时都以相同的方式工作。这反过来又能防止多种错误的发生，或者至少在编译时更早地报告错误使其更容易诊断和修复。</p>
<p>源文件中的模块声明文件和模块中的其他源文件，将会一起编译为.class文件供Java虚拟机使用，这是建立确定性的自然方式。这种方法将立即为开发人员所熟悉，并且IDE和构建工具也会很容易支持。尤其是IDE，可以依照依赖需要为现有组件提供模块声明的提示。</p>
<h4 id="模块打包"><a href="#模块打包" class="headerlink" title="模块打包"></a>模块打包</h4><p>现有工具已经可以创建，操作和使用JAR文件，因此为了便于使用和迁移，我们定义了模块化JAR文件。除了根目录中还包含了一个module-info.class文件之外，模块化的JAR文件就像普通的JAR文件一样。上述com.foo.bar模块的模块化JAR文件可能具有以下内容：</p>
<pre><code>META-INF/
META-INF/MANIFEST.MF
module-info.class
com/foo/bar/alpha/AlphaFactory.class
com/foo/bar/alpha/Alpha.class
...
</code></pre><p>模块化的JAR文件可以被当作模块，在这种情况下，它的module-info.class文件被用来作为模块的声明。它也可以被放在普通的类路径上，在这种情况下，它的module-info.class文件将被忽略。模块化JAR文件允许库的维护者在所有版本上发布工件（artifacts），该工件既可作为Java SE 9及更高版本的模块，也可作为类路径上的常规JAR文件。我们期望包含jar工具的Java SE 9的实现将增强该工具，以便轻松创建模块化JAR文件。</p>
<p>为了模块化Java SE平台的JDK，我们将引入一种新的打包机制（artifact format），它将超越JAR文件来容纳原生代码、配置文件和其他类型的数据（如果这种数据真的存在）。这种机制利用了在源文件中的模块声明并将它们编译成.class文件，此.class文件与其他的打包方式都不同。这种被临时命名为“JMOD”的新格式是否应该成为标准化仍旧是一个悬而未决的问题。（已成为Java9的标准格式之一，请查看<a href="https://docs.oracle.com/javase/9/tools/jmod.htm" target="_blank" rel="noopener">oracle官方文档</a>）</p>
<h4 id="模块描述符"><a href="#模块描述符" class="headerlink" title="模块描述符"></a>模块描述符</h4><p>将模块声明编译到.class文件中的最后一个优点是.class文件已经具有精确定义和可扩展的格式。因此，我们可以将module-info.class文件视为更通用的模块描述符，其中包括源代码级模块声明的编译形式，还包括在声明最初编译之后插入的.class文件中的附加信息。</p>
<p>例如，IDE、或者记录打包时间的工具，可以插入包含文档信息的属性，例如模块的版本、标题、说明和许可证。这些信息可以在编译时和运行时通过模块系统的反射来读取，以用于写文档，程序诊断和调试。它也可以被下游工具用于构建跨操作系统的程序包。特定的属性将被标准化，但由于Java类文件格式是可扩展的，所以其他工具和框架将能够根据需要来定义附加属性。非标准的属性不会影响模块系统本身的行为。</p>
<h3 id="平台模块"><a href="#平台模块" class="headerlink" title="平台模块"></a>平台模块</h3><p>Java SE 9的平台规范，使用模块系统将平台划分为一组模块。Java SE 9平台的实现可能包含所有的平台模块，或者可能仅包含其中的一部分。</p>
<p>在任何情况下，模块系统专用的唯一模块是已命名的基础模块java.base。基本模块定义并导出所有平台的核心软件包，包括模块系统本身：</p>
<pre><code class="java">module java.base {
    exports java.io;
    exports java.lang;
    exports java.lang.annotation;
    exports java.lang.invoke;
    exports java.lang.module;
    exports java.lang.ref;
    exports java.lang.reflect;
    exports java.math;
    exports java.net;
    ...
}
</code></pre>
<p>基本模块始终存在。每个其他模块都隐式的建立在基本模块之上，而基本模块则不依赖于其他模块。</p>
<p>其余的平台模块将共享“ java.”名称前缀，并有可能包括，例如，模块java.sql用于数据库连接， 模块java.xml用于XML处理，模块java.logging进行记录日志。按照惯例，尽管没有在Java SE 9平台规范中定义，但是专用于JDK的模块将共享“ jdk.”名称前缀。</p>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>单个模块可以在模块工件（artifacts）中定义，或者内嵌于编译时或运行时环境。要在任一阶段使用它们，模块系统必须定位它们，然后确定它们如何相互关联的，并以此提供可靠的配置和强大的封装。</p>
<h4 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h4><p>为了定位包中定义的模块，模块系统搜索由系统定义的模块路径（module path）。模块路径是一个序列，其中的每个元素都是模块工件或包含模块工件的目录。系统会按顺序搜索模块路径的元素，以找到定义合适的第一个模块工件。</p>
<p>模块路径（module path）与类路径（class path）有着很大的不同，它更加健壮。类路径的固有脆弱性是基于这样一个事实：即它是一种在所有包中通过路径来定位各个类型的工作方式，它不会在不同的包文件本身之间进行区分。这使得它无法预先知道程序什么时候缺少了某个包。它还允许不同的程序包（artifacts）在相同的包（package）中定义类型，即使这些程序包是只是版本不同，或者就是完全不同的组件（jar hell）。</p>
<p>相反，模块路径是定位整个模块、而不是某个类型的一种手段。如果模块系统无法满足来自模块路径的模块工件的特定依赖性，或者如果在同一目录中遇到定义相同名称模块的两个模块工件，则编译器或虚拟机将报告错误并退出。</p>
<p>内置于编译时或运行时环境的模块以及模块路径中的模块工件定义的模块统称为可观察模块的范围。</p>
<h4 id="解决依赖"><a href="#解决依赖" class="headerlink" title="解决依赖"></a>解决依赖</h4><p>假设我们有一个使用上述com.foo.bar模块和平台java.sql模块的应用程序。包含应用程序核心的模块声明如下：</p>
<pre><code class="java">module com.foo.app {
    requires com.foo.bar;
    requires java.sql;
}
</code></pre>
<p>鉴于这种初始应用程序模块，该模块系统可通过表达依赖性的requires来定位额外观察到的模块，以满足这些依赖关系，然后解决这些模块的依赖关系，并依此类推，直到每个模块的每一个的依赖都被满足。这个传递闭包计算的结果是一个模块图，对于每个依赖其他模块的模块，它包含从第一个模块到第二个模块的有向边。</p>
<p>要为模块com.foo.app构建模块图，模块系统将检查模块的声明java.sql，即：</p>
<pre><code class="java">module java.sql {
    requires java.logging;
    requires java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
</code></pre>
<p>它还会循环检查其声明的com.foo.bar模块（上面的模块定义中已经示出），包括org.baz.qux模块，java.logging模块和 java.xml模块; 为简洁起见，最后三个这里没有显示，因为它们没有声明对任何其他模块的依赖。</p>
<p>根据所有这些模块声明，为com.foo.app模块画出的模块图，包含以下节点和边：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-1.png" alt="module-pic-1"></p>
<p>在该图中，深蓝色线条表示显式依赖关系，如requires，而浅蓝色线条表示每个模块对基本模块的隐式依赖关系。</p>
<h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p>当一个模块直接依赖于模块图中的另一个模块时，则第一个模块中的代码将能够引用第二个模块中的类型。因此，我们说第一个模块读取第二个模块，或者等同地，第二个模块可以被第一个模块读取。因此，在上述的曲线图中，com.foo.app模块读取com.foo.bar和 java.sql模块，但并不读取org.baz.qux模块，java.xml模块或 java.logging模块。java.logging模块可由java.sql模块读取，但不能被其他模块读取。（根据定义，每个模块都会自行读取自己本身。）</p>
<p>在模块图中定义的可读性关系是可靠配置的基础 ：模块系统能确保每个依赖是由另一个模块完成的，模块图是非循环的，每个模块最多只能读取一个包含制定包的模块，这样定义相同名称包的模块就不会相互干扰。</p>
<p>这样的配置不仅更可靠，也可以更快。当模块中的代码引用包中的某个类型时，那么该包将保证在该模块中定义，或者只在该模块读取的模块中定义一个。因此，在寻找特定类型的定义时，不需要在多个模块中搜索它，或者更糟糕的，沿着整个路径搜索它。</p>
<h4 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h4><p>在模块图中定义的可读性关系与exports模块声明中的子句相结合，是强封装的基础：只有当某个模块被另一个模块读取时，Java编译器和虚拟机才会将这个模块中的包中的公共类型视为只能被另一个模块所访问，同时还需要这个模块导出该包。即，如果两种类型的S和T在不同的模块中定义的，并且T是 public，则如果代码S 可以存取 T，必须满足以下条件：</p>
<ol>
<li>S的模块读取T的模块，</li>
<li>T的模块导出T包。</li>
</ol>
<p>跨越模块边界的类型引用以及私有的方法和字段在这种情况下都是不可用的：任何尝试使用它的操作都将导致编译器报告错误，或者由Java虚拟机报出的IllegalAccessError，或者由反射运行时API引发的IllegalAccessException。因此，即使声明了一个类型public，如果它的包没有在其模块的声明中导出，那么它将只能被该模块中的代码访问。</p>
<p>如果模块中的封闭类型是可访问的，并且其成员本身也被声明成允许访问，那么跨模块也可以访问并引用到其方法或字段。</p>
<p>要了解上述模块图的封装是如何工作的，我们标记出每个模块导出的包：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-2.png" alt="module-pic-2"></p>
<p>模块com.foo.app中的代码可以访问com.foo.bar.alpha包中声明的公共类型， 因为模块com.foo.app依赖于模块com.foo.bar，并且因为模块com.foo.bar导出com.foo.bar.alpha包。如果com.foo.bar包含内部程序包（internal package），即com.foo.bar.internal包，则模块com.foo.app不能访问该com.foo.bar.internal包中的任何类型，因为com.foo.bar并没有导出这个内部包。模块com.foo.app中的代码也不能引用org.baz.qux包中的类型，因为模块com.foo.app不依赖于模块org.baz.qux，因此不会读取它（在这个例子中，模块的依赖并不能传递）。</p>
<h4 id="隐含的可读性"><a href="#隐含的可读性" class="headerlink" title="隐含的可读性"></a>隐含的可读性</h4><p>如果一个模块读取另一个模块，则在某些情况下，它也能符合逻辑地读取其他一些模块。</p>
<p>例如，平台的java.sql模块依赖于java.logging模块和java.xml模块，不仅因为它包含了这些模块中的类型的代码实现，还因为它直接声明使用了这些模块中的类型。java.sql.Driver接口声明了一个公共的方法：</p>
<pre><code class="java">public Logger getParentLogger();
</code></pre>
<p>其中Logger是在java.logging模块所导出的包java.util.logging中声明的类型。</p>
<p>假设，例如，com.foo.app模块中的代码调用此方法来获取日志，然后记录一条消息：</p>
<pre><code class="java">String url = ...;
Properties props = ...;
Driver d = DriverManager.getDriver(url);
Connection c = d.connect(url, props);
d.getParentLogger().info(&quot;Connection acquired&quot;);
</code></pre>
<p>如果com.foo.app模块像为如上所述声明，那么这样的代码将不起作用：该getParentLogger方法返回另一个模块java.logging中所声明的Logger类型，而模块com.foo.app并没有读取模块java.logging ，因此调用java.logging模块中Logger类的info方法将会失败，因为该类以及该方法无法访问。</p>
<p>解决这个问题的一个方法寄希望于每一位开发者在依赖java.sql模块并使用getParentLogger方法Logger类的同时，还必须记得声明对java.logging模块的依赖。当然，这样的方式是不可靠的，因为它违反了最小意外原则（principle of least surprise）：如果一个模块依赖于第二个模块，那么很自然的我们会期望去使用第一个模块中的所有属性，包括在第二的模块中声明的属性，也会在我们依赖第一个模块是变得立即可见（即模块依赖的传递性）。</p>
<p>因此，我们扩展了模块声明，以便一个模块可以将附加模块的可读性授予依赖它的任何模块。这种隐含的可读性通过requires public子句来表达（在正式版的jdk中已经被更新为requires transitive）。java.sql模块的声明实际上是这样的：</p>
<pre><code class="java">module java.sql {
    requires public java.logging;
    requires public java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
</code></pre>
<p>该public关键字是指，任何依赖于模块java.sql的模块，不仅仅会读取java.sql模块，也会读取java.logging模块和java.xml模块。因此，上述com.foo.app模块的模块图，包含两个额外的深蓝色边缘，通过绿色边缘链接到java.sql模块，因为java.logging模块和java.xml模块被该模块隐性的依赖：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-moudle-3.png" alt="module-pic-3"></p>
<p>com.foo.app模块现在可以包含访问java.logging模块和java.xml模块的导出包中的所有公共类型的代码，即使其声明中没有提及这些模块。</p>
<p>一般而言，如果一个模块的导出包引用了了另一个模块中的包的类型，则第一个模块应该使用requires public子句来声明对第二个模块的依赖。这将确保依赖于第一个模块的其他模块将自动读取第二个模块，从而访问该模块的导出包中的所有类型。</p>
<h3 id="兼容性和迁移"><a href="#兼容性和迁移" class="headerlink" title="兼容性和迁移"></a>兼容性和迁移</h3><p>到目前为止，我们已经看到如何从头开始定义模块，将它们打包到模块工件中，并将它们与其他模块一起使用，这些模块既可以嵌入到平台中，也可以直接在包中定义。</p>
<p>当然，大多数Java代码是在引入模块系统之前编写的，并且必须继续像现在一样继续工作，而不用更改（向下兼容）。因此，即使平台本身由模块组成，模块系统也应该可以在类路径上编译和运行由JAR文件组成的应用程序。它还允许将现有应用程序以灵活和渐进的方式迁移到模块化形式。</p>
<h4 id="未命名模块"><a href="#未命名模块" class="headerlink" title="未命名模块"></a>未命名模块</h4><p>如果我们的需求时在加载一个其所在的包未再任何已知的模块中声明的类型，则模块系统将尝试从类路径加载它。如果成功，那么该类型会被认为成为一个，被称为未命名模块的特殊模块中的成员，以确保每个类型都与某个模块相关联。未命名模块在高层次上类似于现有概念中的未命名包。当然，所有其他模块都有名称，所以我们今后将把它们称为命名模块。</p>
<p>未命名模块读取所有的其他模块。因此，从类路径加载的任何类型的代码，都将能够访问所有其他可读模块的导出类型，默认情况下，该模块将包含所有内置的已命名平台模块。因此，编译并在Java SE 8上运行的现有类路径应用程序将在Java SE 9上以完全相同的方式进行编译和运行，只要它使用的是标准的，未弃用的Java SE API即可。</p>
<p>未命名的模块默认导出其所有软件包。这可以实现灵活的迁移。但是，它并不意味着命名模块中的代码可以访问未命名模块中的类型。实际上，命名模块甚至不能声明对未命名模块的依赖。这种限制是故意的，因为如果允许命名模块依赖于类路径的任意内容，就不可能实现可靠的配置。</p>
<p>如果在命名模块和未命名模块中都定义了同样名字的包，那么未命名模块中的包将被忽略。即使类路径十分混乱，这种可靠的配置，仍能确保每个模块最多只能读取一个模块来提供你所需要的包。如果在上面的示例中，类路径上的JAR文件，包含一个名为，com/foo/bar/alpha/AlphaFactory.class的.class文件，那么该文件将永远不会被加载，因为包com.foo.bar.alpha 是由模块com.foo.bar导出的。</p>
<h4 id="自下而上的迁移"><a href="#自下而上的迁移" class="headerlink" title="自下而上的迁移"></a>自下而上的迁移</h4><p>从类路径加载的类型作为未命名模块中的成员，这种处理将允许我们自下而上的，将现有的应用程序从JAR文件形式迁移到模块化的形式。</p>
<p>例如，上面显示的应用程序最初是为Java SE 8构建的，因为它是放置在类路径上的一组JAR文件。如果我们在Java SE 9上按原样运行它，那么JAR文件中的类型将在未命名的模块中定义。该模块将读取所有其他模块，包括所有内置平台模块; 为简单起见，假设那些被读取的模块被限制为java.sql模块，java.xml模块， java.logging模块和java.base模块。因此我们获得如下的模块图：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-4.png" alt="module-pic-4"></p>
<p>我们可以立即将org-baz-qux.jar转换为命名模块，因为我们知道它不会引用其他两个JAR文件中的任何类型，因此作为命名模块，它也不会引用未命名模块中的任何类型。（这是因为我们刚刚从最初的例子中知道了这一点。如果我们不知道它时候引用未命名模块的话，我们可以借助诸如类似jdeps的工具来发现它。）</p>
<p>我们编写一个模块声明为org.baz.qux，将其添加到模块的源代码中，编译并将结果打包为模块化JAR包。如果我们将该JAR文件放在模块路径上，并将其他类放在类路径上，我们将获得改进的模块图：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-5.png" alt="module-pic-5"></p>
<p>com-foo-bar.jar和com-foo-app.jar中的代码会继续工作，因为未命名的模块会读取每个已命名的模块，这个未命名模块现在包含新模块org.baz.qux。</p>
<p>我们可以类似地进行模块化com-foo-bar.jar，然后接着模块化com-foo-app.jar最终结束预期的模块图，如前所示：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-6.png" alt="module-pic-6"></p>
<p>如果我们了解原始JAR文件中的类型所做的工作，我们当然可以在一个步骤中将它们全部三个模块化。然而，如果 org-baz-qux.jar是独立维护的，或许由完全不同的团队或组织来维护，那么它可以在其他两个组件之前模块化，并且在com-foo-app.jar模块化之前也可以模块化com-foo-bar.jar。</p>
<h4 id="自动模块"><a href="#自动模块" class="headerlink" title="自动模块"></a>自动模块</h4><p>自下而上的迁移很简单，但并非总是可行的。即使org-baz-qux.jar的维护者尚未将其转换为适当的模块，或者可能永远不会，我们仍然可能想要将模块化com-foo-app.jar和com-foo-bar.jar。</p>
<p>我们已经知道代码是com-foo-bar.jar依赖org-baz-qux.jar。但是，如果我们转换com-foo-bar.jar为命名模块com.foo.bar，但留org-baz-qux.jar在类路径中，那么该代码将不再起作用：org-baz-qux.jar将继续在未命名模块中定义，但com.foo.bar是一个命名模块，它不能声明依赖于未命名模块。</p>
<p>那么，我们必须以某种方式安排org-baz-qux.jar作为一个命名模块出现，以便com.foo.bar可以依赖它。我们可以fork org.baz.qux的源代码并将其模块化，但是如果维护人员不愿意将该更改合并到上游存储库中，那么只要我们需要它，我们就必须维护这个分支。</p>
<p>因此，我们将把org-baz-qux.jar作为一个自动模块，不加修改地放在模块路径上，而不是类路径上。这将定义一个可观察模块，其模块名称，org.baz.qux来源于JAR文件的名称，以便其他非自动模块可以通常的方式依赖它：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-7.png" alt="module-pic-7"></p>
<p>自动模块是一个隐式定义的命名模块，因为它没有模块声明。相比之下，普通的命名模块是通过模块声明明确定义的; 我们今后将把它们称为显式模块。</p>
<p>没有方法可以预先告诉自动模块可能依赖哪些其他模块。因此，在模块图解析完成后，自动模块将读取每个其他命名模块，无论是自动模块还是显式模块：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-8.png" alt="module-pic-8"></p>
<p>（这些新的可读性边在模块图中创建了循环，这使得推理起来有些困难，但我们认为这些是可以容忍的，而且通常是为了实现更灵活迁移所导致的临时结果。）</p>
<p>类似地，没有方法可以告诉自动模块中的哪些包打算供其他模块使用，或者仍旧是通过类路径上的类继续使用。因此，即使自动模块中的每个软件包只用于内部使用，也会被视为导出：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-9.png" alt="module-pic-9"></p>
<p>现在com.foo.app中的代码可以访问org.baz.qux中的类型，尽管我们知道它实际上并没有这样做。</p>
<p>自动模块提供了混乱的类路径和显式模块规则之间的中间地带。它们允许将由JAR文件组成的现有应用程序从上到下迁移到模块，如上所示，或者以自上而下和自下而上的方法组合来迁移。通常，我们可以从类路径上的任意一组JAR文件开始，使用一个工具jdeps来分析它们之间的依赖关系，将我们控制的源代码组件转换为显式模块，然后将剩余的JAR文件按原样放在模块路径中。我们不控制源代码的JAR文件将被视为自动模块，直到它们也转换为显式模块为止。</p>
<h4 id="与类路径建立联系"><a href="#与类路径建立联系" class="headerlink" title="与类路径建立联系"></a>与类路径建立联系</h4><p>许多现有的JAR文件可以用作自动模块，但有些不能。如果类路径上的两个或多个JAR文件包含同一个包中的类型，那么最多可以有其中的一个来用作自动模块，因为模块系统仍然保证每个命名模块至多读取一个包含了需要的包的命名模块，以保证定义了相同名称包的命名模块不会相互干扰。在这种情况下，我们经常会发现实际上，我们只需要其中一个JAR文件。如果其他的JAR文件重复或接近重复，并以某种方式错误地放在类路径上，则可以将其中一个用作自动模块，其他的JAR文件就会被舍弃。但是，如果类路径上的多个JAR文件有意包含在同一个包中的类型，那么它们必须都保留在类路径中（即作为一个在类路径上的未命名模块而非在模块路径上的自动模块）。</p>
<p>因为这些JAR文件不能用作自动模块，为了启用迁移，我们会将自动模块，视为建立在显式模块和仍然处于类路径上的代码（未命名模块）之间的桥梁：自动模块除了读取其他所有命名模块之外，还将读取未命名的模块。如果我们的应用程序的原始类路径中，包含了JAR文件org-baz-fiz.jar和org-baz-fuz.jar，那么我们将有图：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-10.png" alt="module-pic-10"></p>
<p>如前所述，未命名模块导出其所有软件包，因此自动模块中的代码将能够访问所有从类路径加载的公用类型（即未命名模块中的所用公共类型）。</p>
<p>使用类路径中的类型的自动模块，不能将这些类型暴露给其他依赖于它的显式模块，因为显式模块无法声明对未命名模块的依赖关系。如果显式模块com.foo.app中的代码引用了一个自动模块com.foo.bar中的公共类型，并且自动模块com.foo.bar明确声明使用了仍在类路径上的一个JAR文件中的类型，则com.foo.app中的代码将无法访问该类路径上的类型，因为命名模块com.foo.bar不能依赖于未命名的模块。这可以通过将模块com.foo.app暂时视为自动模块来解决，以便其代码可以访问类路径中的类型，直到类路径上的相关JAR文件（未命名模块）可以被视为自动模块或转换为显式模块为止。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>利用服务接口和服务提供者的松散耦合是构建大型软件系统的强大工具。Java通过<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_blank" rel="noopener">java.util.ServiceLoader</a>类来支持服务，该类在运行时通过搜索类路径来定位服务提供者。对于在模块中定义的服务提供者，我们必须考虑如何在一组可观察模块中找到这些模块，解决它们的依赖性，并使提供者可以使用使用相应服务的代码。</p>
<p>假设，例如，我们的com.foo.app模块使用MySQL数据库，并且在具有声明的可观察模块中提供MySQL JDBC驱动程序</p>
<pre><code class="java">module com.mysql.jdbc {
    requires java.sql;
    requires org.slf4j;
    exports com.mysql.jdbc;
}
</code></pre>
<p>其中org.slf4j是驱动程序（jdbc driver）使用的日志记录库，并且com.mysql.jdbc是包含java.sql.Driver这一服务接口的具体实现的包。（实际上并不需要导出驱动程序包，我们这样做是为了使代码清晰可见。）</p>
<p>为了让java.sql模块使用这个驱动程序， ServiceLoader类必须能够通过反射来实例化驱动程序类; 为了实现这一点，模块系统必须将驱动模块添加到模块图中并解决其依赖性，因此：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-11.png" alt="module-pic-11"></p>
<p>为了实现这一点，模块系统必须能够识别所有使用服务的模块，然后从一组可观察模块中找到服务的提供者。</p>
<p>模块系统可以通过，扫描模包中的类文件并调用ServiceLoader::load方法，来识别对服务的使用，但是这样做不仅会很慢，而且并不可靠。模块使用特定服务应该是是模块的一个基本定义，所以为了效率和清晰度，我们在模块的声明中用一个uses子句来表示对服务的使用：</p>
<pre><code class="java">module java.sql {
    requires public java.logging;
    requires public java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
    uses java.sql.Driver;
}
</code></pre>
<p>模块系统可以通过扫描META-INF/services资源条目来识别服务提供者，就像现在ServiceLoader类所做的那样。但是，模块提供特定服务借口的具体实现同样很重要，所以我们在模块的声明中用一个provides子句表示模块的提供者：</p>
<pre><code class="java">module com.mysql.jdbc {
    requires java.sql;
    requires org.slf4j;
    exports com.mysql.jdbc;
    provides java.sql.Driver with com.mysql.jdbc.Driver;
}
</code></pre>
<p>现在，只要阅读这些模块的声明，就很容易看出来，其中一个m模块使用另一个提供的服务。</p>
<p>在模块声明中声明服务提供者和服务使用者的关系具有提高效率和代码清晰度的优势。这两种服务声明都可以在编译时进行解释，以确保服务提供者和服务使用者都可以访问服务接口（例如，java.sql.Driver）。服务提供者声明可以进一步解释，以确保提供者（例如，com.mysql.jdbc.Driver）确定实现其宣称的服务接口。服务使用的声明可以通过工具来提前编译，以确保在运行之前服务提供者能恰当的被编译。</p>
<p>出于迁移目的，如果定义自动模块的JAR文件包含META-INF/services资源条目，则将每个这样的条目视为该模块中的provides关键字的对应子句。自动模块被认为可以使用每一种可用的服务。</p>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p>本文档的其余部分讨论了高级特性，这些特性虽然很重要，但大多数开发人员可能并不感兴趣。</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>为了使模块图在运行时反射也可用，我们在java.lang.reflect包中定义了一个叫Module类，并在一个新的包java.lang.module中定义一些相关类型。Module类的一个实例在运行时代表一个单独的模块。每个类型都在一个模块中，因此每个Class对象都有一个关联的Module对象，该对象由新Class::getModule方法返回。</p>
<p>Module对象的基本操作是：</p>
<pre><code class="java">package java.lang.reflect;

public final class Module {
    public String getName();
    public ModuleDescriptor getDescriptor();
    public ClassLoader getClassLoader();
    public boolean canRead(Module target);
    public boolean isExported(String packageName);
}
</code></pre>
<p>其中ModuleDescriptor是java.lang.module包中的类，它的实例表示模块描述符; getClassLoader方法返回模块的类加载器; canRead方法告诉模块是否可以读取目标模块; isExported方法告诉模块是否导出给定的包。</p>
<p>java.lang.reflect包并不是平台上唯一的反射工具。相似的工具也被添加到javax.lang.model模块，为了支持编译时的注释处理和文档生成工具。</p>
<h4 id="反射的可读性"><a href="#反射的可读性" class="headerlink" title="反射的可读性"></a>反射的可读性</h4><p>框架是使用反射来加载，检查，并在运行时实例化的其他类的工具。Java SE平台本身的框架示例是服务加载器，资源包，动态代理和序列化，当然还有许多流行的外部框架库，用于数据库持久性，依赖注入和测试等多种用途。</p>
<p>鉴于需要在运行时发现类，框架必须能够访问其构造函数之一以实例化它。但事实表明，情况通常不会如此。</p>
<p>Java平台的<a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/package-summary.html" target="_blank" rel="noopener">XML解析器</a>，如果<a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/XMLInputFactory.html#newFactory--" target="_blank" rel="noopener">加载和实例化</a>由系统配置命名为javax.xml.stream.XMLInputFactory的<a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/XMLInputFactory.html" target="_blank" rel="noopener">XMLInputFactory</a>的服务实现，它就将通过ServiceLoader类，优先于所有服务提供者发现被发现。忽略异常处理和安全检查的代码大致如下所示：</p>
<pre><code class="java">String providerName
    = System.getProperty(&quot;javax.xml.stream.XMLInputFactory&quot;);
if (providerName != null) {
    Class providerClass = Class.forName(providerName, false,
                                        Thread.getContextClassLoader());
    Object ob = providerClass.newInstance();
    return (XMLInputFactory)ob;
}
// Otherwise use ServiceLoader
...
</code></pre>
<p>在模块化设置中，只要包含的服务提供者的类为上下文类加载器所知，Class::forName就仍将继续工作。但是，通过反射的方式调用服务提供者的newInstance方法将不起作用：服务提供者可能会从类路径加载，在这种情况下，它将位于未命名的模块中，或者它可能位于某个已命名的模块中，无论是哪种情况，我们的框架本身都在java.xml模块中。该模块仅依赖于基本模块，因此也只读取基本模块，此框架将无法访问任何其他模块中的服务提供者类。</p>
<p>为了使框架可以访问服务提供者类，我们需要使框架的模块可以读取服务提供者的模块。我们可以要求每个框架在运行时都明确地，将必要的可读性边缘添加到模块图中，就像本文档的早期版本一样，但是经验表明这种方法很麻烦并且会导致迁移的障碍。</p>
<p>因此，我们需要修改反射API，我们假设任何反射其他类型的代码，都位于一个可以访问到被反射类型所在模块的模块中。这使得上面的例子和其他类似的代码可以毫无改变地工作。这种方法不会削弱强封装：公开类型仍然必须位于导出的包中，以便从其所在模块外部进行访问，无论是通过编译代码还是通过反射。</p>
<blockquote>
<p>事实上，在这种需要发射其他模块的情况下，如果我们只想要反射共有类型，那只要在模块中导出相应的包就可以；但如果我们想要通过setAccessible(true)方法来反射私有类型是，必须在模块声明时添加open关键字或者opens子句，来使模块成为一个开放模块或者开放模块中的软件包，使反射对私有类型可见，否则就会在运行报出Accessing Error。这一点原作者并未提及，我个人认为这种设计很好的保证了模块的强封装的特性</p>
</blockquote>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>每个类型都在一个模块中，并且在运行时每个模块都有一个类加载器，但是类加载器是否只加载一个模块呢？事实上，模块系统对模块和类加载器之间的关系几乎没有限制。一个类加载器可以从一个模块或多个模块加载类型，只要这些模块不相互干扰，并且只有一个加载器加载了特定模块中的所有类型。</p>
<p>这种灵活性对于兼容性至关重要，因为它允许我们保留平台现有的内置类加载器的层次结构。引导类加载器（bootstrap classloader）和扩展类加载器（extension classloader）仍然存在，并用于从平台模块加载类型。应用程序类加载器（application classloader）仍然存在，用于从工件的模块路径中找到加载类型。</p>
<p>这种灵活性还会使模块化现有应用程序变得更加容易，这些应用程序已经构建了复杂的层次结构甚至自定义类加载器，因次我们可以将这些加载器升级到模块中的加载类型，而无需更改其委托模式。</p>
<blockquote>
<p>事实上，Java9的classloader是有改变的，这一部分我以后会单独写一篇文章来总结。如现在想了解请参考<a href="http://www.cnblogs.com/IcanFixIt/p/7131676.html" target="_blank" rel="noopener">此链接</a>中的扩展机制部分</p>
</blockquote>
<h4 id="未命名模块与类加载器"><a href="#未命名模块与类加载器" class="headerlink" title="未命名模块与类加载器"></a>未命名模块与类加载器</h4><p>我们之前了解到，如果某个类型未在命名模块中定义，那么它将被视为未命名模块的成员，但与未命名模块相关的是哪个类加载器呢？</p>
<p>事实证明，每个类加载器都有自己独特的未命名模块，它是由新ClassLoader::getUnnamedModule方法返回的。如果一个类加载器加载了一个没有在命名模块中定义的类型，那么该类型就被认为是在该加载器的未命名模块中。例如，Class类中的getModule方法将返回其加载器的未命名模块。应用加载器（application classloader）的未命名模块，会从类路径中加载不在任何模块下定义的包中的类型。</p>
<h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>模块系统并不指定模块和类加载器之间的关系，但为了加载特定的类型，它必须以某种方式能够找到合适的加载器。因此，在运行时，模块图的实例化会生成一个层（layer），这个层将图中的每个模块映射到负责加载该模块中的类型的唯一类加载器上。与可被发现的模块相反，引导层（boot layer）是由Java虚拟机在启动时通过解析应用程序的初始模块所创建的。</p>
<p>大多数应用程序以及几乎当前所有的应用程序都不会使用引导层以外的层。然而，多个层可用于带有插件的复杂应用程序或容器体系结构（如应用程序服务器，IDE和测试框架）。这样的应用程序可以使用动态的类加载和模块系统的反射API，来加载和运行由一个或多个模块组成的应用程序。然而，这通常需要添加两种额外的灵活性：</p>
<ol>
<li><p>使用模块的应用程序可能需要不同版本的已存在的模块。例如，Java EE Web应用程序可能需要java.xml.ws模块中的不同版本的JAX-WS，而不是内置于运行时环境的版本。</p>
</li>
<li><p>使用模块的应用程序可能需要已经被发现的服务提供者以外的服务提供者。应用程序甚至可能嵌入自己的首选服务提供者。Web应用程序，可能包含一个它所期望的<a href="https://github.com/FasterXML/woodstox" target="_blank" rel="noopener">Woodstox XML解析器</a>版本，在这种情况下，ServiceLoader类应优先返回它需要的服务提供者而不是任何其他的服务提供者。</p>
</li>
</ol>
<p>与可被发现的模块的环境相反，一个容器应用程序可以为一个使用模块的应用程序的初始模块，在其已有的层上创建一个新的层。这样的环境可以包含可升级平台模块的替代版本以及其他已存在于较低层的非平台模块，解析器优先解析这些备用模块。这种环境也可以在那些已经在较低层被发现的服务提供者之外发现不同的服务提供者; ServiceLoader类将在较低层返回服务提供者之前去加载这些服务提供者。</p>
<p>层可以堆叠：我们可以在引导层之上构建新层，然后再在其上创建另一个层。作为正常解析过程的结果，所指定的层中的模块可以读取该层中或下层中的模块。因此，层的模块图可以通过引用包括其下的每个层的模块图来表示。</p>
<blockquote>
<p>上面这一节翻译的不太好，事实上我也不太理解这一节的内容。以后会仔细研究一下，目前只知道现在JDK中已经有了ModuleLayer类，可以通过Module.getLayer()获得。</p>
</blockquote>
<h4 id="限制性导出"><a href="#限制性导出" class="headerlink" title="限制性导出"></a>限制性导出</h4><p>偶尔有必要安排某些类型在一组模块中可访问，但其他模块无法访问。</p>
<p>在标准JDK的java.sql模块和 java.xml模块的代码实现中，使用了java.base模块中的sun.reflect包下定义的类型 。为了让代码访问sun.reflect包中的类型，我们可以简单地从java.base模块中导出该包：</p>
<pre><code class="java">module java.base {
    ...
    exports sun.reflect;
}
</code></pre>
<p>然而，这将使得每个sun.reflect包中的类型对所有模块都可见（因为每个模块都读取java.base），而这是不合理的，因为该包中的一些类定义了有特权的，安全敏感的方法。</p>
<p>因此，我们扩展了模块声明以允许将包导出到一个或多个特定命名的模块，而不被其他模块可见。java.base模块的声明实际上只将sun.reflect包导出到特定的一组JDK模块：</p>
<pre><code class="java">module java.base {
    ...
    exports sun.reflect to
        java.corba,
        java.logging,
        java.sql,
        java.sql.rowset,
        jdk.scripting.nashorn;
}
</code></pre>
<p>通过在模块图中添加另一种类型的边缘（此处为彩色金色），可以将这些限制性的导出显示在模块图中：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-12.png" alt="module-pic-12"></p>
<p>前面提到的可访问性规则如下所述：如果两种类型S并且T在不同模块中定义，并且T是public，则代码S可以在以下情况下访问T：</p>
<ol>
<li>S的模块读取T的模块，和</li>
<li>T的模块直接导出T的包到S的模块，亦或是导出到所有模块。</li>
</ol>
<p>我们为用于反射的Module类提供了一种方法，来确定是否将包导出到特定模块，而非所有模块：</p>
<pre><code class="java">public final class Module {
    ...
    public boolean isExported(String packageName, Module target);
}
</code></pre>
<p>限制性的导出可能会意外地将内部的类型到处到预期之外的模块，因此我们必须小心使用它们。例如命名一个名为java.corba的模块以访问sun.reflect包中的类型。为了防止这种情况，我们可以在构建时分析相关模块，并在每个模块的描述符中记录允许依赖它的模块内容的哈希值，并使用限制性导出。在分析期间，我们需要验证，那些使用限制性导出到其他命名模块的模块，其模块内容的哈希值，与引用该模块的模块中记录的该模块的哈希值匹配。只要声明和使用限制性的导出的模块以这种方式绑定在一起，限制性的导出就可以安全地在不受信任的环境中使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里描述了模块系统的很多方面，但大多数开发人员只需要使用其中的一部分。我们期望在未来几年内，大多数Java开发人员都会熟悉模块声明，模块化JAR文件，模块路径，可读性，可访问性，未命名模块，自动模块和模块化服务等基本概念。相比之下，反射可读性，层和限制性的导出等更高级功能可能被使用的可能性比较小。</p>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Project Jigsaw:Java模块系统快速入门指南]]></title>
      <url>/2018/03/29/java9-quick-guide/</url>
      <content type="html"><![CDATA[<p><strong>本文为openjdk官方java模块入门指南的翻译。(<a href="http://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener">原文地址</a>)</strong></p>
<p>本文档提供了一些让开发者快速上手Java模块系统的简单例子。<br>例子中的文件路径用/划分，文件分隔符是：，windows开发者请用\和；替换以上分隔符。</p>
<h3 id="Greetings"><a href="#Greetings" class="headerlink" title="Greetings"></a>Greetings</h3><p>第一个例子展示了一个打印”Greetings!”字符串的简单模块。这个模块由两个源文件组成（module-info.java和Main.java）。按照惯例，模块的源文件应该在一个以模块名字为命名的目录中。</p>
<pre><code class="java">src/com.greetings/com/greetings/Main.java
src/com.greetings/module-info.java

$ cat src/com.greetings/module-info.java
module com.greetings { }

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;
public class Main {
    public static void main(String[] args) {
        System.out.println(&quot;Greetings!&quot;);
    }
}
</code></pre>
<p>以下命令会将源文件编译到mods/com.greetings目录中：</p>
<pre><code class="bash">$ mkdir -p mods/com.greetings

$ javac -d mods/com.greetings \
    src/com.greetings/module-info.java \
    src/com.greetings/com/greetings/Main.java
</code></pre>
<p>现在我们用以下命令来运行这个例子：</p>
<pre><code class="bash">$ java --module-path mods -m com.greetings/com.greetings.Main
</code></pre>
<p>–module-path 是模块的路径，他的值是包含模块的一个或多个目录。<br>-m 指定了主模块，/后面的值是模块里包含main方法的全类名。</p>
<h3 id="Greetings-world"><a href="#Greetings-world" class="headerlink" title="Greetings world"></a>Greetings world</h3><p>第二个例子更新了第一个例子中的模块声明，它声明了需要一个名为org.astro的模块的依赖。<br>模块org.astro导出了名为org.astro的api包。</p>
<pre><code class="java">src/org.astro/module-info.java
src/org.astro/org/astro/World.java
src/com.greetings/com/greetings/Main.java
src/com.greetings/module-info.java

$ cat src/org.astro/module-info.java
module org.astro {
    exports org.astro;
}

$ cat src/org.astro/org/astro/World.java
package org.astro;
public class World {
    public static String name() {
        return &quot;world&quot;;
    }
}

$ cat src/com.greetings/module-info.java
module com.greetings {
    requires org.astro;
}

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;
import org.astro.World;
public class Main {
    public static void main(String[] args) {
        System.out.format(&quot;Greetings %s!%n&quot;, World.name());
    }
}
</code></pre>
<p>依次编译这两个模块，用javac命令在编译com.greetings模块时指定模块的路径，使得org.astro模块中的引用和其导出包中的类型可以被引用。</p>
<pre><code class="bash">$ mkdir -p mods/org.astro mods/com.greetings

$ javac -d mods/org.astro \
    src/org.astro/module-info.java src/org.astro/org/astro/World.java

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
</code></pre>
<p>使用与第一个例子相同的方式来运行这个例子：</p>
<pre><code class="bash">$ java --module-path mods -m com.greetings/com.greetings.Main
Greetings world!
</code></pre>
<h3 id="多模块编译"><a href="#多模块编译" class="headerlink" title="多模块编译"></a>多模块编译</h3><p>在上面的例子中，模块com.greetings和模块org.astro是分开编译的，我们也可以用一条javac命令来编译多个模块</p>
<pre><code class="bash">$ mkdir mods

$ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)

$ find mods -type f
mods/com.greetings/com/greetings/Main.class
mods/com.greetings/module-info.class
mods/org.astro/module-info.class
mods/org.astro/org/astro/World.class
</code></pre>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在目前的实例中，编译好的模块都分散在文件系统中，为了调度和部署，我们通常会把模块打包成模块化jar包，模块化jar包就是在jar包最顶层目录包含module-info.class的普通jar包。</p>
<p>以下命令将会在mlib目录中创建org.astro@1.0.jar和com.greetings.jar</p>
<pre><code class="bash">$ mkdir mlib

$ jar --create --file=mlib/org.astro@1.0.jar \
    --module-version=1.0 -C mods/org.astro .

$ jar --create --file=mlib/com.greetings.jar \
    --main-class=com.greetings.Main -C mods/com.greetings .

$ ls mlib
com.greetings.jar   org.astro@1.0.jar
</code></pre>
<p>在这个例子中，模块org.astro在打包时被指定了其版本号1.0，模块com.greetings在打包时被制定了其main方法主类com.greetings.Main。</p>
<p>现在，我们可以直接运行模块com.greetings而无需制定其main class</p>
<pre><code class="bash">$ java -p mlib -m com.greetings
Greetings world!
</code></pre>
<p>命令可以用-p来替代–module-path。</p>
<p>jar命令拥有许多新选项，其中一个就是打印模块化jar包中声明的模块。</p>
<pre><code class="bash">$ jar --describe-module --file=mlib/org.astro@1.0.jar
org.astro@1.0 jar:file:///d/mlib/org.astro@1.0.jar/!module-info.class
exports org.astro
requires java.base mandated
</code></pre>
<h3 id="缺少requires或者exports关键字"><a href="#缺少requires或者exports关键字" class="headerlink" title="缺少requires或者exports关键字"></a>缺少requires或者exports关键字</h3><p>如果我们在com.greetings模块中遗漏了requires关键字：</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    // requires org.astro;
}

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
    import org.astro.World;
                ^
    (package org.astro is declared in module org.astro, but module com.greetings does not read it)
1 error
</code></pre>
<p>如果我们在org.astro模块中遗漏了exports关键字：</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    requires org.astro;
}
$ cat src/org.astro/module-info.java
module org.astro {
    // exports org.astro;
}

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
    import org.astro.World;
                ^
    (package org.astro is declared in module org.astro, which does not export it)
1 error
</code></pre>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务允许服务提供者和服务消费者中建立松散的耦合结构。在这个例子中，存在这一个服务提供者和一个服务消费者：模块com.socket提供了API用来做network socket；模块org.fastsocket是一个服务提供模块，它提供了com.socket.spi.NetworkSocketProvider的实现，并且不导出任何包。</p>
<p>下面是模块com.socket的代码：</p>
<pre><code class="java">$ cat src/com.socket/module-info.java
module com.socket {
    exports com.socket;
    exports com.socket.spi;
    uses com.socket.spi.NetworkSocketProvider;
}

$ cat src/com.socket/com/socket/NetworkSocket.java
package com.socket;

import java.io.Closeable;
import java.util.Iterator;
import java.util.ServiceLoader;

import com.socket.spi.NetworkSocketProvider;

public abstract class NetworkSocket implements Closeable {
    protected NetworkSocket() { }

    public static NetworkSocket open() {
        ServiceLoader&lt;NetworkSocketProvider&gt; sl
            = ServiceLoader.load(NetworkSocketProvider.class);
        Iterator&lt;NetworkSocketProvider&gt; iter = sl.iterator();
        if (!iter.hasNext())
            throw new RuntimeException(&quot;No service providers found!&quot;);
        NetworkSocketProvider provider = iter.next();
        return provider.openNetworkSocket();
    }
}


$ cat src/com.socket/com/socket/spi/NetworkSocketProvider.java
package com.socket.spi;

import com.socket.NetworkSocket;

public abstract class NetworkSocketProvider {
    protected NetworkSocketProvider() { }

    public abstract NetworkSocket openNetworkSocket();
}
</code></pre>
<p>以下是模块org.fastsocket的代码</p>
<pre><code class="java">$ cat src/org.fastsocket/module-info.java
module org.fastsocket {
    requires com.socket;
    provides com.socket.spi.NetworkSocketProvider
        with org.fastsocket.FastNetworkSocketProvider;
}

$ cat src/org.fastsocket/org/fastsocket/FastNetworkSocketProvider.java
package org.fastsocket;

import com.socket.NetworkSocket;
import com.socket.spi.NetworkSocketProvider;

public class FastNetworkSocketProvider extends NetworkSocketProvider {
    public FastNetworkSocketProvider() { }

    @Override
    public NetworkSocket openNetworkSocket() {
        return new FastNetworkSocket();
    }
}

$ cat src/org.fastsocket/org/fastsocket/FastNetworkSocket.java
package org.fastsocket;

import com.socket.NetworkSocket;

class FastNetworkSocket extends NetworkSocket {
    FastNetworkSocket() { }
    public void close() { }
}
</code></pre>
<p>为了简单化，我们同时编译两个模块，但事实上，服务提供者和服务消费者几乎总是分开编译的</p>
<pre><code class="bash">$ mkdir mods
$ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)
</code></pre>
<p>最后我们对模块com.greetings用新的模块的api做更改</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    requires com.socket;
}

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;

import com.socket.NetworkSocket;

public class Main {
    public static void main(String[] args) {
        NetworkSocket s = NetworkSocket.open();
        System.out.println(s.getClass());
    }
}


$ javac -d mods/com.greetings/ -p mods $(find src/com.greetings/ -name &quot;*.java&quot;)
</code></pre>
<p>最后，我们运行com.greetings模块</p>
<pre><code class="bash">$ java -p mods -m com.greetings/com.greetings.Main
class org.fastsocket.FastNetworkSocket
</code></pre>
<p>输出结果确认服务提供者已经被定位成功。</p>
<h3 id="The-linker"><a href="#The-linker" class="headerlink" title="The linker"></a>The linker</h3><p>jlink是一个用来在一组拥有传递性依赖的模块之中，建立一个自定义的模块化可运行镜像的工具。</p>
<p>此工具目前需要制定模块路径的模块化jar包或者jmod格式。jdk会将标准的或jdk指定的模块以jmod格式打包。</p>
<p>以下命令会创建一个包含模块com.greetings和其传递性依赖的可运行镜像。</p>
<pre><code class="bash">jlink --module-path $JAVA_HOME/jmods:mlib --add-modules com.greetings --output greetingsapp
</code></pre>
<p>–module-path的值是包含打包后的模块的路径。在windows下需要将’:’替换成’;’。<br>$JAVA_HOME/jmods是包含java.base.jmod和其他标准化jdk模块的路径。mlib路径包含模块com.greetings的artifact。</p>
<p>jlink工具也包含许多高级的选项来自定义镜像，详见jlink –help</p>
<h3 id="–patch-module"><a href="#–patch-module" class="headerlink" title="–patch-module"></a>–patch-module</h3><p>开发者常会从Doug Lea的CVS中checkout出java.util.concurrent下的类并用-Xbootclasspath/p来替换源文件编译。(我都不知道Doug Lea还在更新juc的代码，膜拜大神)</p>
<p>现在-Xbootclasspath/p已经被舍弃，它在模块化系统中替代是–patch-module，用来替换模块中的类，它也可以被用来增大模块的内容。</p>
<p>javac命令同样也支持–patch-module选项用来编译模块中的as if部分。</p>
<p>以下是用新版本的java.util.concurrent.ConcurrentHashMap来编译并用其运行的例子</p>
<pre><code class="bash">javac --patch-module java.base=src -d mypatches/java.base \
    src/java.base/java/util/concurrent/ConcurrentHashMap.java

java --patch-module java.base=mypatches/java.base ...
</code></pre>
<h3 id="更多链接"><a href="#更多链接" class="headerlink" title="更多链接"></a>更多链接</h3><ul>
<li><a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">The State of the Module System</a></li>
<li><a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">JEP 261: Module System</a></li>
<li><a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Project Jigsaw</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[也来谈谈classloader和classpath hell问题]]></title>
      <url>/2018/01/11/classloader-classpath-hell/</url>
      <content type="html"><![CDATA[<p>classpath hell, 也叫 <a href="https://en.wikipedia.org/wiki/Java_Classloader#JAR_hell" target="_blank" rel="noopener">jar hell</a>。<br>先来简单翻译一下wiki：<br>Java Classloader 是 Java Runtime Environment 的一部分，它动态地将 Java 类加载到 jvm 中。类通常是按需加载的（即只有在需要实例化这个类时才会被加载）。因为有了 classloader 的存在，java runtime 不再需要知道有哪些文件。一个 java 类通常只会被加载一次。<br>当jvm启动时，会用到三个 classloader：</p>
<ol>
<li>Bootstrap class loader</li>
<li>Extensions class loader</li>
<li>System class loader</li>
</ol>
<p>bootstrap class loader是 jvm 的一部分，会加载 <java_home>/jre/lib 下的所有类。</java_home></p>
]]></content>
      
        <categories>
            
            <category> classLoader </category>
            
        </categories>
        
        
        <tags>
            
            <tag> classLoader </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>不是所有的树</p>
<p>都能在自己的家乡终老</p>
<p>不是所有的轨道</p>
<p>都通往春暖花开的地方</p>
<p>不是所有的花都会盛开</p>
<p>不是所有的约定的人都会到来</p>
<p>我知道，是流星赞美了黑夜</p>
<p>鲸鱼安慰了大海</p>
<hr>
<p><strong>Sean the Fish</strong></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=4882391&auto=0&height=66"></iframe>

<p>Java码农，目前供职于IBM。</p>
<p>博客刚刚建立，希望自己能坚持写下去。</p>
<p>Email：a728976009@hotmail.com</p>
<hr>
<p>想在天井里盛一只玻璃杯</p>
<p>明朝看天下雨今夜落几寸</p>
]]></content>
    </entry>
    
  
</search>
