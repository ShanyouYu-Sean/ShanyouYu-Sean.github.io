<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[gc调优-2]]></title>
      <url>/2020/11/16/improve-gc-2/</url>
      <content type="html"><![CDATA[<p>文章节选自<br><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html" target="_blank" rel="noopener">https://tech.meituan.com/2020/11/12/java-9-cms-gc.html</a><br><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p>
<p>先放内存结构图，这个图更清晰些：</p>
<p><img src="https://s3.ax1x.com/2020/11/18/Deca8I.png" alt="Deca8I.png"></p>
<p>GC 主要工作在 Heap 区和 MetaSpace 区（上图蓝色部分），在 Direct Memory 中，如果使用的是 DirectByteBuffer，那么在分配内存不够时则是 GC 通过 Cleaner#clean 间接管理。</p>
<p>任何自动内存管理系统都会面临的步骤：为新对象分配空间，然后收集垃圾对象空间。</p>
<h2 id="GC-问题判断"><a href="#GC-问题判断" class="headerlink" title="GC 问题判断"></a>GC 问题判断</h2><h3 id="确定你算关注的要素"><a href="#确定你算关注的要素" class="headerlink" title="确定你算关注的要素"></a>确定你算关注的要素</h3><ul>
<li>延迟（Latency）： 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</li>
<li>吞吐量（Throughput）： 应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</li>
<li>可用性 ：X个9，这个X是代表数字3~5。<ul>
<li>3个9：<code>(1-99.9%)*365*24=8.76小时</code>，表示该系统在连续运行1年时间里最多可能的业务中断时间是8.76小时。</li>
<li>4个9：<code>(1-99.99%)*365*24=0.876小时=52.6分钟</code>，表示该系统在连续运行1年时间里最多可能的业务中断时间是52.6分钟。</li>
<li>5个9：<code>(1-99.999%)*365*24*60=5.26分钟</code>，表示该系统在连续运行1年时间里最多可能的业务中断时间是5.26分钟。</li>
</ul>
</li>
</ul>
<p>目前各大互联网公司的系统基本都更追求低延时，避免一次 GC 停顿的时间过长对用户体验造成损失，衡量指标需要结合一下应用服务的 SLA，主要如下两点来判断：</p>
<p><img src="https://s3.ax1x.com/2020/11/18/Dm1bKx.png" alt="Dm1bKx.png"></p>
<p>简而言之，即为一次停顿的时间不超过应用服务的 TP9999，GC 的吞吐量不小于 99.99%。举个例子，假设某个服务 A 的 TP9999 为 80 ms，平均 GC 停顿为 30 ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min 以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。（大家可以先停下来，看看监控平台上面的 gc.meantime 分钟级别指标，如果超过了 6 ms 那单机 GC 吞吐量就达不到 4 个 9 了。）</p>
<p>备注：除了这两个指标之外还有 Footprint（资源量大小测量）、反应速度等指标，互联网这种实时系统追求低延迟，而很多嵌入式系统则追求 Footprint。</p>
<h3 id="GC可能带来的影响"><a href="#GC可能带来的影响" class="headerlink" title="GC可能带来的影响"></a>GC可能带来的影响</h3><p>举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：</p>
<p><img src="https://s3.ax1x.com/2020/11/18/De5m1H.png" alt="De5m1H.png"></p>
<p>那么有<code>(50ms+25ms)/T</code>比例的请求会受GC影响，其中GC前的50ms内到达的请求都会增加25ms，GC期间的25ms内到达的请求，会增加0-25ms不等，<code>如果时间T内发生N次GC，受GC影响请求占比=(接口响应时间+GC时间)×N/T</code> 。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。</p>
<h3 id="判断是不是-GC-引发的问题"><a href="#判断是不是-GC-引发的问题" class="headerlink" title="判断是不是 GC 引发的问题"></a>判断是不是 GC 引发的问题</h3><p>在一次 GC 问题处理的过程中，如何判断是 GC 导致的故障，还是系统本身引发 GC 问题。“GC 耗时增大、线程 Block 增多、慢查询增多、CPU 负载高等四个表象，如何判断哪个是根因？”：</p>
<ul>
<li>时序分析： 先发生的事件是根因的概率更大，通过监控手段分析各个指标的异常时间点，还原事件时间线，如先观察到 CPU 负载高（要有足够的时间 Gap），那么整个问题影响链就可能是：CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; 线程Block增多 -&gt; RT 上涨。</li>
<li>概率分析： 使用统计概率学，结合历史问题的经验进行推断，由近到远按类型分析，如过往慢查的问题比较多，那么整个问题影响链就可能是：慢查询增多 -&gt; GC 耗时增大 -&gt; CPU 负载高 -&gt; 线程 Block 增多 -&gt; RT上涨。</li>
<li>实验分析： 通过故障演练等方式对问题现场进行模拟，触发其中部分条件（一个或多个），观察是否会发生问题，如只触发线程 Block 就会发生问题，那么整个问题影响链就可能是：线程Block增多 -&gt; CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; RT 上涨。</li>
<li>反证分析： 对其中某一表象进行反证分析，即判断表象的发不发生跟结果是否有相关性，例如我们从整个集群的角度观察到某些节点慢查和 CPU 都正常，但也出了问题，那么整个问题影响链就可能是：GC 耗时增大 -&gt; 线程 Block 增多 -&gt; RT 上涨。</li>
</ul>
<p>不同的根因，后续的分析方法是完全不同的。如果是 CPU 负载高那可能需要用火焰图看下热点、如果是慢查询增多那可能需要看下 DB 情况、如果是线程 Block 引起那可能需要看下锁竞争的情况，最后如果各个表象证明都没有问题，那可能 GC 确实存在问题，可以继续分析 GC 问题了。</p>
<h3 id="GC-问题分类"><a href="#GC-问题分类" class="headerlink" title="GC 问题分类"></a>GC 问题分类</h3><ul>
<li>Unexpected GC： 意外发生的 GC，实际上不需要发生，我们可以通过一些手段去避免。<ul>
<li>Space Shock： 空间震荡问题，参见“场景一：动态扩容引起的空间震荡”。</li>
<li>Explicit GC： 显示执行 GC 问题，参见“场景二：显式 GC 的去与留”。</li>
</ul>
</li>
<li>Partial GC： 部分收集操作的 GC，只对某些分代/分区进行回收。<ul>
<li>Young GC： 分代收集里面的 Young 区收集动作，也可以叫做 Minor GC。<ul>
<li>ParNew： Young GC 频繁，参见“场景四：过早晋升”。</li>
</ul>
</li>
<li>Old GC： 分代收集里面的 Old 区收集动作，也可以叫做 Major GC，有些也会叫做 Full GC，但其实这种叫法是不规范的，在 CMS 发生 Foreground GC 时才是 Full GC，CMSScavengeBeforeRemark 参数也只是在 Remark 前触发一次Young GC。<ul>
<li>CMS： Old GC 频繁，参见“场景五：CMS Old GC 频繁”。</li>
<li>CMS： Old GC 不频繁但单次耗时大，参见“场景六：单次 CMS Old GC 耗时长”。</li>
</ul>
</li>
</ul>
</li>
<li>Full GC： 全量收集的 GC，对整个堆进行回收，STW 时间会比较长，一旦发生，影响较大，也可以叫做 Major GC，参见“场景七：内存碎片&amp;收集器退化”。</li>
<li>MetaSpace： 元空间回收引发问题，参见“场景三：MetaSpace 区 OOM”。</li>
<li>Direct Memory： 直接内存（也可以称作为堆外内存）回收引发问题，参见“场景八：堆外内存 OOM”。</li>
<li>JNI： 本地 Native 方法引发问题，参见“场景九：JNI 引发的 GC 问题”。</li>
</ul>
<h3 id="参数基本策略"><a href="#参数基本策略" class="headerlink" title="参数基本策略"></a>参数基本策略</h3><p>分析活跃数据的大小是很好的切入点。</p>
<p>活跃数据的大小是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中Full GC之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取GC数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下：<br>|空间|倍数|<br>|—|—|<br>|总大小|3-4 倍活跃数据的大小|<br>|新生代|1-1.5 活跃数据的大小|<br>|老年代|2-3 倍活跃数据的大小|<br>|永久代|1.2-1.5 倍Full GC后的永久代空间占用|</p>
<p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：</p>
<p><code>总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*</code></p>
<h3 id="GC-Cause"><a href="#GC-Cause" class="headerlink" title="GC Cause"></a>GC Cause</h3><p>重点需要关注的几个GC Cause：</p>
<ul>
<li>System.gc()： 手动触发GC操作。</li>
<li>CMS： CMS GC 在执行过程中的一些动作，重点关注 CMS Initial Mark 和 CMS Final Remark 两个 STW 阶段。</li>
<li>Promotion Failure： Old 区没有足够的空间分配给 Young 区晋升的对象（即使总可用内存足够大）。</li>
<li>Concurrent Mode Failure： CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能，下面的一个案例即为这种场景。</li>
<li>GCLocker Initiated GC： 如果线程执行在 JNI 临界区时，刚好需要进行 GC，此时 GC Locker 将会阻止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</li>
</ul>
<h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><ul>
<li>java.lang.OutOfMemoryError: Java heap space：表示Java堆空间不够，当应用程序申请更多的内存，而Java堆内存已经无法满足应用程序对内存的需要，将抛出这种异常。</li>
<li>java.lang.OutOfMemoryError: PermGen space：表示Java永久带（方法区）空间不够，永久带用于存放类的字节码和长常量池，类的字节码加载后存放在这个区域，这和存放对象实例的堆区是不同的，大多数JVM的实现都不会对永久带进行垃圾回收，因此，只要类加载的过多就会出现这个问题。一般的应用程序都不会产生这个错误，然而，对于Web服务器来讲，会产生有大量的JSP，JSP在运行时被动态的编译成Java Servlet类，然后加载到方法区，因此，太多的JSP的Web工程可能产生这个异常。</li>
<li>java.lang.OutOfMemoryError: unable to create new native thread：本质原因是创建了太多的线程，而能创建的线程数是有限制的，导致了这种异常的发生。</li>
<li>java.lang.OutOfMemoryError：GC overhead limit exceeded：在并行或者并发回收器在GC回收时间过长、超过98%的时间用来做GC并且回收了不到2%的堆内存，然后抛出这种异常进行提前预警，用来避免内存过小造成应用不能正常工作。</li>
</ul>
<h3 id="常见场景分析与解决"><a href="#常见场景分析与解决" class="headerlink" title="常见场景分析与解决"></a>常见场景分析与解决</h3><h4 id="动态扩容引起的空间震荡"><a href="#动态扩容引起的空间震荡" class="headerlink" title="动态扩容引起的空间震荡"></a>动态扩容引起的空间震荡</h4><h5 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h5><p>服务刚刚启动时 GC 次数较多，最大空间剩余很多但是依然发生 GC，这种情况我们可以通过观察 GC 日志或者通过监控工具来观察堆的空间变化情况即可。GC Cause 一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整，如下图所示：</p>
<p><img src="https://s3.ax1x.com/2020/11/18/DeqvQO.png" alt="DeqvQO.png"></p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>在 JVM 的参数中 -Xms 和 -Xmx 设置的不一致，在初始化时只会初始 -Xms 大小的空间存储信息，每当空间不够用时再向操作系统申请，这样的话必然要进行一次 GC。</p>
<p>另外，如果空间剩余很多时也会进行缩容操作，JVM 通过 -XX:MinHeapFreeRatio 和 -XX:MaxHeapFreeRatio 来控制扩容和缩容的比例，调节这两个值也可以控制伸缩的时机。</p>
<h5 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h5><p>定位：观察 CMS GC 触发时间点 Old/MetaSpace 区的 committed 占比是不是一个固定的值，或者像上文提到的观察总的内存使用率也可以。</p>
<p>解决：尽量将成对出现的空间大小配置参数设置成固定的，如 -Xms 和 -Xmx，-XX:MaxNewSize 和 -XX:NewSize，-XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 等。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>一般来说，我们需要保证 Java 虚拟机的堆是稳定的，确保 -Xms 和 -Xmx 设置的是一个值（即初始值和最大值一致），获得一个稳定的堆，同理在 MetaSpace 区也有类似的问题。不过在不追求停顿时间的情况下震荡的空间也是有利的，可以动态地伸缩以节省空间，例如作为富客户端的 Java 应用。</p>
<h4 id="显式-GC-的去与留"><a href="#显式-GC-的去与留" class="headerlink" title="显式 GC 的去与留"></a>显式 GC 的去与留</h4><h5 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h5><p>除了扩容缩容会触发 CMS GC 之外，还有 Old 区达到回收阈值、MetaSpace 空间不足、Young 区晋升失败、大对象担保失败等几种触发条件，如果这些情况都没有发生却触发了 GC ？这种情况有可能是代码中手动调用了 System.gc 方法，此时可以找到 GC 日志中的 GC Cause 确认下。那么这种 GC 到底有没有问题，翻看网上的一些资料，有人说可以添加 -XX:+DisableExplicitGC 参数来避免这种 GC，也有人说不能加这个参数，加了就会影响 Native Memory 的回收。先说结论，笔者这里建议保留 System.gc，那为什么要保留？我们一起来分析下。</p>
<h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5><p>找到 System.gc 在 Hotspot 中的源码，可以发现增加 -XX:+DisableExplicitGC 参数后，这个方法变成了一个空方法，如果没有加的话便会调用 Universe::heap()::collect 方法，继续跟进到这个方法中，发现 System.gc 会引发一次 STW 的 Full GC，对整个堆做收集。</p>
<p>保留 System.gc</p>
<p>此处补充一个知识点，CMS GC 共分为 Background 和 Foreground 两种模式，前者就是我们常规理解中的并发收集，可以不影响正常的业务线程运行，但 Foreground Collector 却有很大的差异，他会进行一次压缩式 GC。此压缩式 GC 使用的是跟 Serial Old GC 一样的 Lisp2 算法，其使用 Mark-Compact 来做 Full GC，一般称之为 MSC（Mark-Sweep-Compact），它收集的范围是 Java 堆的 Young 区和 Old 区以及 MetaSpace。 compact 的代价是巨大的，那么使用 Foreground Collector 时将会带来非常长的 STW。如果在应用程序中 System.gc 被频繁调用，那就非常危险了。</p>
<p>去掉 System.gc</p>
<p>如果禁用掉的话就会带来另外一个内存泄漏问题，此时就需要说一下 DirectByteBuffer，它有着零拷贝等特点，被 Netty 等各种 NIO 框架使用，会使用到堆外内存。堆内存由 JVM 自己管理，堆外内存必须要手动释放，DirectByteBuffer 没有 Finalizer，它的 Native Memory 的清理工作是通过 sun.misc.Cleaner 自动完成的，是一种基于 PhantomReference 的清理工具，比普通的 Finalizer 轻量些。</p>
<p>为 DirectByteBuffer 分配空间过程中会显式调用 System.gc ，希望通过 Full GC 来强迫已经无用的 DirectByteBuffer 对象释放掉它们关联的 Native Memory，下面为代码实现：</p>
<pre><code class="java">// These methods should be called whenever direct memory is allocated or
// freed.  They allow the user to control the amount of direct memory
// which a process may access.  All sizes are specified in bytes.
static void reserveMemory(long size) {

    synchronized (Bits.class) {
        if (!memoryLimitSet &amp;&amp; VM.isBooted()) {
            maxMemory = VM.maxDirectMemory();
            memoryLimitSet = true;
        }
        if (size &lt;= maxMemory - reservedMemory) {
            reservedMemory += size;
            return;
        }
    }

    System.gc();
    try {
        Thread.sleep(100);
    } catch (InterruptedException x) {
        // Restore interrupt status
        Thread.currentThread().interrupt();
    }
    synchronized (Bits.class) {
        if (reservedMemory + size &gt; maxMemory)
            throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);
        reservedMemory += size;
    }

}
</code></pre>
<p>HotSpot VM 只会在 Old GC 的时候才会对 Old 中的对象做 Reference Processing，而在 Young GC 时只会对 Young 里的对象做 Reference Processing。Young 中的 DirectByteBuffer 对象会在 Young GC 时被处理，也就是说，做 CMS GC 的话会对 Old 做 Reference Processing，进而能触发 Cleaner 对已死的 DirectByteBuffer 对象做清理工作。但如果很长一段时间里没做过 GC 或者只做了 Young GC 的话, 则不会在 Old 触发 Cleaner 的工作，那么就可能让本来已经死亡，但已经晋升到 Old 的 DirectByteBuffer 关联的 Native Memory 得不到及时释放。这几个实现特征使得依赖于 System.gc 触发 GC 来保证 DirectByteMemory 的清理工作能及时完成。如果打开了 -XX:+DisableExplicitGC，清理工作就可能得不到及时完成，于是就有发生 Direct Memory 的 OOM。</p>
<h5 id="策略-1"><a href="#策略-1" class="headerlink" title="策略"></a>策略</h5><p>通过上面的分析看到，无论是保留还是去掉都会有一定的风险点，不过目前互联网中的 RPC 通信会大量使用 NIO，所以笔者在这里建议保留。此外 JVM 还提供了 -XX:+ExplicitGCInvokesConcurrent 和 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses 参数来将 System.gc 的触发类型从 Foreground 改为 Background，同时 Background 也会做 Reference Processing，这样的话就能大幅降低了 STW 开销，同时也不会发生 NIO Direct Memory OOM。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>不止 CMS，在 G1 或 ZGC中开启 ExplicitGCInvokesConcurrent 模式，都会采用高性能的并发收集方式进行收集，不过还是建议在代码规范方面也要做好约束，规范好 System.gc 的使用。</p>
<h4 id="MetaSpace-区-OOM"><a href="#MetaSpace-区-OOM" class="headerlink" title="MetaSpace 区 OOM"></a>MetaSpace 区 OOM</h4><h5 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h5><p>JVM 在启动后或者某个时间点开始，MetaSpace 的已使用大小在持续增长，同时每次 GC 也无法释放，调大 MetaSpace 空间也无法彻底解决。</p>
<h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5><p>在讨论为什么会 OOM 之前，我们先来看一下这个区里面会存什么数据，Java7 之前字符串常量池被放到了 Perm 区，所有被 intern 的 String 都会被存在这里，由于 String.intern 是不受控的，所以 -XX:MaxPermSize 的值也不太好设置，经常会出现 java.lang.OutOfMemoryError: PermGen space 异常，所以在 Java7 之后常量池等字面量（Literal）、类静态变量（Class Static）、符号引用（Symbols Reference）等几项被移到 Heap 中。而 Java8 之后 PermGen 也被移除，取而代之的是 MetaSpace。</p>
<p>在最底层，JVM 通过 mmap 接口向操作系统申请内存映射，每次申请 2MB 空间，这里是虚拟内存映射，不是真的就消耗了主存的 2MB，只有之后在使用的时候才会真的消耗内存。申请的这些内存放到一个链表中 VirtualSpaceList，作为其中的一个 Node。</p>
<p>在上层，MetaSpace 主要由 Klass Metaspace 和 NoKlass Metaspace 两大部分组成。</p>
<ul>
<li>Klass MetaSpace： 就是用来存 Klass 的，就是 Class 文件在 JVM 里的运行时数据结构，这部分默认放在 Compressed Class Pointer Space 中，是一块连续的内存区域，紧接着 Heap。Compressed Class Pointer Space 不是必须有的，如果设置了 -XX:-UseCompressedClassPointers，或者 -Xmx 设置大于 32 G，就不会有这块内存，这种情况下 Klass 都会存在 NoKlass Metaspace 里。</li>
<li>NoKlass MetaSpace： 专门来存 Klass 相关的其他的内容，比如 Method，ConstantPool 等，可以由多块不连续的内存组成。虽然叫做 NoKlass Metaspace，但是也其实可以存 Klass 的内容，上面已经提到了对应场景。</li>
</ul>
<p>MetaSpace 的对象为什么无法释放，我们看下面两点：</p>
<ul>
<li><p>MetaSpace 内存管理： 类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在 Metaspace 中的类元数据也是存活的，不能被回收。每个加载器有单独的存储空间，通过 ClassLoaderMetaspace 来进行管理 SpaceManager* 的指针，相互隔离的。</p>
</li>
<li><p>MetaSpace 弹性伸缩： 由于 MetaSpace 空间和 Heap 并不在一起，所以这块的空间可以不用设置或者单独设置，一般情况下避免 MetaSpace 耗尽 VM 内存都会设置一个 MaxMetaSpaceSize，在运行过程中，如果实际大小小于这个值，JVM 就会通过 -XX:MinMetaspaceFreeRatio 和 -XX:MaxMetaspaceFreeRatio 两个参数动态控制整个 MetaSpace 的大小。</p>
</li>
</ul>
<p>由场景一可知，为了避免弹性伸缩带来的额外 GC 消耗，我们会将 -XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 两个值设置为固定的，但是这样也会导致在空间不够的时候无法扩容，然后频繁地触发 GC，最终 OOM。所以关键原因就是 ClassLoader 不停地在内存中 load 了新的 Class ，一般这种问题都发生在动态类加载等情况上。</p>
<h5 id="策略-2"><a href="#策略-2" class="headerlink" title="策略"></a>策略</h5><p>了解大概什么原因后，如何定位和解决就很简单了，可以 dump 快照之后通过 JProfiler 或 MAT 观察 Classes 的 Histogram（直方图） 即可，或者直接通过命令即可定位， jcmd 打几次 Histogram 的图，看一下具体是哪个包下的 Class 增加较多就可以定位了。不过有时候也要结合InstBytes、KlassBytes、Bytecodes、MethodAll 等几项指标综合来看下。</p>
<p>如果无法从整体的角度定位，可以添加 -XX:+TraceClassLoading 和 -XX:+TraceClassUnLoading 参数观察详细的类加载和卸载信息。</p>
<h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>原理理解比较复杂，但定位和解决问题会比较简单，经常会出问题的几个点有 Orika 的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。另外就是及时给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。</p>
<h4 id="过早晋升"><a href="#过早晋升" class="headerlink" title="过早晋升"></a>过早晋升</h4><h5 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h5><p>这种场景主要发生在分代的收集器上面，专业的术语称为“Premature Promotion”。90% 的对象朝生夕死，只有在 Young 区经历过几次 GC 的洗礼后才会晋升到 Old 区，每经历一次 GC 对象的 GC Age 就会增长 1，最大通过 -XX:MaxTenuringThreshold 来控制。</p>
<p>过早晋升一般不会直接影响 GC，总会伴随着浮动垃圾、大对象担保失败等问题，但这些问题不是立刻发生的，我们可以观察以下几种现象来判断是否发生了过早晋升。</p>
<p>分配速率接近于晋升速率，对象晋升年龄较小。</p>
<p>GC 日志中出现“Desired survivor size 107347968 bytes, new threshold 1(max 6)”等信息，说明此时经历过一次 GC 就会放到 Old 区。</p>
<p>Full GC 比较频繁，且经历过一次 GC 之后 Old 区的变化比例非常大。</p>
<p>比如说 Old 区触发的回收阈值是 80%，经历过一次 GC 之后下降到了 10%，这就说明 Old 区的 70% 的对象存活时间其实很短。</p>
<p>过早晋升的危害：</p>
<ul>
<li>Young GC 频繁，总的吞吐量下降。</li>
<li>Full GC 频繁，可能会有较大停顿。</li>
</ul>
<h5 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h5><p>主要的原因有以下两点：</p>
<ul>
<li><p>Young/Eden 区过小： 过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升，Young GC 采用的是复制算法，copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是 copy 的时间（CMS 扫描 Card Table 或 G1 扫描 Remember Set 出问题的情况另说），没来及回收的对象增大了回收的代价，所以 Young GC 时间增加，同时又无法快速释放空间，Young GC 次数也跟着增加。</p>
</li>
<li><p>分配速率过大： 可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。</p>
</li>
</ul>
<p>同时无法 GC 掉对象还会带来另外一个问题，引发动态年龄计算：JVM 通过 -XX:MaxTenuringThreshold 参数来控制晋升年龄，每经过一次 GC，年龄就会加一，达到最大年龄就可以进入 Old 区，最大值为 15（因为 JVM 中使用 4 个比特来表示对象的年龄）。设定固定的 MaxTenuringThreshold 值作为晋升条件：</p>
<ul>
<li><p>MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在 Survivor 区，直到 Survivor 区溢出，一旦溢出发生，Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。</p>
</li>
<li><p>MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。</p>
</li>
</ul>
<p>相同应用在不同时间的表现不同，特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面问题，所以 Hotspot 会使用动态计算的方式来调整晋升的阈值。</p>
<h5 id="策略-3"><a href="#策略-3" class="headerlink" title="策略"></a>策略</h5><p>知道问题原因后我们就有解决的方向，如果是 Young/Eden 区过小，我们可以在总的 Heap 内存不变的情况下适当增大 Young 区，具体怎么增加？一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。</p>
<p>拿笔者的一次典型过早晋升优化来看，原配置为 Young 1.2G + Old 2.8G，通过观察 CMS GC 的情况找到存活对象大概为 300~400M，于是调整 Old 1.5G 左右，剩下 2.5G 分给 Young 区。仅仅调了一个 Young 区大小参数（-Xmn），整个 JVM 一分钟 Young GC 从 26 次降低到了 11 次，单次时间也没有增加，总的 GC 时间从 1100ms 降低到了 500ms，CMS GC 次数也从 40 分钟左右一次降低到了 7 小时 30 分钟一次。</p>
<p>如果是分配速率过大：</p>
<ul>
<li>偶发较大：通过内存分析工具找到问题代码，从业务逻辑上做一些优化。</li>
<li>一直较大：当前的 Collector 已经不满足 Mutator 的期望了，这种情况要么扩容 Mutator 的 VM，要么调整 GC 收集器类型或加大空间。</li>
</ul>
<h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><p>过早晋升问题一般不会特别明显，但日积月累之后可能会爆发一波收集器退化之类的问题，所以我们还是要提前避免掉的，可以看看自己系统里面是否有这些现象，如果比较匹配的话，可以尝试优化一下。一行代码优化的 ROI 还是很高的。</p>
<p>如果在观察 Old 区前后比例变化的过程中，发现可以回收的比例非常小，如从 80% 只回收到了 60%，说明我们大部分对象都是存活的，Old 区的空间可以适当调大些。</p>
<h4 id="CMS-Old-GC-频繁"><a href="#CMS-Old-GC-频繁" class="headerlink" title="CMS Old GC 频繁"></a>CMS Old GC 频繁</h4><h5 id="现象-4"><a href="#现象-4" class="headerlink" title="现象"></a>现象</h5><p>Old 区频繁的做 CMS GC，但是每次耗时不是特别长，整体最大 STW 也在可接受范围内，但由于 GC 太频繁导致吞吐下降比较多。</p>
<h5 id="原因-4"><a href="#原因-4" class="headerlink" title="原因"></a>原因</h5><p>这种情况比较常见，基本都是一次 Young GC 完成后，负责处理 CMS GC 的一个后台线程 concurrentMarkSweepThread 会不断地轮询，使用 shouldConcurrentCollect() 方法做一次检测，判断是否达到了回收条件。如果达到条件，使用 collect_in_background() 启动一次 Background 模式 GC。轮询的判断是使用 sleepBeforeNextCycle() 方法，间隔周期为 -XX:CMSWaitDuration 决定，默认为2s。</p>
<p>分析其中逻辑判断是否触发 GC，分为以下几种情况：</p>
<ul>
<li><p>触发 CMS GC： 通过调用 _collector-&gt;collect_in_background() 进行触发 Background GC 。</p>
<ul>
<li><p>CMS 默认采用 JVM 运行时的统计数据判断是否需要触发 CMS GC，如果需要根据 -XX:CMSInitiatingOccupancyFraction 的值进行判断，需要设置参数 -XX:+UseCMSInitiatingOccupancyOnly。</p>
</li>
<li><p>如果开启了 -XX:UseCMSInitiatingOccupancyOnly 参数，判断当前 Old 区使用率是否大于阈值，则触发 CMS GC，该阈值可以通过参数 -XX:CMSInitiatingOccupancyFraction 进行设置，如果没有设置，默认为 92%。</p>
</li>
<li><p>如果之前的 Young GC 失败过，或者下次 Young 区执行 Young GC 可能失败，这两种情况下都需要触发 CMS GC。</p>
</li>
<li><p>CMS 默认不会对 MetaSpace 或 Perm 进行垃圾收集，如果希望对这些区域进行垃圾收集，需要设置参数 -XX:+CMSClassUnloadingEnabled。</p>
</li>
</ul>
</li>
<li><p>触发 Full GC： 直接进行 Full GC，这种情况到场景七中展开说明。</p>
<ul>
<li><p>如果 _full_gc_requested 为真，说明有明确的需求要进行 GC，比如调用 System.gc。</p>
</li>
<li><p>在 Eden 区为对象或 TLAB 分配内存失败，导致一次 Young GC，在 GenCollectorPolicy 类的 satisfy_failed_allocation() 方法中进行判断。</p>
</li>
</ul>
</li>
</ul>
<p>大家可以看一下源码中的日志打印，通过日志我们就可以比较清楚地知道具体的原因，然后就可以着手分析了。</p>
<h5 id="策略-4"><a href="#策略-4" class="headerlink" title="策略"></a>策略</h5><p>我们这里还是拿最常见的达到回收比例这个场景来说，与过早晋升不同的是这些对象确实存活了一段时间，Survival Time 超过了 TP9999 时间，但是又达不到长期存活，如各种数据库、网络链接，带有失效时间的缓存等。</p>
<p>处理这种常规内存泄漏问题基本是一个思路，主要步骤如下：</p>
<p><img src="https://s3.ax1x.com/2020/11/18/DmudMT.png" alt="DmudMT.png"></p>
<h4 id="单次-CMS-Old-GC-耗时长"><a href="#单次-CMS-Old-GC-耗时长" class="headerlink" title="单次 CMS Old GC 耗时长"></a>单次 CMS Old GC 耗时长</h4><h5 id="现象-5"><a href="#现象-5" class="headerlink" title="现象"></a>现象</h5><p>CMS GC 单次 STW 最大超过 1000ms，不会频繁发生，如下图所示最长达到了 8000ms。某些场景下会引起“雪崩效应”，这种场景非常危险，我们应该尽量避免出现。</p>
<h5 id="原因-5"><a href="#原因-5" class="headerlink" title="原因"></a>原因</h5><p>CMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段，也是导致 CMS Old GC 最多的原因，另外有些情况就是在 STW 前等待 Mutator 的线程到达 SafePoint 也会导致时间过长，但这种情况较少，我们在此处主要讨论前者。发生收集器退化或者碎片压缩的场景请看场景七。</p>
<ul>
<li>CMS Init Mark执行步骤<br><img src="https://s3.ax1x.com/2020/11/18/DmKMf1.png" alt="DmKMf1.png"><br>整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。</li>
<li>CMS Final Remark 执行步骤<br><img src="https://s3.ax1x.com/2020/11/18/DmK1l6.png" alt="DmK1l6.png"><br>Final Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行，如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 Card Table 遍历、Reference 实例的清理并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源。</li>
</ul>
<h5 id="策略-5"><a href="#策略-5" class="headerlink" title="策略"></a>策略</h5><p>知道了两个 STW 过程执行流程，我们分析解决就比较简单了，由于大部分问题都出在 Final Remark 过程，这里我们也拿这个场景来举例，主要步骤：</p>
<p>【方向】 观察详细 GC 日志，找到出问题时 Final Remark 日志，分析下 Reference 处理和元数据处理 real 耗时是否正常，详细信息需要通过 -XX:+PrintReferenceGC 参数开启。基本在日志里面就能定位到大概是哪个方向出了问题，耗时超过 10% 的就需要关注。</p>
<p>【根因】 有了具体的方向我们就可以进行深入的分析，一般来说最容易出问题的地方就是 Reference 中的 FinalReference 和元数据信息处理中的 scrub symbol table 两个阶段，想要找到具体问题代码就需要内存分析工具 MAT 或 JProfiler 了，注意要 dump 即将开始 CMS GC 的堆。在用 MAT 等工具前也可以先用命令行看下对象 Histogram，有可能直接就能定位问题。</p>
<ul>
<li><p>对 FinalReference 的分析主要观察 java.lang.ref.Finalizer 对象的 dominator tree，找到泄漏的来源。经常会出现问题的几个点有 Socket 的 SocksSocketImpl 、Jersey 的 ClientRuntime、MySQL 的 ConnectionImpl 等等。</p>
</li>
<li><p>scrub symbol table 表示清理元数据符号引用耗时，符号引用是 Java 代码被编译成字节码时，方法在 JVM 中的表现形式，生命周期一般与 Class 一致，当 _should_unload_classes 被设置为 true 时在 CMSCollector::refProcessingWork() 中与 Class Unload、String Table 一起被处理。</p>
</li>
</ul>
<p>【策略】 知道 GC 耗时的根因就比较好处理了，这种问题不会大面积同时爆发，不过有很多时候单台 STW 的时间会比较长，如果业务影响比较大，及时摘掉流量，具体后续优化策略如下：</p>
<ul>
<li><p>FinalReference：找到内存来源后通过优化代码的方式来解决，如果短时间无法定位可以增加 -XX:+ParallelRefProcEnabled 对 Reference 进行并行处理。</p>
</li>
<li><p>symbol table：观察 MetaSpace 区的历史使用峰值，以及每次 GC 前后的回收情况，一般没有使用动态类加载或者 DSL 处理等，MetaSpace 的使用率上不会有什么变化，这种情况可以通过 -XX:-CMSClassUnloadingEnabled 来避免 MetaSpace 的处理，JDK8 会默认开启 CMSClassUnloadingEnabled，这会使得 CMS 在 CMS-Remark 阶段尝试进行类的卸载。</p>
</li>
</ul>
<h5 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h5><p>正常情况进行的 Background CMS GC，出现问题基本都集中在 Reference 和 Class 等元数据处理上，在 Reference 类的问题处理方面，不管是 FinalReference，还是 SoftReference、WeakReference 核心的手段就是找准时机 dump 快照，然后用内存分析工具来分析。Class 处理方面目前除了关闭类卸载开关，没有太好的方法。</p>
<p>在 G1 中同样有 Reference 的问题，可以观察日志中的 Ref Proc，处理方法与 CMS 类似。</p>
<h4 id="内存碎片-amp-收集器退化"><a href="#内存碎片-amp-收集器退化" class="headerlink" title="内存碎片&amp;收集器退化"></a>内存碎片&amp;收集器退化</h4><h5 id="现象-6"><a href="#现象-6" class="headerlink" title="现象"></a>现象</h5><p>并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：</p>
<p>带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。<br>不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。</p>
<h5 id="原因-6"><a href="#原因-6" class="headerlink" title="原因"></a>原因</h5><p>CMS 发生收集器退化主要有以下几种情况：</p>
<ul>
<li>晋升失败（Promotion Failed）</li>
</ul>
<p>顾名思义，晋升失败就是指在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。直觉上乍一看这种情况可能会经常发生，但其实因为有 concurrentMarkSweepThread 和担保机制的存在，发生的条件是很苛刻的，除非是短时间将 Old 区的剩余空间迅速填满，例如上文中说的动态年龄判断导致的过早晋升（见下文的增量收集担保失败）。另外还有一种情况就是内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。</p>
<p>使用 CMS 作为 GC 收集器时，运行过一段时间的 Old 区, 清除算法导致内存出现多段的不连续，出现大量的内存碎片。</p>
<p>碎片带来了两个问题：</p>
<p>空间分配效率较低：上文已经提到过，如果是连续的空间 JVM 可以通过使用 pointer bumping 的方式来分配，而对于这种有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问，查找可以存放新建对象的地址。<br>空间利用效率变低：Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象，也就是本文所说的问题。</p>
<ul>
<li>增量收集担保失败</li>
</ul>
<p>分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之，则代表不安全，不进行Young GC，直接触发Full GC。</p>
<ul>
<li>显式 GC</li>
</ul>
<p>这种情况参见场景二。</p>
<ul>
<li>并发模式失败（Concurrent Mode Failure）</li>
</ul>
<p>最后一种情况，也是发生概率较高的一种，在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。</p>
<p>为什么 CMS GC 正在执行还会导致收集器退化呢？主要是由于 CMS 无法处理浮动垃圾（Floating Garbage）引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。所以 Old 区回收的阈值不能太高，否则预留的内存空间很可能不够，从而导致 Concurrent Mode Failure 发生。</p>
<h5 id="策略-6"><a href="#策略-6" class="headerlink" title="策略"></a>策略</h5><p>分析到具体原因后，我们就可以针对性解决了，具体思路还是从根因出发，具体解决策略：</p>
<ul>
<li><p>内存碎片： 通过配置 -XX:UseCMSCompactAtFullCollection=true 来控制 Full GC的过程中是否进行空间的整理（默认开启，注意是Full GC，不是普通CMS GC），以及 -XX: CMSFullGCsBeforeCompaction=n 来控制多少次 Full GC 后进行一次压缩。</p>
</li>
<li><p>增量收集： 降低触发 CMS GC 的阈值，即参数 -XX:CMSInitiatingOccupancyFraction 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 -XX:+UseCMSInitiatingOccupancyOnly 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。</p>
</li>
<li><p>浮动垃圾： 视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 -XX:+CMSScavengeBeforeRemark 在过程中提前触发一次 Young GC，防止后续晋升过多对象。</p>
</li>
</ul>
<h5 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h5><p>正常情况下触发并发模式的 CMS GC，停顿非常短，对业务影响很小，但 CMS GC 退化后，影响会非常大，建议发现一次后就彻底根治。只要能定位到内存碎片、浮动垃圾、增量收集相关等具体产生原因，还是比较好解决的，关于内存碎片这块，如果 -XX:CMSFullGCsBeforeCompaction 的值不好选取的话，可以使用 -XX:PrintFLSStatistics 来观察内存碎片率情况，然后再设置具体的值。</p>
<p>最后就是在编码的时候也要避免需要连续地址空间的大对象的产生，如过长的字符串，用于存放附件、序列化或反序列化的 byte 数组等，还有就是过早晋升问题尽量在爆发问题前就避免掉。</p>
<h4 id="堆外内存-OOM"><a href="#堆外内存-OOM" class="headerlink" title="堆外内存 OOM"></a>堆外内存 OOM</h4><h5 id="现象-7"><a href="#现象-7" class="headerlink" title="现象"></a>现象</h5><p>内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，通过 top 命令发现 Java 进程的 RES(常驻内存) 甚至超过了 -Xmx 的大小。出现这些现象时，基本可以确定是出现了堆外内存泄漏。</p>
<h5 id="原因-7"><a href="#原因-7" class="headerlink" title="原因"></a>原因</h5><p>JVM 的堆外内存泄漏，主要有两种的原因：</p>
<ul>
<li>通过 UnSafe#allocateMemory，ByteBuffer#allocateDirect 主动申请了堆外内存而没有释放，常见于 NIO、Netty 等相关组件。</li>
<li>代码中有通过 JNI 调用 Native Code 申请的内存没有释放。</li>
</ul>
<h5 id="策略-7"><a href="#策略-7" class="headerlink" title="策略"></a>策略</h5><p>哪种原因造成的堆外内存泄漏？</p>
<p>首先，我们需要确定是哪种原因导致的堆外内存泄漏。这里可以使用 NMT（NativeMemoryTracking） 进行分析。在项目中添加 -XX:NativeMemoryTracking=detail JVM参数后重启项目（需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗）。使用命令 <code>jcmd pid VM.native_memory detail</code> 查看内存分布。重点观察 total 中的 committed，因为 jcmd 命令显示的内存包含堆内内存、Code 区域、通过 Unsafe.allocateMemory 和 DirectByteBuffer 申请的内存，但是不包含其他 Native Code（C 代码）申请的堆外内存。</p>
<p>如果 total 中的 committed 和 top 中的 RES 相差不大，则应为主动申请的堆外内存未释放造成的，如果相差较大，则基本可以确定是 JNI 调用造成的。</p>
<p>原因一：主动申请未释放</p>
<p>JVM 使用 -XX:MaxDirectMemorySize=size 参数来控制可申请的堆外内存的最大值。在 Java8 中，如果未配置该参数，默认和 -Xmx 相等。</p>
<p>NIO 和 Netty 都会取 -XX:MaxDirectMemorySize 配置的值，来限制申请的堆外内存的大小。NIO 和 Netty 中还有一个计数器字段，用来计算当前已申请的堆外内存大小，NIO 中是 <code>java.nio.Bits#totalCapacity</code>、Netty 中 <code>io.netty.util.internal.PlatformDependent#DIRECT_MEMORY_COUNTER</code>。</p>
<p>当申请堆外内存时，NIO 和 Netty 会比较计数器字段和最大值的大小，如果计数器的值超过了最大值的限制，会抛出 OOM 的异常。</p>
<p>NIO 中是：<code>OutOfMemoryError: Direct buffer memory</code>。</p>
<p>Netty 中是：<code>OutOfDirectMemoryError: failed to allocate capacity byte(s) of direct memory (used: usedMemory , max: DIRECT_MEMORY_LIMIT )</code>。</p>
<p>我们可以检查代码中是如何使用堆外内存的，NIO 或者是 Netty，通过反射，获取到对应组件中的计数器字段，并在项目中对该字段的数值进行打点，即可准确地监控到这部分堆外内存的使用情况。</p>
<p>此时，可以通过 Debug 的方式确定使用堆外内存的地方是否正确执行了释放内存的代码。另外，需要检查 JVM 的参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc 失效。（场景二：显式 GC 的去与留）</p>
<p>原因二：通过 JNI 调用的 Native Code 申请的内存未释放</p>
<p>这种情况排查起来比较困难，我们可以通过 Google perftools + Btrace 等工具，帮助我们分析出问题的代码在哪里。</p>
<h5 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h5><p>首先可以使用 NMT + jcmd 分析泄漏的堆外内存是哪里申请，确定原因后，使用不同的手段，进行原因定位。</p>
<h4 id="JNI-引发的-GC-问题"><a href="#JNI-引发的-GC-问题" class="headerlink" title="JNI 引发的 GC 问题"></a>JNI 引发的 GC 问题</h4><h5 id="现象-8"><a href="#现象-8" class="headerlink" title="现象"></a>现象</h5><p>在 GC 日志中，出现 GC Cause 为 GCLocker Initiated GC。</p>
<h5 id="原因-8"><a href="#原因-8" class="headerlink" title="原因"></a>原因</h5><p>JNI（Java Native Interface）意为 Java 本地调用，它允许 Java 代码和其他语言写的 Native 代码进行交互。</p>
<p>JNI 如果需要获取 JVM 中的 String 或者数组，有两种方式：</p>
<ul>
<li>拷贝传递。</li>
<li>共享引用（指针），性能更高。</li>
</ul>
<p>由于 Native 代码直接使用了 JVM 堆区的指针，如果这时发生 GC，就会导致数据错误。因此，在发生此类 JNI 调用时，禁止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</p>
<p>GC Locker可能导致的不良后果有：</p>
<ul>
<li><p>如果此时是 Young 区不够 Allocation Failure 导致的 GC，由于无法进行 Young GC，会将对象直接分配至 Old 区。</p>
</li>
<li><p>如果 Old 区也没有空间了，则会等待锁释放，导致线程阻塞。</p>
</li>
<li><p>可能触发额外不必要的 Young GC，JDK 有一个 Bug，有一定的几率，本来只该触发一次 GCLocker Initiated GC 的 Young GC，实际发生了一次 Allocation Failure GC 又紧接着一次 GCLocker Initiated GC。是因为 GCLocker Initiated GC 的属性被设为 full，导致两次 GC 不能收敛。</p>
</li>
</ul>
<h5 id="策略-8"><a href="#策略-8" class="headerlink" title="策略"></a>策略</h5><ul>
<li><p>添加 -XX+PrintJNIGCStalls 参数，可以打印出发生 JNI 调用时的线程，进一步分析，找到引发问题的 JNI 调用。</p>
</li>
<li><p>JNI 调用需要谨慎，不一定可以提升性能，反而可能造成 GC 问题。</p>
</li>
<li><p>升级 JDK 版本到 14，避免 JDK-8048556 导致的重复 GC。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这里，我们把整个文章内容总结一下，方便大家整体地理解回顾。</p>
<h4 id="处理流程（SOP）"><a href="#处理流程（SOP）" class="headerlink" title="处理流程（SOP）"></a>处理流程（SOP）</h4><p>下图为整体 GC 问题普适的处理流程，重点的地方下面会单独标注，其他的基本都是标准处理流程，此处不再赘述，最后在整个问题都处理完之后有条件的话建议做一下复盘。</p>
<p><img src="https://s3.ax1x.com/2020/11/18/Dm1s8s.png" alt="Dm1s8s.png"></p>
<ul>
<li><p>制定标准： 这块内容其实非常重要，但大部分系统都是缺失的，笔者过往面试的同学中只有不到一成的同学能给出自己的系统 GC 标准到底什么样，其他的都是用的统一指标模板，缺少预见性，需要结合应用系统的 TP9999 时间和延迟、吞吐量等设定具体的指标，而不是被问题驱动。</p>
</li>
<li><p>保留现场： 目前线上服务基本都是分布式服务，某个节点发生问题后，如果条件允许一定不要直接操作重启、回滚等动作恢复，优先通过摘掉流量的方式来恢复，这样我们可以将堆、栈、GC 日志等关键信息保留下来，不然错过了定位根因的时机，后续解决难度将大大增加。当然除了这些，应用日志、中间件日志、内核日志、各种 Metrics 指标等对问题分析也有很大帮助。</p>
</li>
<li><p>因果分析： 判断 GC 异常与其他系统指标异常的因果关系，可以参考笔者在 3.2 中介绍的时序分析、概率分析、实验分析、反证分析等 4 种因果分析法，避免在排查过程中走入误区。</p>
</li>
<li><p>根因分析： 确实是 GC 的问题后，可以借助上文提到的工具并通过 5 why 根因分析法以及跟第三节中的九种常见的场景进行逐一匹配，或者直接参考下文的根因鱼骨图，找出问题发生根因，最后再选择优化手段。</p>
</li>
</ul>
<h4 id="根因鱼骨图"><a href="#根因鱼骨图" class="headerlink" title="根因鱼骨图"></a>根因鱼骨图</h4><p>送上一张问题根因鱼骨图，一般情况下我们在处理一个 GC 问题时，只要能定位到问题的“病灶”，有的放矢，其实就相当于解决了 80%，如果在某些场景下不太好定位，大家可以借助这种根因分析图通过排除法去定位。</p>
<p><img src="https://s3.ax1x.com/2020/11/18/Dm39xI.png" alt="Dm39xI.png"></p>
<h4 id="调优建议"><a href="#调优建议" class="headerlink" title="调优建议"></a>调优建议</h4><ul>
<li><p>Trade Off： 与 CAP 注定要缺一角一样，GC 优化要在延迟（Latency）、吞吐量（Throughput）、容量（Capacity）三者之间进行权衡。</p>
</li>
<li><p>最终手段： GC 发生问题不是一定要对 JVM 的 GC 参数进行调优，大部分情况下是通过 GC 的情况找出一些业务问题，切记上来就对 GC 参数进行调整，当然有明确配置错误的场景除外。</p>
</li>
<li><p>控制变量： 控制变量法是在蒙特卡洛（Monte Carlo）方法中用于减少方差的一种技术方法，我们调优的时候尽量也要使用，每次调优过程尽可能只调整一个变量。</p>
</li>
<li><p>善用搜索： 理论上 99.99% 的 GC 问题基本都被遇到了，我们要学会使用搜索引擎的高级技巧，重点关注 StackOverFlow、Github 上的 Issue、以及各种论坛博客，先看看其他人是怎么解决的，会让解决问题事半功倍。能看到这篇文章，你的搜索能力基本过关了~</p>
</li>
<li><p>调优重点： 总体上来讲，我们开发的过程中遇到的问题类型也基本都符合正态分布，太简单或太复杂的基本遇到的概率很低，笔者这里将中间最重要的三个场景添加了“*”标识，希望阅读完本文之后可以观察下自己负责的系统，是否存在上述问题。</p>
</li>
<li><p>GC 参数： 如果堆、栈确实无法第一时间保留，一定要保留 GC 日志，这样我们最起码可以看到 GC Cause，有一个大概的排查方向。关于 GC 日志相关参数，最基本的 -XX:+HeapDumpOnOutOfMemoryError 等一些参数就不再提了，笔者建议添加以下参数，可以提高我们分析问题的效率。</p>
</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/18/Dm3eiQ.png" alt="Dm3eiQ.png"></p>
<ul>
<li><p>其他建议： 上文场景中没有提到，但是对 GC 性能也有提升的一些建议。</p>
</li>
<li><p>主动式 GC： 也有另开生面的做法，通过监控手段监控观测 Old 区的使用情况，即将到达阈值时将应用服务摘掉流量，手动触发一次 Major GC，减少 CMS GC 带来的停顿，但随之系统的健壮性也会减少，如非必要不建议引入。</p>
</li>
<li><p>禁用偏向锁： 偏向锁在只有一个线程使用到该锁的时候效率很高，但是在竞争激烈情况会升级成轻量级锁，此时就需要先消除偏向锁，这个过程是 STW 的。如果每个同步资源都走这个升级过程，开销会非常大，所以在已知并发激烈的前提下，一般会禁用偏向锁 -XX:-UseBiasedLocking 来提高性能。</p>
</li>
<li><p>虚拟内存： 启动初期有些操作系统（例如 Linux）并没有真正分配物理内存给 JVM ，而是在虚拟内存中分配，使用的时候才会在物理内存中分配内存页，这样也会导致 GC 时间较长。这种情况可以添加 -XX:+AlwaysPreTouch 参数，让 VM 在 commit 内存时跑个循环来强制保证申请的内存真的 commit，避免运行时触发缺页异常。在一些大内存的场景下，有时候能将前几次的 GC 时间降一个数量级，但是添加这个参数后，启动的过程可能会变慢。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> jvm </category>
            
            <category> gc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
            <tag> gc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tomcat classloader源码详解]]></title>
      <url>/2020/11/15/tomcat-classloader/</url>
      <content type="html"><![CDATA[<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="java">public void init() throws Exception {

        // 初始化，后文会说这个方法
        initClassLoaders();

        // 设置线程类加载器
        Thread.currentThread().setContextClassLoader(catalinaLoader);

        SecurityClassLoad.securityClassLoad(catalinaLoader);

        // Load our startup class and call its process() method
        // 通过之前初始化的classloader反射实例化Catalina类的实例
        Class&lt;?&gt; startupClass =
            catalinaLoader.loadClass
            (&quot;org.apache.catalina.startup.Catalina&quot;);
        Object startupInstance = startupClass.newInstance();
        // Set the shared extensions class loader
        if (log.isDebugEnabled())
            log.debug(&quot;Setting startup class properties&quot;);
        String methodName = &quot;setParentClassLoader&quot;;
        Class&lt;?&gt; paramTypes[] = new Class[1];
        paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;);
        Object paramValues[] = new Object[1];
        paramValues[0] = sharedLoader;
        Method method =
            startupInstance.getClass().getMethod(methodName, paramTypes);

        // Catalina#setParentClassLoader为sharedLoader
        // 因为sharedLoader默认就是commonloader
        // 当然Catalina默认也是commonloader
        // 为啥不直接设置成commonclassloader呢？
        // 因为webappclassloader会把自己的parentclassloader设置成Catalina的ParentClassLoader
        // 注意是Catalina对象的爹是sharedLoader
        // catalinaLoader的爹仍旧是commonloader
        // 为啥这样？Catalina对象由catalinaLoader加载，Catalina对象的爹是sharedLoader，catalinaLoader的爹却是commonloader？ 求解
        method.invoke(startupInstance, paramValues);

        catalinaDaemon = startupInstance;

    }
</code></pre>
<p>initClassLoader()方法：</p>
<pre><code class="java">private void initClassLoaders() {
        try {
            // 默认情况下common.loader是有值的
            // common.loader=&quot;${catalina.base}/lib&quot;,&quot;${catalina.base}/lib/*.jar&quot;,&quot;${catalina.home}/lib&quot;,&quot;${catalina.home}/lib/*.jar&quot;
            commonLoader = createClassLoader(&quot;common&quot;, null);
            if( commonLoader == null ) {
                // no config file, default to this loader - we might be in a &#39;single&#39; env.
                commonLoader = this.getClass().getClassLoader();
            }
            // catalinaLoader和sharedLoader实际上有共同的父类加载器commonLoader
            // 而如果server.loader, shared.loader为空
            // 那么此时的catalinaLoader,sharedLoader其实是同一个ClassLoader ———— commonclassloader
            catalinaLoader = createClassLoader(&quot;server&quot;, commonLoader);
            sharedLoader = createClassLoader(&quot;shared&quot;, commonLoader);
        } catch (Throwable t) {
            log.error(&quot;Class loader creation threw exception&quot;, t);
            System.exit(1);
        }
}
</code></pre>
<p>createClassLoader()方法：</p>
<pre><code class="java">private ClassLoader createClassLoader(String name, ClassLoader parent) throws Exception {

    String value = CatalinaProperties.getProperty(name + &quot;.loader&quot;);
    // 判断如果catalina.properties中没有配置对应的loader属性的话，直接返回父加载器
    // 而默认情况下，server.loader, shared.loader为空，那么此时的catalinaLoader,sharedLoader其实是同一个ClassLoader ————commonloader
    if ((value == null) || (value.equals(&quot;&quot;)))
        return parent;

    value = replace(value);

    List&lt;Repository&gt; repositories = new ArrayList&lt;Repository&gt;();

    StringTokenizer tokenizer = new StringTokenizer(value, &quot;,&quot;);
    while (tokenizer.hasMoreElements()) {
        String repository = tokenizer.nextToken().trim();
        if (repository.length() == 0) {
            continue;
        }

        // Check for a JAR URL repository
        try {
            @SuppressWarnings(&quot;unused&quot;)
            URL url = new URL(repository);
            repositories.add(
                    new Repository(repository, RepositoryType.URL));
            continue;
        } catch (MalformedURLException e) {
            // Ignore
        }

        // Local repository
        if (repository.endsWith(&quot;*.jar&quot;)) {
            repository = repository.substring
                (0, repository.length() - &quot;*.jar&quot;.length());
            repositories.add(
                    new Repository(repository, RepositoryType.GLOB));
        } else if (repository.endsWith(&quot;.jar&quot;)) {
            repositories.add(
                    new Repository(repository, RepositoryType.JAR));
        } else {
            repositories.add(
                    new Repository(repository, RepositoryType.DIR));
        }
    }
    //这里返回的是一个UrlClassLoader实例
    //最终调用org.apache.catalina.startup.ClassLoaderFactory#createClassLoader静态工厂方法创建了URLClassloader的实例
    //而具体的URL其实就是*.loader属性配置的内容
    ClassLoader classLoader = ClassLoaderFactory.createClassLoader
        (repositories, parent);


    return classLoader;

}
</code></pre>
<p>查看org.apache.catalina.startup.Catalina#getParentClassLoader调用栈，我们看到在StandardContext的startInternal方法中调用了它，那么我们查看一下它的代码，包含了如下代码片段：</p>
<pre><code class="java">if (getLoader() == null) {
    // 初始化WebappLoader，把他的爹设置为sharedloader
            WebappLoader webappLoader = new WebappLoader(getParentClassLoader());
            webappLoader.setDelegate(getDelegate());
            setLoader(webappLoader);
}
try {

    if (ok) {

        // Start our subordinate components, if any
        if ((loader != null) &amp;&amp; (loader instanceof Lifecycle))
            ((Lifecycle) loader).start();
        //other code    
    }
catch(Exception e){
}
</code></pre>
<p>因为WebappLoader符合Tomcat组件生命周期管理的模板方法模式，因此会调用到它的startInternal方法。我们接下来就来看看WebappLoader的startInternal，我们摘取一部分与本篇相关的代码片段如下：</p>
<pre><code class="java">classLoader = createClassLoader();
classLoader.setResources(container.getResources());
// 设置是否配置委派模式
classLoader.setDelegate(this.delegate);
classLoader.setSearchExternalFirst(searchExternalFirst);
</code></pre>
<p>从上的代码可以看到调用了createClassLoader方法创建一个classLoader，那么我们再看来看看createClassLoader的代码：</p>
<pre><code class="java">private WebappClassLoader createClassLoader()
    throws Exception {

// classLoader是WebappLoader的实例变量，其值为org.apache.catalina.loader.WebappClassLoader，其实就是通过反射调用了WebappClassLoader的构造函数，然后传递了sharedLoader作为其父亲加载器。
    Class&lt;?&gt; clazz = Class.forName(loaderClass);
    WebappClassLoader classLoader = null;

    if (parentClassLoader == null) {
        parentClassLoader = container.getParentClassLoader();
    }
    Class&lt;?&gt;[] argTypes = { ClassLoader.class };
    Object[] args = { parentClassLoader };
    Constructor&lt;?&gt; constr = clazz.getConstructor(argTypes);
    classLoader = (WebappClassLoader) constr.newInstance(args);

    return classLoader;

}
</code></pre>
<p>进一步来分析一下WebAppClassLoader的代码，在Java自定义类加载器，一般情况下，我们只需要重写findClass方法就好了，而对于WebAppClassLoader，通过查看源代码，我们发现loadClass和findClass方法都进行了重写，那么我们首先就来看看它的loadClass方法,它的代码如下：</p>
<pre><code class="java">public synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException {

    if (log.isDebugEnabled())
        log.debug(&quot;loadClass(&quot; + name + &quot;, &quot; + resolve + &quot;)&quot;);
    Class&lt;?&gt; clazz = null;

    // Log access to stopped classloader
    if (!started) {
        try {
            throw new IllegalStateException();
        } catch (IllegalStateException e) {
            log.info(sm.getString(&quot;webappClassLoader.stopped&quot;, name), e);
        }
    }

    // (0) Check our previously loaded local class cache
    // 首先从当前ClassLoader的本地缓存中加载类，如果找到则返回。
    clazz = findLoadedClass0(name);
    if (clazz != null) {
        if (log.isDebugEnabled())
            log.debug(&quot;  Returning class from cache&quot;);
        if (resolve)
            resolveClass(clazz);
        return (clazz);
    }

    // (0.1) Check our previously loaded class cache
    // 在本地缓存没有的情况下，调用ClassLoader的findLoadedClass方法查看jvm是否已经加载过此类，如果已经加载则直接返回。
    clazz = findLoadedClass(name);
    if (clazz != null) {
        if (log.isDebugEnabled())
            log.debug(&quot;  Returning class from cache&quot;);
        if (resolve)
            resolveClass(clazz);
        return (clazz);
    }

    // (0.2) Try loading the class with the system class loader, to prevent
    //       the webapp from overriding J2SE classes
    // 通过系统的来加载器加载此类，这里防止应用写的类覆盖了J2SE的类,这句代码非常关键，如果不写的话，就会造成你自己写的类有可能会把J2SE的类给替换调，另外假如你写了一个javax.servlet.Servlet类，放在当前应用的WEB-INF/class中，如果没有此句代码的保证，那么你自己写的类就会替换到Tomcat容器Lib中包含的类。
    try {
        clazz = system.loadClass(name);
        if (clazz != null) {
            if (resolve)
                resolveClass(clazz);
            return (clazz);
        }
    } catch (ClassNotFoundException e) {
        // Ignore
    }

    // (0.5) Permission to access this class when using a SecurityManager
    if (securityManager != null) {
        int i = name.lastIndexOf(&#39;.&#39;);
        if (i &gt;= 0) {
            try {
                securityManager.checkPackageAccess(name.substring(0,i));
            } catch (SecurityException se) {
                String error = &quot;Security Violation, attempt to use &quot; +
                    &quot;Restricted Class: &quot; + name;
                log.info(error, se);
                throw new ClassNotFoundException(error, se);
            }
        }
    }

    // 判断是否需要委托给父类加载器进行加载，delegate属性默认为false，那么delegatedLoad的值就取决于filter的返回值了，filter方法中根据包名来判断是否需要进行委托加载，默认情况下会返回false.因此delegatedLoad为false
    boolean delegateLoad = delegate || filter(name);

    // (1) Delegate to our parent if requested
    // 因为delegatedLoad为false,那么此时不会委托父加载器去加载，这里其实是没有遵循parent-first的加载机制。
    if (delegateLoad) {
        if (log.isDebugEnabled())
            log.debug(&quot;  Delegating to parent classloader1 &quot; + parent);
        ClassLoader loader = parent;
        if (loader == null)
            loader = system;
        try {
            clazz = Class.forName(name, false, loader);
            if (clazz != null) {
                if (log.isDebugEnabled())
                    log.debug(&quot;  Loading class from parent&quot;);
                if (resolve)
                    resolveClass(clazz);
                return (clazz);
            }
        } catch (ClassNotFoundException e) {
            // Ignore
        }
    }

    // (2) Search local repositories
    if (log.isDebugEnabled())
        log.debug(&quot;  Searching local repositories&quot;);
    // 调用findClass方法在webapp级别进行加载
    try {
        clazz = findClass(name);
        if (clazz != null) {
            if (log.isDebugEnabled())
                log.debug(&quot;  Loading class from local repository&quot;);
            if (resolve)
                resolveClass(clazz);
            return (clazz);
        }
    } catch (ClassNotFoundException e) {
        // Ignore
    }

    // (3) Delegate to parent unconditionally
    // 如果还是没有加载到类，并且不采用委托机制的话，则通过父类加载器去加载。
    if (!delegateLoad) {
        if (log.isDebugEnabled())
            log.debug(&quot;  Delegating to parent classloader at end: &quot; + parent);
        ClassLoader loader = parent;
        if (loader == null)
            loader = system;
        try {
            clazz = Class.forName(name, false, loader);
            if (clazz != null) {
                if (log.isDebugEnabled())
                    log.debug(&quot;  Loading class from parent&quot;);
                if (resolve)
                    resolveClass(clazz);
                return (clazz);
            }
        } catch (ClassNotFoundException e) {
            // Ignore
        }
    }

    throw new ClassNotFoundException(name);

}
</code></pre>
<p>接着在来分析一下findClass，通过分析findClass的代码，最终会调用org.apache.catalina.loader.WebappClassLoader#findClassInternal方法，那我们就来分析一下它的代码：</p>
<pre><code class="java">protected Class&lt;?&gt; findClassInternal(String name)
    throws ClassNotFoundException {

    //
    if (!validate(name))
        throw new ClassNotFoundException(name);

    String tempPath = name.replace(&#39;.&#39;, &#39;/&#39;);
    String classPath = tempPath + &quot;.class&quot;;

    ResourceEntry entry = null;

    if (securityManager != null) {
        PrivilegedAction&lt;ResourceEntry&gt; dp =
            new PrivilegedFindResourceByName(name, classPath);
        entry = AccessController.doPrivileged(dp);
    } else {
        // 通过名称去当前webappClassLoader的仓库中查找对应的类文件
        entry = findResourceInternal(name, classPath);
    }

    if (entry == null)
        throw new ClassNotFoundException(name);

    Class&lt;?&gt; clazz = entry.loadedClass;
    if (clazz != null)
        return clazz;

    synchronized (this) {
        clazz = entry.loadedClass;
        if (clazz != null)
            return clazz;

        if (entry.binaryContent == null)
            throw new ClassNotFoundException(name);

        try {
            // 将找到的类文件通过defineClass转变为Jvm可以识别的Class对象返回
            clazz = defineClass(name, entry.binaryContent, 0,
                    entry.binaryContent.length,
                    new CodeSource(entry.codeBase, entry.certificates));
        } catch (UnsupportedClassVersionError ucve) {
            throw new UnsupportedClassVersionError(
                    ucve.getLocalizedMessage() + &quot; &quot; +
                    sm.getString(&quot;webappClassLoader.wrongVersion&quot;,
                            name));
        }
        entry.loadedClass = clazz;
        entry.binaryContent = null;
        entry.source = null;
        entry.codeBase = null;
        entry.manifest = null;
        entry.certificates = null;
    }

    return clazz;

}
</code></pre>
]]></content>
      
        <categories>
            
            <category> classLoader </category>
            
            <category> jvm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> classLoader </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[classloader详解]]></title>
      <url>/2020/11/14/classloader-classpath-hell/</url>
      <content type="html"><![CDATA[<h2 id="类加载的顺序"><a href="#类加载的顺序" class="headerlink" title="类加载的顺序"></a>类加载的顺序</h2><p><img src="https://s3.ax1x.com/2020/11/17/DVLBkt.png" alt="DVLBkt.png"></p>
<p>六种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之 前开始):</p>
<ul>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有:<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)<br>的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ul>
<p><code>static{}</code>代码块会执行<code>&lt;clinit&gt;()</code>，并在方法构造器<code>&lt;init&gt;()</code>之前执行，注意<code>static{}</code>可以访问和赋值在他之前生命的静态变量，但对于其后生命的变量只能赋值，不能访问。父类永远先于子类执行。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。即，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器:</p>
<ul>
<li>一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分;</li>
<li>另外一种就是其他所有 的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p>站在Java开发者的角度来说，绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载：</p>
<ul>
<li>启动类加载器(Bootstrap Class Loader):前面已经介绍过，这个类加载器负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的(按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</li>
<li>扩展类加载器(Extension Class Loader):这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>以Java代码的形式实现的。它负责加载<code>&lt;JAVA_HOM E&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所 指定的路径中所有的类库。根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK 9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</li>
<li>应用程序类加载器(Application Class Loader):这个类加载器由<br><code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，所以也称它为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/17/DZCFu6.png" alt="DZCFu6.png"></p>
<p>双亲委派模型的工作过程是:如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去完成加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。相同包名的同名类只能在一个类加载器中加载，从而避免混乱。</p>
<pre><code class="java">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // 首先，检查请求的类是否已经被加载过了 
    Class c = findLoadedClass(name); 
    if (c == null) {
        try {
            if (parent != null) {
                c = parent.loadClass(name, false);
            } else {
            c = findBootstrapClassOrNull(name); }
        } catch (ClassNotFoundException e) {
        // 如果父类加载器抛出ClassNotFoundException 
        // 说明父类加载器无法完成加载请求
        }
        if (c == null) {
            // 在父类加载器无法加载时
            // 再调用本身的findClass方法来进行类加载 
            c = findClass(name);
        } 
    }
    if (resolve) { 
        resolveClass(c);
    }
    return c; 
}
</code></pre>
<h3 id="破坏双亲委派"><a href="#破坏双亲委派" class="headerlink" title="破坏双亲委派"></a>破坏双亲委派</h3><h4 id="自定义classloader"><a href="#自定义classloader" class="headerlink" title="自定义classloader"></a>自定义classloader</h4><p>类加载器的概念和抽象类java.lang.ClassLoader无法避免loadClass()被子类覆盖，只能通过protected方法findClass()，并引导用写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="线程上下文类加载器-Thread-Context-ClassLoader"><a href="#线程上下文类加载器-Thread-Context-ClassLoader" class="headerlink" title="线程上下文类加载器 (Thread Context ClassLoader)"></a>线程上下文类加载器 (Thread Context ClassLoader)</h4><p>以jndi为例：<br>JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程 序的ClassPath下的JNDI服务提供者接口(Service Provider Interface，SPI)的代码，但启动类加载器是绝不可能认识、加载这些代码的。</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计:线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在SPI接口的代码中使用线程上下文类加载器，就可以成功的加载到SPI实现的类。</p>
<p>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则。</p>
<h4 id="OSGi"><a href="#OSGi" class="headerlink" title="OSGi"></a>OSGi</h4><p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGi中称为 Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实 现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p>
<h4 id="Java9中的模块化"><a href="#Java9中的模块化" class="headerlink" title="Java9中的模块化"></a>Java9中的模块化</h4><p>一篇详细讲解模块化的文章<br><a href="http://seanthefish.com/2018/03/29/module-system/">http://seanthefish.com/2018/03/29/module-system/</a></p>
<p>jdk9提出了与“类路径”(ClassPath)相对应的“模块路径”(M odulePath)的概念。某个类库到底是模块还是传统的JAR包，只取决于它存放在哪种路径上。只要是放在类路径上的JAR文件，无论其中是否包含模块化信息(是否包含了module-info.class文件)，它都会被当作传统的JAR包来对待;相应地，只 要放在模块路径上的JAR文件，即使没有使用JMOD后缀，甚至说其中并不包含module-info.class文 件，它也仍然会被当作一个模块来对待。</p>
<ul>
<li>JAR文件在类路径的访问规则:所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块(Unnamed Module)里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路 径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li>
<li>模块在模块路径的访问规则:模块路径下的具名模块(Named Module)只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。</li>
<li>JAR文件在模块路径的访问规则:如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块(Automatic Module)。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li>
</ul>
<p>在模块化的java9中：</p>
<ul>
<li>扩展类加载器(Extension Class Loader)被平台类加载器(Platform Class Loader)取代。</li>
<li>平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader，如果有程序直接 依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK 9及更高版 本的JDK中崩溃。</li>
<li>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/17/DZZ78S.png" alt="DZZ78S.png"></p>
<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>Tomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类(Object,String等)，各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。</p>
<p>首先要了解的是，tomcat有两中类加载器模式：</p>
<p>默认情况下：</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZJNi4.png" alt="DZJNi4.png"></p>
<p>高级模式：</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZJRWd.png" alt="DZJRWd.png"></p>
<p>根据conf/catalina.properties文件中common.loader，server.loader，shared.loader的值来初始化commonLoader,catalinaLoader,sharedLoader，其中catalinaLoader,sharedLoader的父亲加载器是commonLoader，默认情况下，这3个ClassLoader是同一个实例变量。</p>
<p>tomcat容器不希望它下面的webapps之间能互相访问到，所以不能用jvm中的appClassLoarder去加载。所以tomcat新建一个sharedClassLoader（它的parent是commonClassLoader，commonClassLoader的parent是jvm中的appClassLoarder，默认情况下，sharedClassLoader和commonClassLoader是同一个UrlClassLoader实例），这是catalina容器使用的ClassLoader。对于每个webapp，为其新建一个webappClassLoader，用于加载webapp下面的类，这样webapp之间就不能相互访问了。tomcat的ClassLoader不完全遵循双亲委派，首先用webappClassLoader去加载某个类，如果找不到，再交给parent。而对于java核心库，不在tomcat的ClassLoader的加载范围。</p>
<ul>
<li>commonLoader：Tomcat最基本的类加载器，加载路径（/common/*）中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li>catalinaLoader：Tomcat容器私有的类加载器，加载路径（/server/*）中的class对于Webapp不可见；</li>
<li>sharedLoader：各个Webapp共享的类加载器，加载路径（/shared/*（在tomcat 6之后已经合并到根目录下的lib目录下））中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li>WebappClassLoader：各个Webapp私有的类加载器，加载路径（/WebApp/WEB-INF/*中的Java类库）中的class只对当前Webapp可见；</li>
</ul>
<p>当应用需要到某个类时，默认会按照下面的顺序进行类加载（不使用委派模式）：</p>
<ul>
<li>使用bootstrapclassloader加载器加载</li>
<li>使用webapppclassloader加载器在WEB-INF/classes中加载</li>
<li>使用webapppclassloader加载器在WEB-INF/lib中加载</li>
<li>使用appclassloader（systemclassloader）加载器加载</li>
<li>使用commonclassloader在CATALINA_HOME/lib中加载</li>
</ul>
<p>使用委派模式的话（配置<code>&lt;Loader delegate=&quot;true&quot;/&gt;</code>）:</p>
<ul>
<li>使用bootstrapclassloader加载器加载</li>
<li>使用appclassloader（systemclassloader）加载器加载</li>
<li>使用commonclassloader在CATALINA_HOME/lib中加载</li>
<li>使用webapppclassloader加载器在WEB-INF/classes中加载</li>
<li>使用webapppclassloader加载器在WEB-INF/lib中加载</li>
</ul>
<h2 id="was"><a href="#was" class="headerlink" title="was"></a>was</h2><p>简单说一下was，直接上图</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZ0PDs.png" alt="DZ0PDs.png"></p>
<p>was里分为Parent_first和Parent_last模式</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZ03Ux.png" alt="DZ03Ux.png"></p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZ0aKH.png" alt="DZ0aKH.png"></p>
<p>同时在was的appclassloader级别（即为ear）和webmoduleclassloader级别（即为war）都分别具备隔离和共享两种classloader模式。</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZ0LM4.png" alt="DZ0LM4.png"></p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZ0vZR.png" alt="DZ0vZR.png"></p>
<p>Shared Library模式</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZBALd.png" alt="DZBALd.png"></p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZBZdI.png" alt="DZBZdI.png"></p>
<p>独立的shared library模式（有自己的classloader，且必须为PARENT_LAST模式）</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZBJwn.png" alt="DZBJwn.png"></p>
<p>常见问题：<br>（图片里说的很清楚，故不做多余解释，这些问题也可以引申到其他的服务器中）</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZB0lF.png" alt="DZB0lF.png"><br>Solution:<br> Create a shared library to hold the test1.jar file and associate the shared library with both EAR1 and EAR2.</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZB46e.png" alt="DZB46e.png"><br>Solution:<br> Place the dependent jars, test3.jar, in the same classloader as test1.jar so that both jar files are loaded by the same class loaderand visible to each other. </p>
<p><img src="https://s3.ax1x.com/2020/11/17/DZB7TI.png" alt="DZB7TI.png"><br>Solution:<br> Set the application class loader mode to parent_last so the correct version from the EAR file to be picked up first.<br> Or remove the duplicate class (wrong version) from the shared library.</p>
<p>又想起了曾经被was支配的恐惧。<br>打fatjar还是最简单有效的。</p>
]]></content>
      
        <categories>
            
            <category> classLoader </category>
            
            <category> jvm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> classLoader </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gc调优]]></title>
      <url>/2020/11/13/improve-gc/</url>
      <content type="html"><![CDATA[<p>先贴个图</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAwfZ6.png" alt="DAwfZ6.png"></p>
<h2 id="如何阅读gclog："><a href="#如何阅读gclog：" class="headerlink" title="如何阅读gclog："></a>如何阅读gclog：</h2><p>以其中一行为例来解读下日志信息：</p>
<p>[GC (Allocation Failure) [ParNew: 367523K-&gt;1293K(410432K), 0.0023988 secs] 522739K-&gt;156516K(1322496K), 0.0025301 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]</p>
<p>GC：<br>表明进行了一次垃圾回收，前面没有Full修饰，表明这是一次Minor GC ,注意它不表示只GC新生代，并且现有的不管是新生代还是老年代都会STW。</p>
<p>Allocation Failure：<br>表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
<p>ParNew：<br>表明本次GC发生在年轻代并且使用的是ParNew垃圾收集器。ParNew是一个Serial收集器的多线程版本，会使用多个CPU和线程完成垃圾收集工作（默认使用的线程数和CPU数相同，可以使用-XX：ParallelGCThreads参数限制）。该收集器采用复制算法回收内存，期间会停止其他工作线程，即Stop The World。</p>
<p>367523K-&gt;1293K(410432K)：单位是KB<br>三个参数分别为：GC前该内存区域(这里是年轻代)使用容量，GC后该内存区域使用容量，该内存区域总容量。</p>
<p>0.0023988 secs：<br>该内存区域GC耗时，单位是秒</p>
<p>522739K-&gt;156516K(1322496K)：<br>三个参数分别为：堆区垃圾回收前的大小，堆区垃圾回收后的大小，堆区总大小。</p>
<p>0.0025301 secs：<br>该内存区域GC耗时，单位是秒</p>
<p>[Times: user=0.04 sys=0.00, real=0.01 secs]：<br>分别表示用户态耗时，内核态耗时和总耗时</p>
<p>分析下可以得出结论：</p>
<p>该次GC新生代减少了367523-1293=366239K</p>
<p>Heap区总共减少了522739-156516=366223K</p>
<p>366239 – 366223 =16K，说明该次共有16K内存从年轻代移到了老年代，可以看出来数量并不多，说明都是生命周期短的对象，只是这种对象有很多。</p>
<p>我们需要的是尽量避免Full GC的发生，让对象尽可能的在年轻代就回收掉，所以这里可以稍微增加一点年轻代的大小，让那17K的数据也保存在年轻代中。</p>
<h2 id="常见配置举例"><a href="#常见配置举例" class="headerlink" title="常见配置举例"></a>常见配置举例</h2><h3 id="堆大小设置"><a href="#堆大小设置" class="headerlink" title="堆大小设置"></a>堆大小设置</h3><p>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统 下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。</p>
<p>典型设置：<br><code>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</code></p>
<p>-Xmx3550m：设置JVM最大可用内存为3550M。</p>
<p>-Xms3550m：设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p>
<p>-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p>
<p>-Xss128k： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内 存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
<p><code>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</code></p>
<p>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</p>
<p>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
<p>-XX:MaxPermSize=16m:设置持久代大小为16m。</p>
<p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p>
<h3 id="回收器选择"><a href="#回收器选择" class="headerlink" title="回收器选择"></a>回收器选择</h3><p>JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。</p>
<h4 id="吞吐量优先的并行收集器"><a href="#吞吐量优先的并行收集器" class="headerlink" title="吞吐量优先的并行收集器"></a>吞吐量优先的并行收集器</h4><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。</p>
<p>典型配置：<br><code>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</code></p>
<p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</p>
<p>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p>
<p><code>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</code></p>
<p>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</p>
<p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100</p>
<p>-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p>
<p><code>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</code></p>
<p>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</p>
<h4 id="响应时间优先的并发收集器"><a href="#响应时间优先的并发收集器" class="headerlink" title="响应时间优先的并发收集器"></a>响应时间优先的并发收集器</h4><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。</p>
<p>典型配置：<br><code>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></p>
<p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</p>
<p>-XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p>
<p><code>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</code></p>
<p>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p>
<p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片。</p>
<h3 id="常见配置汇总"><a href="#常见配置汇总" class="headerlink" title="常见配置汇总"></a>常见配置汇总</h3><h4 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h4><p>-Xms:初始堆大小<br>-Xmx:最大堆大小<br>-XX:NewSize=n:设置年轻代大小<br>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4<br>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5<br>-XX:MaxPermSize=n:设置持久代大小</p>
<h4 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h4><p>-XX:+UseSerialGC:设置串行收集器<br>-XX:+UseParallelGC:设置并行收集器<br>-XX:+UseParalledlOldGC:设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC:设置并发收集器</p>
<h5 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h5><p>-XX:+PrintGC<br>-XX:+Printetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename</p>
<h5 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h5><p>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)<br>并发收集器设置<br>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><h3 id="年轻代大小选择"><a href="#年轻代大小选择" class="headerlink" title="年轻代大小选择"></a>年轻代大小选择</h3><p>响应时间优先的应用：设置接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。ps：并非堆越大越好，大堆full gc时间就长，停顿时间变长。在full gc发生不可控的情况下，大内存的物理机考虑使用集群化环境。</p>
<p>吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</p>
<h3 id="年老代大小选择"><a href="#年老代大小选择" class="headerlink" title="年老代大小选择"></a>年老代大小选择</h3><p>响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p>
<ul>
<li>并发垃圾收集信息</li>
<li>持久代并发收集次数</li>
<li>传统GC信息</li>
<li>花在年轻代和年老代回收上的时间比例</li>
<li>减少年轻代和年老代花费的时间，一般会提高应用的效率</li>
</ul>
<p>吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</p>
<h3 id="较小堆引起的碎片问题"><a href="#较小堆引起的碎片问题" class="headerlink" title="较小堆引起的碎片问题"></a>较小堆引起的碎片问题</h3><p>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出 现“碎片”，可能需要进行如下配置：<br>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。<br>-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩。</p>
<h3 id="高分配速率-High-Allocation-Rate"><a href="#高分配速率-High-Allocation-Rate" class="headerlink" title="高分配速率(High Allocation Rate)"></a>高分配速率(High Allocation Rate)</h3><p>分配速率(Allocation rate)表示单位时间内分配的内存量。通常使用 MB/sec作为单位, 也可以使用 PB/year 等。</p>
<p>计算上一次垃圾收集之后,与下一次GC开始之前的年轻代使用量, 两者的差值除以时间,就是分配速率。</p>
<p>分配速率过高就会严重影响程序的性能。在JVM中会导致巨大的GC开销。</p>
<h4 id="分配速率的意义"><a href="#分配速率的意义" class="headerlink" title="分配速率的意义"></a>分配速率的意义</h4><p>分配速率的变化,会增加或降低GC暂停的频率, 从而影响吞吐量。但只有年轻代的 minor GC受分配速率的影响, 老年代GC的频率和持续时间不受分配速率(allocation rate)的直接影响, 而是受到提升速率(promotion rate)的影响, 请参见下文。</p>
<p>现在我们只关心Minor GC暂停, 查看年轻代的3个内存池。因为对象在Eden区分配, 所以我们一起来看Eden区的大小和分配速率的关系。看看增加Eden区的容量, 能不能减少Minor GC暂停次数, 从而使程序能够维持更高的分配速率。</p>
<p>经过我们的实验, 通过参数-XX:NewSize、 -XX:MaxNewSize以及 -XX:SurvivorRatio设置不同的Eden空间, 运行同一程序时, 可以发现:</p>
<ul>
<li>Eden 空间为 100 MB 时, 分配速率低于 100 MB/秒。</li>
<li>将 Eden 区增大为 1 GB, 分配速率也随之增长,大约等于 200 MB/秒。</li>
</ul>
<p>为什么会这样? —— 因为减少GC暂停,就等价于减少了任务线程的停顿，就可以做更多工作, 也就创建了更多对象, 所以对同一应用来说, 分配速率越高越好。</p>
<p>在得出 “Eden区越大越好” 这个结论前, 我们注意到, 分配速率可能会,也可能不会影响程序的实际吞吐量。吞吐量和分配速率有一定关系, 因为分配速率会影响 minor GC 暂停, 但对于总体吞吐量的影响, 还要考虑 Major GC(大型GC)暂停, 而且吞吐量的单位不是 MB/秒，而是系统所处理的业务量。</p>
<h4 id="高分配速率对JVM的影响"><a href="#高分配速率对JVM的影响" class="headerlink" title="高分配速率对JVM的影响"></a>高分配速率对JVM的影响</h4><p>demo：</p>
<pre><code class="java">public class BoxingFailure {
  private static volatile Double sensorValue;
  private static void readSensor() {
    while(true) sensorValue = Math.random();
  }
  private static void processSensorValue(Double value) {
    if(value != null) {
      //...
    }
  }
}
</code></pre>
<p>如同类名所示, 这个Demo是模拟 boxing 的。为了 null 值判断, 使用的是包装类型 Double。 程序基于传感器的最新值进行计算, 但从传感器取值是一个重量级操作, 所以采用了异步方式： 一个线程不断获取新值, 计算线程则直接使用暂存的最新值, 从而避免同步等待。</p>
<p>Demo 程序在运行的过程中, 由于分配速率太大而受到GC的影响。</p>
<p>首先，我们应该检查程序的吞吐量是否降低。如果创建了过多的临时对象, minor GC的次数就会增加。如果并发较大, 则GC可能会严重影响吞吐量。</p>
<p>遇到这种情况时, GC日志将会像下面这样，当然这是上面的示例程序 产生的GC日志。 JVM启动参数为 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xmx32m:</p>
<pre><code>2.808: [GC (Allocation Failure) 
        [PSYoungGen: 9760K-&gt;32K(10240K)], 0.0003076 secs]
2.819: [GC (Allocation Failure) 
        [PSYoungGen: 9760K-&gt;32K(10240K)], 0.0003079 secs]
2.830: [GC (Allocation Failure) 
        [PSYoungGen: 9760K-&gt;32K(10240K)], 0.0002968 secs]
2.842: [GC (Allocation Failure) 
        [PSYoungGen: 9760K-&gt;32K(10240K)], 0.0003374 secs]
2.853: [GC (Allocation Failure) 
        [PSYoungGen: 9760K-&gt;32K(10240K)], 0.0004672 secs]
2.864: [GC (Allocation Failure) 
        [PSYoungGen: 9760K-&gt;32K(10240K)], 0.0003371 secs]
2.875: [GC (Allocation Failure) 
        [PSYoungGen: 9760K-&gt;32K(10240K)], 0.0003214 secs]
2.886: [GC (Allocation Failure) 
        [PSYoungGen: 9760K-&gt;32K(10240K)], 0.0003374 secs]
2.896: [GC (Allocation Failure) 
        [PSYoungGen: 9760K-&gt;32K(10240K)], 0.0003588 secs]
</code></pre><p>minor GC的频率过高，就说明创建了大量的对象。而年轻代在GC之后的使用量又很低, 也没有full GC发生。 因此，GC对吞吐量造成了严重的影响。</p>
<p>解决方案<br>在某些情况下,只要增加年轻代的大小, 即可降低分配速率过高所造成的影响。增加年轻代空间并不会降低分配速率, 但是会减少GC的频率。如果每次GC后只有少量对象存活, minor GC 的暂停时间就不会明显增加。</p>
<p>运行 示例程序 时, 增加堆内存大小,(同时也就增大了年轻代的大小), 使用的JVM参数为 -Xmx64m:</p>
<pre><code>2.808: [GC (Allocation Failure) 
        [PSYoungGen: 20512K-&gt;32K(20992K)], 0.0003748 secs]
2.831: [GC (Allocation Failure) 
        [PSYoungGen: 20512K-&gt;32K(20992K)], 0.0004538 secs]
2.855: [GC (Allocation Failure) 
        [PSYoungGen: 20512K-&gt;32K(20992K)], 0.0003355 secs]
2.879: [GC (Allocation Failure) 
        [PSYoungGen: 20512K-&gt;32K(20992K)], 0.0005592 secs]
</code></pre><p>但有时候增加堆内存的大小,并不能解决问题。通过前面学到的知识, 我们可以通过分配分析器找出大部分垃圾产生的位置。实际上在此示例中, 99%的对象属于 Double 包装类, 在readSensor 方法中创建。最简单的优化, 将创建的 Double 对象替换为原生类型 double, 而针对 null 值的检测, 可以使用 Double.NaN 来进行。由于原生类型不算是对象, 也就不会产生垃圾, 导致GC事件。优化之后, 不在堆中分配新对象, 而是直接覆盖一个属性域即可。</p>
<h3 id="过早提升-Premature-Promotion"><a href="#过早提升-Premature-Promotion" class="headerlink" title="过早提升(Premature Promotion)"></a>过早提升(Premature Promotion)</h3><p>提升速率(promotion rate), 用于衡量单位时间内从年轻代提升到老年代的数据量。一般使用 MB/sec 作为单位, 和分配速率类似。</p>
<p>JVM会将长时间存活的对象从年轻代提升到老年代。根据分代假设, 可能存在一种情况, 老年代中不仅有存活时间长的对象,也可能有存活时间短的对象。这就是过早提升：对象存活时间还不够长的时候就被提升到了老年代。</p>
<p>major GC 不是为频繁回收而设计的, 但 major GC 现在也要清理这些生命短暂的对象, 就会导致GC暂停时间过长。这会严重影响系统的吞吐量。</p>
<p>GC之前和之后的 年轻代使用量以及堆内存使用量。这样就可以通过差值算出老年代的使用量。请注意, 只能根据 minor GC 计算提升速率。 Full GC 的日志不能用于计算提升速率, 因为 major GC 会清理掉老年代中的一部分对象。</p>
<h4 id="提升速率的意义"><a href="#提升速率的意义" class="headerlink" title="提升速率的意义"></a>提升速率的意义</h4><p>和分配速率一样, 提升速率也会影响GC暂停的频率。但分配速率主要影响 minor GC, 而提升速率则影响 major GC 的频率。有大量的对象提升,自然很快将老年代填满。 老年代填充的越快, 则 major GC 事件的频率就会越高。</p>
<h4 id="过早提升的影响"><a href="#过早提升的影响" class="headerlink" title="过早提升的影响"></a>过早提升的影响</h4><p>demo:</p>
<pre><code class="java">public class PrematurePromotion {
   private static final Collection&lt;byte[]&gt; accumulatedChunks 
                = new ArrayList&lt;&gt;();
   private static void onNewChunk(byte[] bytes) {
       accumulatedChunks.add(bytes);
       if(accumulatedChunks.size() &gt; MAX_CHUNKS) {
           processBatch(accumulatedChunks);
           accumulatedChunks.clear();
       }
   }
}
</code></pre>
<p>一般来说,过早提升的症状表现为以下形式:</p>
<ul>
<li>短时间内频繁地执行 full GC。</li>
<li>每次 full GC 后老年代的使用率都很低, 在10-20%或以下。</li>
<li>提升速率接近于分配速率。</li>
</ul>
<p>要演示这种情况稍微有点麻烦, 所以我们使用特殊手段, 让对象提升到老年代的年龄比默认情况小很多。指定GC参数 -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1, 运行程序之后,可以看到下面的GC日志:</p>
<pre><code>2.176: [Full GC (Ergonomics) 
        [PSYoungGen: 9216K-&gt;0K(10752K)] 
        [ParOldGen: 10020K-&gt;9042K(12288K)] 
        19236K-&gt;9042K(23040K), 0.0036840 secs]
2.394: [Full GC (Ergonomics) 
        [PSYoungGen: 9216K-&gt;0K(10752K)] 
        [ParOldGen: 9042K-&gt;8064K(12288K)] 
        18258K-&gt;8064K(23040K), 0.0032855 secs]
2.611: [Full GC (Ergonomics) 
        [PSYoungGen: 9216K-&gt;0K(10752K)] 
        [ParOldGen: 8064K-&gt;7085K(12288K)] 
        17280K-&gt;7085K(23040K), 0.0031675 secs]
2.817: [Full GC (Ergonomics) 
        [PSYoungGen: 9216K-&gt;0K(10752K)] 
        [ParOldGen: 7085K-&gt;6107K(12288K)] 
        16301K-&gt;6107K(23040K), 0.0030652 secs]
</code></pre><p>乍一看似乎不是过早提升的问题。事实上,在每次GC之后老年代的使用率似乎在减少。但反过来想, 要是没有对象提升或者提升率很小, 也就不会看到这么多的Full GC了。</p>
<p>简单解释一下这里的GC行为: 有很多对象提升到老年代, 同时老年代中也有很多对象被回收了, 这就造成了老年代使用量减少的假象. 但事实是大量的对象不断地被提升到老年代, 并触发full GC。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>简单来说, 要解决这类问题, 需要让年轻代存放得下暂存的数据。有两种简单的方法:</p>
<p>一是增加年轻代的大小, 设置JVM启动参数, 类似这样: -Xmx64m -XX:NewSize=32m, 程序在执行时, Full GC 的次数自然会减少很多, 只会对 minor GC的持续时间产生影响:</p>
<p>二是减少每次批处理的数量, 也能得到类似的结果. 至于选用哪个方案, 要根据业务需求决定。在某些情况下, 业务逻辑不允许减少批处理的数量, 那就只能增加堆内存,或者重新指定年轻代的大小。</p>
<p>如果都不可行, 就只能优化数据结构, 减少内存消耗。但总体目标依然是一致的: 让临时数据能够在年轻代存放得下。</p>
<h3 id="Weak-Soft-及-Phantom-引用"><a href="#Weak-Soft-及-Phantom-引用" class="headerlink" title="Weak, Soft 及 Phantom 引用"></a>Weak, Soft 及 Phantom 引用</h3><ul>
<li>强引用：代码中普遍存在的类似<code>object obj = new object()</code>的引用，只要强引用存在，垃圾处理器就不会回收。</li>
<li>软引用：描述有些还有用但非必须的对象。在系统将要发生内存溢出时，会将这些对象列为回收范围进行二次回收，如果这次回收后还没有足够的内存，才会oom。Java中SoftReference类表示软引用。</li>
<li>弱引用：描述非必须对象，被弱引用关联的对象只能生存到下一次回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中WeakReference类表示软引用。</li>
<li>虚引用：这个引用存在的唯一目的，就是在这个对象被收集器回收时得到一个系统通知，被虚引用关联的对象，和其生存时间完全没有关系。Java中PhantomReference类表示软引用。</li>
</ul>
<h4 id="弱引用的缺点"><a href="#弱引用的缺点" class="headerlink" title="弱引用的缺点"></a>弱引用的缺点</h4><p>首先, 弱引用(weak reference) 是可以被GC强制回收的。当垃圾收集器发现一个弱可达对象(weakly reachable,即指向该对象的引用只剩下弱引用) 时, 就会将其置入相应的ReferenceQueue 中, 变成可终结的对象. 之后可能会遍历这个 reference queue, 并执行相应的清理。典型的示例是清除缓存中不再引用的KEY。</p>
<p>当然, 在这个时候, 我们还可以将该对象赋值给新的强引用, 在最后终结和回收前, GC会再次确认该对象是否可以安全回收。因此, 弱引用对象的回收过程是横跨多个GC周期的。</p>
<p>实际上弱引用使用的很多。大部分缓存框架(caching solution)都是基于弱引用实现的, 所以虽然业务代码中没有直接使用弱引用, 但程序中依然会大量存在。</p>
<p>其次, 软引用(soft reference) 比弱引用更难被垃圾收集器回收. 回收软引用没有确切的时间点, 由JVM自己决定. 一般只会在即将耗尽可用内存时, 才会回收软引用,以作最后手段。这意味着, 可能会有更频繁的 full GC, 暂停时间也比预期更长, 因为老年代中的存活对象会很多。</p>
<p>最后, 使用虚引用(phantom reference)时, 必须手动进行内存管理, 以标识这些对象是否可以安全地回收。表面上看起来很正常, 但实际上并不是这样。 javadoc 中写道:</p>
<p>为了防止可回收对象的残留, 虚引用对象不应该被获取: phantom reference 的 get 方法返回值永远是 null。</p>
<p>令人惊讶的是, 很多开发者忽略了下一段内容(这才是重点):</p>
<p>与软引用和弱引用不同, 虚引用不会被 GC 自动清除, 因为他们被存放到队列中. 通过虚引用可达的对象会继续留在内存中, 直到调用此引用的 clear 方法, 或者引用自身变为不可达。</p>
<p>也就是说,我们必须手动调用 clear()) 来清除虚引用, 否则可能会造成 OutOfMemoryError 而导致 JVM 挂掉. 使用虚引用的理由是, 对于用编程手段来跟踪某个对象何时变为不可达对象, 这是唯一的常规手段。 和软引用/弱引用不同的是, 我们不能复活虚可达(phantom-reachable)对象。</p>
<p>建议使用JVM参数 -XX:+PrintReferenceGC 来看看各种引用对GC的影响。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>如果程序确实碰到了 mis-, ab- 问题或者滥用 weak, soft, phantom 引用, 一般都要修改程序的实现逻辑。每个系统不一样, 因此很难提供通用的指导建议, 但有一些常用的办法:</p>
<ul>
<li>弱引用(Weak references) —— 如果某个内存池的使用量增大, 造成了性能问题, 那么增加这个内存池的大小(可能也要增加堆内存的最大容量)。如, 增加堆内存的大小, 以及年轻代的大小, 可以减轻症状。</li>
<li>虚引用(Phantom references) —— 请确保在程序中调用了虚引用的 clear 方法。编程中很容易忽略某些虚引用, 或者清理的速度跟不上生产的速度, 又或者清除引用队列的线程挂了, 就会对GC 造成很大压力, 最终可能引起 OutOfMemoryError。</li>
<li>软引用(Soft references) —— 如果确定问题的根源是软引用, 唯一的解决办法是修改程序源码, 改变内部实现逻辑。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> jvm </category>
            
            <category> gc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
            <tag> gc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[总结下jvm gc的知识]]></title>
      <url>/2020/11/12/jvm-gc/</url>
      <content type="html"><![CDATA[<h2 id="jvm的内存模型"><a href="#jvm的内存模型" class="headerlink" title="jvm的内存模型"></a>jvm的内存模型</h2><p>jdk8之前</p>
<p><img src="https://s3.ax1x.com/2020/11/16/Dkodu6.png" alt="Dkodu6.png"></p>
<p>jdk8之后</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DABmHP.png" alt="DABmHP.png"></p>
<p>程序计数器，本地方法栈和虚拟机栈都是线程私有的，不需要回收。</p>
<p>堆是线程共享的，所有对象实例都应该在堆上分配内存。</p>
<p>方法区，用于存储已被虚拟机加载的类型信息、常量、静态变量等。在jdk8之前为永久带，8之后改为metaspace，（原因是永久带有最大限制，更容易出现oom），metaspace直接使用堆外内存（即本地内存）进行储存。</p>
<p>堆外内存，可以通过nio中的DirectByteBuffer.allocateDirect()直接申请内存空间。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象的分配会先检查类的加载，确定类加载后为对象从堆中分配出一块连续空间，然后再设置对象头信息，最后执行构造函数。</p>
<p>对象包含三部分：</p>
<p>对象头：包括两类信息。第一类是用于存储对象自身的运行时数据，如哈 希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。</p>
<p>实例数据：对象真正存储的有效信息。</p>
<p>对齐填充：不是必须的，对象为8字节的整数倍，所以需要占位符。</p>
<h2 id="回收原则"><a href="#回收原则" class="headerlink" title="回收原则"></a>回收原则</h2><h3 id="对象的回收"><a href="#对象的回收" class="headerlink" title="对象的回收"></a>对象的回收</h3><p>引用计数：给对象添加一个引用计数器，引用时+1，引用失效时-1。java并没有选择这种方法，因为无法判断循环引用。</p>
<p>可达性分析：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAp7jO.png" alt="DAp7jO.png"></p>
<p>固定可作为GC Roots的对象包括以下几种:</p>
<ul>
<li>在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。</li>
<li>在本地方法栈中JNI(即通常所说的Native方法)引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。</li>
<li>所有被同步锁(synchronized关键字)持有的对象。</li>
<li>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。</li>
</ul>
<p>要真正宣告一个对象死亡，至少要经历两次标记过程:</p>
<p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。finalize()方法是对象逃脱死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己————只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的 合;如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>方法区的垃圾收集主要回收两部分内容:废弃的常量和不再使用的类型。</p>
<p>常量不再被引用跟对象的判定相似。</p>
<p>类的回收判定比较苛刻：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h3 id="堆外内存的回收"><a href="#堆外内存的回收" class="headerlink" title="堆外内存的回收"></a>堆外内存的回收</h3><p>JDK中使用DirectByteBuffer对象来表示堆外内存，每个DirectByteBuffer对象在初始化时，都会创建一个对应的Cleaner对象，用于保存堆外内存的元信息（开始地址、大小和容量等），当DirectByteBuffer被GC回收后，Cleaner对象被放入ReferenceQueue中，然后由ReferenceHandler守护线程调用unsafe.freeMemory(address)，回收堆外内存。 在Cleaner 内部中通过一个列表，维护了一个针对每一个 directBuffer 的一个回收堆外内存的 线程对象(Runnable)，回收操作是发生在 Cleaner 的 clean() 方法中。</p>
<p>Direct Memory是受GC控制的，例如ByteBuffer bb = ByteBuffer.allocateDirect(1024)，这段代码的执行会在堆外占用1k的内存，Java堆内只会占用一个对象的指针引用的大小，堆外的这1k的空间只有当bb对象被回收时，才会被回收，这里会发现一个明显的不对称现象，就是堆外可能占用了很多，而堆内没占用多少，导致还没触发GC，那就很容易出现Direct Memory造成物理内存耗光。</p>
<p>Direct ByteBuffer分配出去的内存其实也是由GC负责回收的，而不像Unsafe是完全自行管理的，Hotspot在GC时会扫描Direct ByteBuffer对象是否有引用，如没有则同时也会回收其占用的堆外内存。</p>
<p>主动回收（推荐）：对于Sun的JDK，只要从DirectByteBuffer里取出那个sun.misc.Cleaner，然后调用它的clean()就行；</p>
<p>基于 GC 回收：堆内的DirectByteBuffer对象被GC时，会调用cleaner回收其引用的堆外内存。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAD9rn.png" alt="DAD9rn.png"></p>
<p>堆外内存注意<br>java.nio.DirectByteBuffer对象在创建过程中会先通过Unsafe接口直接通过os::malloc来分配内存，然后将内存的起始地址和大小存到java.nio.DirectByteBuffer对象，这样就可以直接操作这些内存。这些内存只有在DirectByteBuffer回收掉之后才有机会被回收。</p>
<p>当我们基于GC回收时，YGC只会将新生代里的不可达的DirectByteBuffer对象及其堆外内存回收，如果有大量的DirectByteBuffer对象移到了old区，但是又一直没有做CMS GC或者FGC，而只进行YGC，物理内存会被慢慢耗光，触发OutOfMemoryError。</p>
<p>因此为了避免这种悲剧的发生，通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc来做一次full gc，以此来回收掉没有被使用的堆外内存。</p>
<p>堆外内存优缺点<br>优点：</p>
<ul>
<li>提升了IO效率（避免了数据从用户态向内核态的拷贝）。堆内内存由JVM管理，属于“用户态”；而堆外内存由OS管理，属于“内核态”。如果从堆内向磁盘写数据时，数据会被先复制到堆外内存，即内核缓冲区，然后再由OS写入磁盘，使用堆外内存避免了数据从用户内向内核态的拷贝。</li>
<li>对垃圾回收停顿的改善因为full gc意味着彻底回收，彻底回收时，垃圾收集器会对所有分配的堆内内存进行完整的扫描，这意味着一个重要的事实——这样一次垃圾收集对Java应用造成的影响，跟堆的大小是成正比的。过大的堆会影响Java应用的性能。如果使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。</li>
<li>可以在进程间共享，减少JVM间的对象复制，使得JVM的分割部署更容易实现</li>
<li>可以扩展至更大的内存空间。比如超过1TB甚至比主存还大的空间</li>
<li>它的持久化存储可以支持快速重启，同时还能够在测试环境中重现生产数据</li>
</ul>
<p>缺点：</p>
<ul>
<li>分配和回收堆外内存比分配和回收堆内存耗时；（解决方案：通过对象池避免频繁地创建和销毁堆外内存）</li>
<li>堆外内存的泄漏问题</li>
<li>堆外内存的数据结构问题：堆外内存最大的问题就是你的数据结构变得不那么直观，如果数据结构比较复杂，就要对它进行串行化（serialization），而串行化本身也会影响性能。另一个问题是由于你可以使用更大的内存，你可能开始担心虚拟内存（即硬盘）的速度对你的影响了。</li>
</ul>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="分带与跨带"><a href="#分带与跨带" class="headerlink" title="分带与跨带"></a>分带与跨带</h3><p>设计者一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域。顾名思义，在新生代中，对象是朝生夕灭的，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p>
<p>但是，对象不是孤立的，对象之间会存在跨代引用。如果老年代中引用了新生代的对象，在新生代中做可达性分析时就会带上老年代，反而降低效率。</p>
<p>所以有了 跨代引用假说(Intergenerational Reference Hypothesis):跨代引用相对于同代引用来说仅占极少数。</p>
<p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录 每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构(该结构被称 为“记忆集”，Remembered Set)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会 存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>
<p>一些常见的定义：<br>部分收集(Partial GC):指目标不是完整收集整个Java堆的垃圾收集，其中又分为:</p>
<ul>
<li>新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集。</li>
<li>老年代收集(Major GC/Old GC):指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。</li>
<li>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
<li>整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。</li>
</ul>
<p>Minor GC和Full GC的区别以及触发条件：</p>
<p>Minor GC:</p>
<p>对于复制算法来说，当年轻代Eden区域满的时候会触发一次Minor GC，将Eden和From Survivor的对象复制到另外一块To Survivor上。</p>
<p>注意：如果某个对象存活的时间超过一定Minor gc次数会直接进入老年代，不在分配到To Survivor上(默认15次，对应虚拟机参数 -XX:+MaxTenuringThreshold)。另外，如果单个 Survivor 区已经被占用了 50% (对应虚拟机参数: -XX:TargetSurvivorRatio)，那么较高复制次数的对象也会被晋升至老年代。</p>
<p>Full GC:</p>
<p>用于清理整个堆空间。它的触发条件主要有以下几种：</p>
<ul>
<li>显式调用System.gc方法(建议JVM触发)。</li>
<li>方法区空间不足(JDK8及之后不会有这种情况了)</li>
<li>老年代空间不足，引起Full GC。这种情况比较复杂，有以下几种：<ul>
<li>大对象直接进入老年代引起，由-XX:PretenureSizeThreshold参数定义</li>
<li>Minor GC时，经历过多次Minor GC仍存在的对象进入老年代。上面提过，由-XX:MaxTenuringThreashold参数定义</li>
<li>Minor GC时，动态对象年龄判定机制会将对象提前转移老年代。年龄从小到大进行累加，当加入某个年龄段后，累加和超过survivor区域 * -XX:TargetSurvivorRatio的时候，从这个年龄段往上的年龄的对象进入老年代</li>
<li>Minor GC时，Eden和From Space区向To Space区复制时，大于To Space区可用内存，会直接把对象转移到老年代</li>
</ul>
</li>
</ul>
<p>JVM的空间分配担保机制可能会触发Full GC：</p>
<p>空间担保分配是指在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p>
<p>如果大于，则此次Minor GC是安全的。如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的，失败后会重新发起一次Full gc；如果小于或者HandlePromotionFailure=false，则改为直接进行一次Full GC。</p>
<p>所有才会说一次Full GC很有可能是由一次Minor GC触发的。</p>
<h3 id="标记清楚算法"><a href="#标记清楚算法" class="headerlink" title="标记清楚算法"></a>标记清楚算法</h3><p>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回 收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。</p>
<p>它的主要缺点有两个:</p>
<p>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;</p>
<p>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找 到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAAXsx.png" alt="DAAXsx.png"></p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存 活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复 制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAE1ln.png" alt="DAE1ln.png"></p>
<p>Appel式回收: HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍 然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新 生代容量的90%(Eden的80%加上一个Survivor的10%)，只有一个Survivor空间，即10%的新生代是会 被“浪费”的。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域(实际上大多就是老年代)进行分配担保(Handle Promotion)。</p>
<p>新生代上对象朝生夕灭的特点决定了它更适用复制算法，而不用担心空间的损耗。</p>
<p>Survivor区的意义：</p>
<p>如果没有survivor,Eden每进行一次minor gc，存活的对象就会进入老年代，老年代很快被填满就会进入major gc。由于老年代空间一般很大，所以进行一次gc耗时要长的多！尤其是频繁进行full GC，对程序的响应和连接都会有影响！</p>
<p>Survivor存在就是减少被送到老年代的对象，进而减少Full gc的发生。默认设置是经历了16次minor gc还在新生代中存活的对象才会被送到老年代。</p>
<p>为什么要有两个Survivor：</p>
<p>主要是为了解决内存碎片化和效率问题。如果只有一个Survivor时，每触发一次minor gc都会有数据从Eden放到Survivor，一直这样循环下去。注意的是，Survivor区也会进行垃圾回收，这样就会出现内存碎片化问题。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>针对老年代对象的长时间存在的特征，“标记-整理”(Mark-Compact)算法诞生，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可 回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p>移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行。</p>
<p>HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAm2DI.png" alt="DAm2DI.png"></p>
<h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>根节点枚举，所有收集器在这一步骤时都是必须暂停用户线程的（stop the world）。当用户线程停顿下来之后，hotspot使用一组称为OopMap的数据结构来得到哪些地方存放着对象引用。</p>
<p>一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间。HotSpot只是在“特定的位置”记录了这些信息，这些位置被称为安全点(Safepoint)。</p>
<p>有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。</p>
<p>因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。具备“长时间执行”的特征的指令序列的复用，例如方法调用、循环跳转、异常跳转等才会产生安全点。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任 意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
<p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集(Remembered Set)的数据结构，用以避免把整个老年代加进GC Roots扫描范围。</p>
<p>在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针。</p>
<p>HotSpot使用“卡精度”:每个记录精确到一块内存区域，该区域内有对象含有跨代指针。也称为称为“卡表”(Card Table)。</p>
<p>字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”(Card Page)。</p>
<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个(或更多)对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏(Dirty)，没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAuY01.png" alt="DAuY01.png"></p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>卡表状态的维护：有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。</p>
<p>在HotSpot虚拟机里是通过写屏障(Write Barrier)技术维护卡表状态的。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切<br>面，在引用对象赋值时会产生一个环形(Around)通知，供程序执行额外的动作，也就是说赋值的 前后都在写屏障的覆盖范畴内。</p>
<p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新 卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销。</p>
<h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析， 这意味着必须全程冻结用户线程的运行。</p>
<p>我们引入三色标记(Tri-color Marking)作为工具来辅<br>助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色:</p>
<ul>
<li>白色:表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li>黑色:表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接(不经过灰色对象)指向某个白色对象。</li>
<li>灰色:表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li>
</ul>
<p>如果用户线程与收集器是并发工作，收集器在对象图上标记颜色，同时用户线程在修改引用关系————即修改对象图的结构，这样可能出现两种后果。一种是把原本消亡的对象错误标记为存活。另一种是把原本存活的对象错误标记为已消亡，后者十分严重，会产生对象消失。</p>
<p>对象消失，即原本应该是黑色的对象被误标为白色，其产生条件：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用;</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>有两种解决方法：</p>
<ul>
<li>增量更新，破坏的是第一个条件，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</li>
<li>原始快照，破坏的是第二个条件，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来 进行搜索。</li>
</ul>
<p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，CMS是基于增量更新 来做并发标记的，G1、Shenandoah则是用原始快照来实现。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://s3.ax1x.com/2020/11/16/DAQ36g.png" alt="DAQ36g.png"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>单线程工作的收集器，它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAQB1U.png" alt="DAQB1U.png"></p>
<p>优于其他收集器的地方，那就是简单而高效(与其他收集器的单线程相比)，对于内<br>存资源受限的环境，它是所有收集器里额外内存消耗(Memory Footprint)最小的;对于单核处理器或处理器核心数较少的环境来说，Serial收集器没有线程交互的开销。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，使用标记整理算法。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>吞吐量优先收集器。（吞吐量：每秒钟接待多少人；响应时间：每个人要等多长时间才能得到服务。）Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p>
<p>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的: 系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间 的确在下降，但吞吐量也降下来了。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数 、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。</p>
<p>除了Serial收集器外，目前只有它能与CMS收集器配合工作。自JDK 9开始，ParNew合并入CMS，成为它专门处理新生代的组成部分。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAlNKe.png" alt="DAlNKe.png"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现的。整个过程分为四个步骤：</p>
<ul>
<li>初始标记(CMS initial mark) ————“Stop The World”，标记GC Roots</li>
<li>并发标记(CMS concurrent mark) ————并发进行可达性分析</li>
<li>重新标记(CMS remark) ————“Stop The World”，增量更新</li>
<li>并发清除(CMS concurrent sweep)</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/16/DANS7F.png" alt="DANS7F.png"></p>
<p>缺点：</p>
<ul>
<li>CMS收集器对处理器资源非常敏感。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢，降低总吞吐量。</li>
<li>由于CMS收集器无法处理“浮动垃圾”(FloatingGarbage)。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</li>
<li>可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”(Concurrent Mode Failure)，这时候虚拟机将不得不启动后备预案:冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。</li>
<li>CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。</li>
</ul>
<h3 id="g1收集器"><a href="#g1收集器" class="headerlink" title="g1收集器"></a>g1收集器</h3><p>全堆收集器，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>
<p>基于Region的堆内存布局，连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区 域(不需要连续)的动态集合。收集器能够对扮演不同角色的Region采用不同的策略去处理。</p>
<p>每个Region的大小可以通过参数-XX:G1Heap RegionSize设定，取值范围为1M B~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代 的一部分来进行看待。</p>
<p>g1将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间(使用参数-XX:MaxGCPauseMillis指定，默认值是200毫秒)，优先处理回收价值收益最大的那些Region。</p>
<p>跨Region使用特殊的记忆集（双向卡表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。）通过写屏障来维护记忆集能处理跨代指针，得以实现Region的增量回收。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAajXt.png" alt="DAajXt.png"></p>
<p>G1收集器的运作过程大致可划分为以下四个步骤:</p>
<ul>
<li>初始标记(Initial Marking):仅仅只是标记一下GC Roots能直接关联到的对象（stop the world）</li>
<li>并发标记(Concurrent Marking):从GC Root开始对堆中对象进行可达性分析，通过原始快照来处理并发问题。</li>
<li>最终标记(Final Marking):对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的原始快照记录。（stop the world）</li>
<li>筛选回收(Live Data Counting and Evacuation):负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集（整理），然后把决定回收的那一部分Region的存活对象复制到空的Region中（复制），再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。（stop the world）</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/16/DAdYB6.png" alt="DAdYB6.png"></p>
<p>G1和CMS的比较:</p>
<ul>
<li>G1从整体上看是“标记-整理”算法，从局部（两个Region之间）上看是“标记-复制”算法，不会产生内存碎片，而CMS基于“标记-清除”算法会产生内存碎片。</li>
<li>G1在垃圾收集时产生的内存占用和程勋运行时的额外负载都比CMS高</li>
<li>G1支持动态指定停顿时间，而CMS无法指定</li>
<li>两者都利用了并发标记这个技术</li>
</ul>
<h3 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h3><p>ZGC收集器是一款基于Region内存布局的，(暂时) 不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。接下来，笔者将逐项来介绍ZGC的这些技术特点。</p>
<p>（有点复杂，不展开了，记住Region分为大中小，整个收集过程都全程可并发，短暂停顿也只与GC Roots大小相关而与堆内存大小无关，完全没有使用记忆集，它甚至连分代都没有，不需要维护记忆集的写屏障，而用读屏障）</p>
<h2 id="gc调优"><a href="#gc调优" class="headerlink" title="gc调优"></a>gc调优</h2><p>单开一篇文章说吧，这一篇太长了</p>
]]></content>
      
        <categories>
            
            <category> jvm </category>
            
            <category> gc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
            <tag> gc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[k8s中的jvm]]></title>
      <url>/2020/11/11/jvm-in-container/</url>
      <content type="html"><![CDATA[<p>最近遇到了Java应用在k8s中频繁重启的问题，记录一下。</p>
<p>起因是因为一个bug，使我们的一个请求会大量申请许多新空对象，但这些空对象并没有被即使的回收，直接导致了pod级别的oomkille，或者直接被驱逐，于是开始了调查。</p>
<p>在Java 8u131和Java 9之前，JVM不能识别容器设置的内存或cpu限制。所以按照jvm的管理，最大堆的大小会设置为虚拟机内存的四分之一。我们当前node使用的虚拟机是64g的，因此xmx就被设置为了16g，但是我们并没有在pod中做memory limits的限制，当前node上又跑了许多其他的应用，这导致k8s无法给pod申请足够的内存，jvm的堆大小冲破了pod的实际可分配内存，直接被oomkilled并重启。被干掉的pod会留下一个Evicted状态的尸体，但这个pod尸体里没有events可以看，这增加了debug的难度。</p>
<p>仅仅在pod层面增加memory limits并不能解决问题，我们的jvm无法感知到容器的内存变化，仍旧以虚拟机内存的四分之一来设置最大堆的大小。<br>我们确实可以通过简单设置xmx和pod的resource limits来解决，但是并不优雅，应用资源与容器资源强耦合，忘改一处即可能带来灾难。因此我们来探索下有没有其他方式。</p>
<p>Java 8u131首先实现了称为的实验功能UseCGroupMemoryLimitForHeap。这是第一次尝试，但存在缺陷，为应用添加UnlockExperimentalVMOptions和UseCGroupMemoryLimitForHeap参数后，jvm确实可以感知到容器内存，并控制应用的实际堆大小。但是这并没有充分利用我们为容器分配的内存，jvm提供-XX:MaxRAMFraction标志来帮助更好的计算堆大小。</p>
<p>MaxRAMFraction默认值是4（即除以4），但不幸的是，它是一个分数，而不是一个百分比，因此很难设置一个能有效利用可用内存的值，但是为什么我们不设置MaxRAMFraction为1，使其使用100％的可用内存呢？因为容器中可能正在运行其他进程，或者一些通过shell链接到容器的工具。</p>
<p>Java 10附带了对容器环境的更好支持。如果你在Linux容器中运行Java应用程序，JVM将使用该UseContainerSupport选项自动检测内存限制。然后，您可以控制以下选项，InitialRAMPercentage，MaxRAMPercentage和MinRAMPercentage。这时，我们使用的是百分比而不是分数，这将更加准确。而这几个参数已经向下移植到Java 8u191。</p>
<p>UseContainerSupport默认情况下是激活的。MaxRAMPercentage是25%，MinRAMPercentage是50%。这里min竟然比max大，不知道为啥。<br>我们可以设置-XX:MinRAMPercentage=50.0，-XX:MaxRAMPercentage=80.0来是我们的应用感知，并充分利用pod的resource limits。<br>需要注意的是，UseCGroupMemoryLimitForHeap虽然仍可以在最新版本的Java8中使用，但是已经被视为弃用的参数了。</p>
<p>此外，在docker容器中运行JVM时，使用HeapDumpOnOutOfMemoryError参数可能是一个更明智的选择，因为，如果内存不足，jvm会将堆内存转储写入磁盘。默认情况下，堆内存会转储到VM的工作目录中的一个名为java_pid.hprof的文件中。您可以使用-XX:HeapDumpPath=来指定备用文件名或目录。例如，-XX:HeapDumpPath=/disk2/dumps将在/disk2/dumps目录中生成堆转储文件。请确保Java进程对堆转储的目录具有写入的访问权限。<br>接着在说一下cpu，pod可以给cpu的limits的限制，来确保pod可以调度到几个cpu核心，而jvm会根据cpu的核心数来设置是否使用ParallelGC，以及几个ParallelGCThreads。</p>
<p>但是如果我们不为pod设置cpu限制的话，jvm也并不能感知到虚拟机所有的可用cpu，而是认为只有一核，并关闭ParallelGC功能。因此在我们需要ParallelGC功能时，我们最好还设置cpu的限制。</p>
<p>而且通过查阅一些资料，发现cpu核数对jvm的工作线程也有着影响。<code>Runtime.getRuntime().availableProcessors()</code>，这段的代码常用于Java库，它会根据CPU的个数产生工作线程。如果没有正确设置docker中的参数，对实际的程序性能会产生很大的影响。availableProcessors就是根据核数而定的。</p>
<p>题外话：<br>一个完整的jdk对gc和jvm问题的排查十分重要。jinfo，jstat都是十分有用的工具，并且学会看gclog也十分重要。</p>
<p>一个小细节，我一直认为java -XX:+PrintFlagsFinal打印出的内容就是实际应用所在jvm进程的环境变量，但事实上，java -XX:+PrintFlagsFinal会单独建立一个进程，你打印出的东西都是这个命令所在进程的变量，而不是应用所在进程的变量。正确排查应用所在的jvm的进程的jvm变量还得用jinfo。</p>
<p>此外，我们安装了阿里的Arthas来进行jvm故障的排查，很有用。但考虑到有的时候我们也想在生产环境安装Arthas，但是不希望为生产环境的应用安装完整的jdk，怎么办？可以使用sidecar的方式来安装Arthas，然后通过shareProcessNamespace: true参数来在pod中share不同容器里的进程，这样sidecar里的Arthas就可以attach到你应用的pid了。详见：<a href="https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/。" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/。</a></p>
<p>先说到这，下回总结下gc的问题。</p>
]]></content>
      
        <categories>
            
            <category> k8s </category>
            
            <category> jvm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
            <tag> k8s </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务下的权限设计]]></title>
      <url>/2020/07/24/micro-service-authorization/</url>
      <content type="html"><![CDATA[<p><code>本文优先发表于CIO Talk微信公众号（微信号: CIO_China_Lab）</code></p>
<p>随着微服务架构的流行，越来越多的应用基于微服务架构设计和实现，同时带来了新的问题，传统单体应用架构下，认证和授权容易完成，但是微服务架构下，如何能更好的完成认证和授权，尤其在传统应用的微服务化转型过程中，如何更好的迁移，在不重新实现原有的权限管理系统的情况下，能够更优雅的实现复杂微服务架构下的认证和授权，本文将对上述问题做一些探讨。 </p>
<h1 id="微服务场景会为认证和授权带来哪些问题"><a href="#微服务场景会为认证和授权带来哪些问题" class="headerlink" title="微服务场景会为认证和授权带来哪些问题"></a>微服务场景会为认证和授权带来哪些问题</h1><p>在传统的单体架构应用中，当用户登录时，应用程序的安全模块验证用户的身份。在验证用户是合法的之后，为用户创建会话（session），并且将会话ID（session ID）与之相关联。服务器端会话存储登录用户信息，例如用户名，角色和权限。服务器将会话ID返回给客户端（浏览器）。客户端（浏览器）将会话ID记录为cookie，并在后续请求中将其发送到应用程序。然后，应用程序可以使用会话ID来验证用户的身份，而无需每次都输入用户名和密码进行身份验证。当客户端（浏览器）访问应用程序时，会话ID与HTTP请求一起发送到应用程序。程序的安全模块通常会使用授权拦截器，此拦截器首先确定会话ID是否存在。如果会话ID存在，则它知道用户已登录。然后，通过查询用户权限，确定用户是否可以执行请求。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQBGD.png" alt="UjQBGD.png"></p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQDRe.png" alt="UjQDRe.png"></p>
<p>在微服务架构下，应用由多个微服务组成，每个微服务在原始的单体应用程序中实现单一业务逻辑，并且前后端的分离使得客户端变成一个纯前端应用。在这种场景下，对每个微服务（包括纯前端的客户端应用）的访问请求进行身份验证和授权会面临以下问题： </p>
<ul>
<li>客户端拆分成独立的纯前端应用程序（单页应用），前端应用需要以一种安全的方式在浏览器中获取用户的身份信息和权限信息，并与服务端微服务程序共享。如果涉及到微前端的架构，前端由多个可独立部署的子应用组成，如何在多个微前端之间共享相同的登录信息、权限及其有效性？ </li>
<li>每个微服务需要处理相同的用户认证和授权信息，但是每个微服务又有独立的权限控制逻辑，相同用户在不同的微服务中，权限并不相同。微服务应遵循单一责任原则。微服务只处理单个业务逻辑。身份验证和授权的全局逻辑不应放在单个微服务实现中。 </li>
<li>HTTP是无状态协议。无状态意味着服务器可以根据需要将客户端请求发送到集群中的任何节点，HTTP的无状态设计对负载平衡有明显的好处。由于没有状态，用户请求可以分发到任何服务器。对于需要身份验证的服务，需要以基于HTTP协议的方式保存用户的登录状态。此时传统使用服务器端的会话来保存用户状态的方式就不适用了。 </li>
<li>微服务架构中的身份验证和授权涉及更复杂的场景，包括用户访问微服务应用程序，第三方应用程序访问微服务应用程序以及多个微服务应用程序之间的相互调用，在每种情况下，身份验证和授权方案都需要确保每个请求的安全性。 </li>
<li>尽管单点登录的可以确保用户的登录状态，但如何在微服务内部保持单点登录也会在无状态的微服务框架下带来挑战，微服务系统需要通过某种方式将用户的登录状态和权限在整个系统中共享。 </li>
</ul>
<p>下面我们来介绍一下认证和授权的区别，以及OAuth框架和OIDC协议的基本概念，以便更好的理解如何通过引入OAuth2.0框架和OIDC协议来解决上述问题。 </p>
<h1 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h1><p>首先，认证和授权是两个不同的概念，为了让我们的 API 更加安全和具有清晰的设计，理解认证和授权的不同就非常有必要了。 </p>
<ul>
<li><p>认证是 authentication，指的是当前用户的身份，解决 “我是谁？”的问题，当用户登陆过后系统便能追踪到他的身份并做出符合相应业务逻辑的操作。 </p>
</li>
<li><p>授权是 authorization，指的是什么样的身份被允许访问某些资源，解决“我能做什么？”的问题，在获取到用户身份后继续检查用户的权限。 </p>
</li>
<li><p>凭证（credentials）是实现认证和授权的基础，用来标记访问者的身份或权利，在现实生活中每个人都需要一张身份证才能访问自己的银行账户、结婚和办理养老保险等，这就是认证的凭证。在互联网世界中，服务器为每一个访问者颁发会话ID 存放到 cookie，这就是一种凭证技术。数字凭证还表现在方方面面，SSH 登录的密匙、JWT 令牌、一次性密码等。 </p>
</li>
</ul>
<p>单一的系统授权往往是伴随认证完成的，但是在开放 API 的多系统架构下，授权需要由不同的系统来完成，例如 OAuth2.0。 </p>
<p>在流行的技术和框架中，这些概念都无法孤立的被实现，因此在现实中使用这些技术时，大家往往对 OAuth2.0 是认证还是授权这种概念争论不休。下面我们会介绍在API开发中常常使用的几种认证和授权技术：OAuth2.0，OpenId Connect和JWT。 </p>
<h2 id="OAuth2-0、OpenId-Connect（OIDC）和JWT"><a href="#OAuth2-0、OpenId-Connect（OIDC）和JWT" class="headerlink" title="OAuth2.0、OpenId Connect（OIDC）和JWT"></a>OAuth2.0、OpenId Connect（OIDC）和JWT</h2><h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><h4 id="什么是OAuth2-0"><a href="#什么是OAuth2-0" class="headerlink" title="什么是OAuth2.0"></a>什么是OAuth2.0</h4><p>在第三方登录已经如此普遍的今天，相信大家一定都见过下面的这种界面： </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQcqI.png" alt="UjQcqI.png"></p>
<p>第三方登录让我们可以在一个app上无需注册新用户，就能使用我们的微信、qq等社交账号进行登录，app可以获取到我们社交账号上的头像、邮箱等信息。 </p>
<p>而这种现在看来已经非常普遍的操作，其背后就是OAuth2.0协议在支撑。 </p>
<p>在详细讲解OAuth2.0之前，需要了解几个专用名词。 </p>
<ul>
<li>Client：第三方应用程序，即客户端应用程序。 </li>
<li>HTTP service：HTTP服务提供商，即OAuth 服务提供商。 </li>
<li>Resource Owner：资源所有者，即终端用户。 </li>
<li>User Agent：用户代理，即浏览器。 </li>
<li>Authorization ：认证服务器，即服务提供商专门用来处理认证的服务器。 </li>
<li>Resource ：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。 </li>
<li>Token：包含用户身份或权限信息的令牌，通常为一串随机生成的字符，并具有时效性 </li>
</ul>
<p>OAuth2.0是一个关于授权的开放网络标准 <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">rfc6749</a>，允许用户授权第三方应用访问服务授权者提供的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。 </p>
<p>要理解OAuth2.0，让我们先从一个现实的场景开始： </p>
<p>如果要开发一个能检测代码质量的工具，面向的用户都是GitHub的使用者，那么如何才能让用户在不暴露GitHub的账号和密码的情况下，也能获得用户存储在GitHub的代码库的内容呢？ </p>
<p>简单来说，OAuth2.0就是让”Client”安全可控地获取”用户”的授权，与”Resource “进行互动。 </p>
<p>回到我们的场景中，我们要开发的代码检测工具就是Client，我们的用户就是Resource Owner，GitHub的登录系统就是Authorization ，GitHub的repo就是Resource 。在OAuth2.0框架下，用户在访问代码质量检查工具时，会先通过GitHub的Authorization 进行登录，GitHub的Authorization 会返回一个包含用户标识、且有时效性的token，通过这个token，代码质量检查工具可以访问GitHub的Resource 来获取用户代码库的内容。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQRdP.png" alt="UjQRdP.png"></p>
<h4 id="OAuth2-0的核心"><a href="#OAuth2-0的核心" class="headerlink" title="OAuth2.0的核心"></a>OAuth2.0的核心</h4><p>从我们的例子种不难发现，OAuth2.0的关键之处，在于Client如何和Authorization 进行交互，获取token。 </p>
<p>OAuth2.0协议为我们提供了以下endpoint： </p>
<ul>
<li>authorization endpoint：用于申请授权码的endpoint </li>
<li>token endpoint：用于申请token的endpoint </li>
<li>introspection endpoint：用于验证解析token的endpoint </li>
</ul>
<p>我们的client需要向OAuth2.0的提供商去申请一个client id和client secret，用于帮助OAuth2.0的提供商来验证client的合法性。（client id和client secret既可以在url param中验证，也可以携带于authorization basic token验证，这取决于你使用的Authorization 服务商） </p>
<p>OAuth2.0包含6种授权类型（Grant Type），用于client和Authorization 进行交互： </p>
<ul>
<li>授权码模式（Authorization  Grant Type) <ul>
<li>授权码模式是我们最常见的一种方式，传统的授权码模式通常使用在client为前后端一体的应用中。授权码模式与其他授权类型相比具有一些优势。当用户授权应用程序时，会带着URL中的授权码返回应用程序。应用程序用授权码来交换access token。当应用程序发出token请求时，该请求将使用client secret进行身份验证，从而降低攻击者拦截授权码并自行使用它的风险。这也意味着token永远不会被用户看到，因此这是将token传递回应用程序的最安全方式，从而降低token泄露给其他人的风险。（对于token endpoint的post请求参数有时也会以form-data的形式出现，这取决于你使用的Authorization 服务商） </li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQ5Rg.png" alt="UjQ5Rg.png"></p>
<ul>
<li>刷新模式（Refresh Token Grant Type） <ul>
<li>通常在请求到access token时，都会携带有一个refresh token，因为access token是有有效时长的，所以我们需要用一个不会过期的refresh token来刷新access token，在用户无需重新登录的情况下，让client也能保持使用正确有效的access token。 </li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQIzQ.png" alt="UjQIzQ.png"></p>
<ul>
<li>隐藏模式（Implict Grant Type） <ul>
<li>在前后端分离的架构中，client只有一个运行在浏览器上的前端的单页应用，不包含后端。因为JavaScript应用的特殊性，我们无法安全的将client secret存储在纯前端应用里，并且因为请求全部从浏览器发起，我们无法保证传统的授权码模式的两步请求中，是否会有中间人攻击。因此需要一种不通过client secret和两步请求就可以获取access token的方式，这就是隐藏模式。在此模式中，access token将作为redirect url的fragment返回到client，并且出于安全性考虑，将不会返回refresh token，因此我们不能用传统的refresh token模式来刷新access token，只能通过silent refresh的方式刷新。 </li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQTMj.png" alt="UjQTMj.png"></p>
<pre><code>* silent refresh 
* slient refresh是隐藏模式的一种特殊的刷新方式，其原理是运用html中iframe的特性，在access token过期之前，使用一个隐藏的iframe来重新用隐藏模式申请一次token，若authorization 的session不过期，便无需用户重新输入其登录信息就能获取一个新的access token。 
</code></pre><ul>
<li>PKCE模式（Proof Key for  Exchange by OAuth Public Clients） <ul>
<li>在隐藏模式介绍中我们可以发现，该模式是有明显的缺点的，即其silent refresh的刷新方式，authorization 所保存的用户登录session不可能永远不失效，一旦失效，我们还是需要用户重新登录才能确保client使用正确有效的token。为了解决这个缺点，PKCE模式应运而生。 PKCE模式通过改造传统的授权码模式，在请求authorization endpoint的同时，加入code_challenge和code_challenge_method参数，得到授权码后，在请求token endpoint时加入code_verifier参数，authorization 会验证code_challenge和code_verifier是否匹配，以此来防止两步请求中可能产生的中间人攻击。 </li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQHLn.png" alt="UjQHLn.png"></p>
<ul>
<li>密码模式（Password Grant Type） <ul>
<li>如果你高度信任某个应用，OAuth2.0也允许用户直接使用用户名和密码，该应用通过用户提供的密码，申请token，这种方式称为密码模式。密码模式无需浏览器作为代理，可以直接通过post请求获得token。 </li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQOoV.png" alt="UjQOoV.png"></p>
<ul>
<li>凭证模式（Client Credentials Grant Type） <ul>
<li>当你的应用只需要代表应用本身，而不是某个用户，来获取resource 的资源时，就可以使用凭证模式。这种模式不需要任何用户信息，返回的token也不携带任何用户信息。凭证模式也无需浏览器作为代理，可以直接通过post请求获得token。 </li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/24/UjQvJU.png" alt="UjQvJU.png"></p>
<p>而client在获取到access token之后，需要将access token携带于authorization bearer token header，再向resource 发出相应的资源请求。client也可以使用introspection endpoint来验证token是否有效。 </p>
<h3 id="OpenId-Connect（OIDC）"><a href="#OpenId-Connect（OIDC）" class="headerlink" title="OpenId Connect（OIDC）"></a>OpenId Connect（OIDC）</h3><p>尽管在今天很多OAuth2.0的使用中都包含身份信息，但OAuth2.0实际上是一个授权（authorization）的协议，并不包含认证（authentication）的内容。 </p>
<p>OAuth2.0框架明确不提供有关已授权应用程序的用户的任何信息。OAuth2.0是一个委派框架，允许第三方应用程序代表用户行事，而无需应用程序知道用户的身份。 </p>
<p>而OpenId的诞生就是为了解决认证问题的：OpenId基于OAuth2.0，在兼容OAuth2.0协议的基础上，它构建了一个身份层，用于验证并为client展示身份信息。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlpQJ.png" alt="UjlpQJ.png"></p>
<p>OpenID Connect的核心基于一个名为“ID token”的概念。authorization 将返回新的token类型，它对用户的身份验证信息进行编码。与仅旨在由资源服务器理解的access token相反，ID token旨在被第三方应用程序理解。当client发出OpenID Connect请求时，它可以请求ID token以及access token。 </p>
<p>OpenID Connect的ID token采用JSON Web Token（JWT）的形式，JWT是一个JSON有效负载，使用发行者的私钥进行签名，并且可以由应用程序进行解析和验证。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlCLR.png" alt="UjlCLR.png"></p>
<p>得益于JWT的自解析性，client可以不申请introspection endpoint就可以解析出ID token所包含的身份信息。JWT内部是一些定义的属性名称，它们为应用程序提供信息。它们用简写名称表示，以保持JWT的整体大小。这包括用户的唯一标识符（sub即“subject”的缩写），发出token的服务器的标识符（iss即“issuer”的缩写），请求此token的client的标识符（aud即“audience”的缩写），以及少数属性，例如token的生命周期，以及用户在多长时间之前获得主要身份验证提示。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlFdx.png" alt="UjlFdx.png"></p>
<h3 id="JWT（Json-Web-Token）"><a href="#JWT（Json-Web-Token）" class="headerlink" title="JWT（Json Web Token）"></a>JWT（Json Web Token）</h3><p>JWT（Json Web Token）是一个非常轻巧的规范。这个规范允许我们使用JWT在两个组织之间传递安全可靠的信息。 </p>
<p>首先，我们需要理解的是，JWT实际上是一个统称，它实际上是包含两部分JWS（Json Web Signature）和JWE（Json Web Encryption）。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlEFK.png" alt="UjlEFK.png"></p>
<h4 id="JWS（Json-Web-Signature）"><a href="#JWS（Json-Web-Signature）" class="headerlink" title="JWS（Json Web Signature）"></a>JWS（Json Web Signature）</h4><p>Json Web Signature是一个有着简单的统一表达形式的字符串： </p>
<p>JWS包含三部分： </p>
<ul>
<li><p>JOSE头（header）用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。JSON内容要经Base64编码生成字符串成为Header。 </p>
</li>
<li><p>JWS负载（payload）所必须的五个字段都是由JWT的标准所定义的。 </p>
<ul>
<li><p>iss(issuer): 该JWT的签发者（通常是authorization 的地址） </p>
</li>
<li><p>sub(subject): 该JWT所面向的用户（通常是用户名或用户ID） </p>
</li>
<li>aud(audience): 接收该JWT的一方（通常是client id） </li>
<li>exp(expires): 什么时候过期（Unix时间戳） </li>
<li>iat(issued at): 在什么时候签发的（Unix时间戳） </li>
</ul>
</li>
</ul>
<p>其他字段可以按需要补充。JSON内容要经Base64编码生成字符串成为PayLoad。 </p>
<ul>
<li>JWS签名（signature）使用密钥secret进行加密，生成签名。 </li>
</ul>
<p>JWS的主要目的是保证了数据在传输过程中不被修改，验证数据的完整性。但由于仅采用Base64对消息内容编码，因此不保证数据的不可泄露性。所以不适合用于传输敏感数据。并且加密数据只用于签名部分，所以JWS具有自解析性。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlmSe.png" alt="UjlmSe.png"></p>
<h4 id="JWE（Json-Web-Encryption）"><a href="#JWE（Json-Web-Encryption）" class="headerlink" title="JWE（Json Web Encryption）"></a>JWE（Json Web Encryption）</h4><p>Json Web Encryption是一个JWS的扩展，它是一串用加密算法加密过的token，在没有密钥的情况下，它能像JWS一样的解析。 </p>
<p>JWE包含五部分： </p>
<ul>
<li><p>JOSE头（header）：描述用于创建JWE加密密钥和JWE密文的加密操作，类似于JWS中的header。 </p>
</li>
<li><p>JWE加密密钥：用来加密文本内容所采用的算法。 </p>
</li>
<li><p>JWE初始化向量：加密明文时使用的初始化向量值，有些加密方式需要额外的或者随机的数据。这个参数是可选的。 </p>
</li>
<li><p>JWE密文：明文加密后产生的密文值。 </p>
</li>
<li><p>JWE认证标签：数字认证标签。 </p>
</li>
<li><p>JWE规范引入了两个新元素（enc和zip），它们包含在JWE令牌的JOSE头中，enc元素定义了秘文的加密算法，它应该是一个AEAD（Authenticated Encryption with Associated Data）模式的对称算法， zip元素定义了压缩算法，alg元素定义了用来加密cek（Content Encryption Key）的加密算法。 </p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/24/Ujluyd.png" alt="Ujluyd.png"></p>
<h1 id="微服务架构下的认证和授权的探讨"><a href="#微服务架构下的认证和授权的探讨" class="headerlink" title="微服务架构下的认证和授权的探讨"></a>微服务架构下的认证和授权的探讨</h1><p>通过对以上OAuth2.0，OIDC以及JWT/JWE的相关介绍，下面来探讨如何实现一个基于上述框架和协议的微服务认证和授权系统。 </p>
<p>在大型的系统架构中，往往存在多个产品共存的情况，网站因业务需求拆分成多个自成体系的微服务架构，但为了统一用户体验，这些独立的微服务架构往往共享一个身份认证服务。例如笔者所在的公司，拥有许多独立产品和服务，他们共享同一个认证服务器，支持OIDC协议，对用户身份认证，而每个产品和服务内部，在微服务架构下，则有着自己独立的授权逻辑。 </p>
<p>从传统单体架构到微服务架构的演变过程中，同一应用间的微服务调用，不同应用间的微服务调用，使得微服务组成了一个矩阵，相互之间存在交叉调用，每个独立的微服务又要对自己提供的服务实现权限控制，不止是系统权限，更多的是业务权限控制。如何能够基于原有的认证和权限管理系统，实现在同一微服务中，同时支持同应用之间的权限管理和不同应用之间的权限管理，是我们要探讨的主要问题。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlQeI.png" alt="UjlQeI.png"></p>
<h2 id="认证与授权的剥离"><a href="#认证与授权的剥离" class="headerlink" title="认证与授权的剥离"></a>认证与授权的剥离</h2><p>基于这样的架构基础，身份认证统一管理，应用和服务通过统一的身份认证服务完成用户登陆，剥离身份认证和用户授权，是构建微服务认证体系的第一步。 </p>
<p>现代应用中，前后端分离已是常态，独立的前端单页应用是用户进入站点的第一步，也扮演着client的角色，因此前端单页应用将会在微服务体系中扮演者获得身份信息的重要角色。由独立的前端应用（client）获取代表身份的token后，后端就无需再与身份验证服务做复杂的交互。 </p>
<p>我们可以使用前文所介绍的PKCE模式，安全的为前端应用授权。而后端只需要在网关层面拦截所有的请求验证身份即可，此时，前端应用就是身份验证服务（OIDC ）的client，后端网关将成为身份验证服务（OIDC ）的resource 。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/Ujl1TP.png" alt="Ujl1TP.png"></p>
<p>值得一提的是，在微前端概念高速发展的今天，我们同样需要在每个微前端项目中统一用户的身份和权限，借助浏览器localstorage对于不同域名的独立封闭性，我们可以使用类似cloudflare的工具帮助组装部署在不同服务器之上的前端应用共享同一域名，并以此来共享微前端不同系统之间的用户token。 </p>
<h2 id="服务端用户权限系统的建构"><a href="#服务端用户权限系统的建构" class="headerlink" title="服务端用户权限系统的建构"></a>服务端用户权限系统的建构</h2><p>在网关完成身份认证的工作后，整个认证（authentication）的流程就已完成，接下来我们要面临的则是如何在后端微服务之间统一用户权限。 </p>
<p>网关进行身份验证后，授权服务不需要让用户重新输入身份信息，因此应该由一个简单的api请求来完成。借助于OAuth2.0协议，我们可以使用密码流程（password grant type）来为用户进行授权。用户密码即为可自验证的ID token，而非用户的真正密码，我们借助密码流程的优势，构建一个支持解析用户ID token，并符合OAuth2.0协议标准的授权服务。 </p>
<p>前端应用在完成身份验证之后，会立即向服务端授权服务（OAuth ）发送获取权限的请求，授权服务（OAuth ）将权限压缩加密成一个JWE返回前端，以保证权限token的安全性，前端应用可以通过introspection endpoint来解析权限，而无需知道加密JWE的client secret。 </p>
<p>在得到JWE格式的权限token后，前端将携带着代表身份信息的ID token和代表权限的JWE token一同通过网关发往后端，后端网关在验证完ID token后会重新组装请求，只将权限token发往后端微服务进行单独验证。 </p>
<p>此时，后端网关是授权服务（OAuth ）的client，而后端其他的微服务将成为授权服务（OAuth ）的resource 。 </p>
<p>微服务在收到具体的业务请求后，会使用client secret解析JWE token，而无需再与授权服务进行交互。 </p>
<p>而之后的服务间调用，也将一直携带着此JWE token，以提供权限凭证。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlGY8.png" alt="UjlGY8.png"></p>
<h2 id="第三方系统间权限系统的建构"><a href="#第三方系统间权限系统的建构" class="headerlink" title="第三方系统间权限系统的建构"></a>第三方系统间权限系统的建构</h2><p>对于一个微服务系统来说，我们不仅仅要处理来自用户的请求，还经常会与其他系统进行交互，因此，我们的权限系统也需要提供一种在不提供用户身份访问系统的方式，这就是system-partner模式。 </p>
<p>得益于OAuth2.0协议中的凭证模式（client credentials grant type），我们可以要求对我们发起请求的第三方系统在身份认证服务（OIDC ）中去申请一个不包含用户信息的client credentials token，而后端网关会解析client credentials token，并从token解析出的grant_type=client_credentials字段来识别出system-partner的请求，并验证system-partner client id的白名单，之后去我们的授权服务（OAuth ）去申请一个system-partner的权限。 </p>
<p>通过OAuth token endpoint中携带的additional parameter，授权服务（OAuth ）会识别出system-partner的请求，赋予其一个system-partner的权限，并包装成JWE token，返回第三方系统。 </p>
<p>在第三方系统得到了client credentials token和JWE token后，可以以与之前相同的方式发往我们的微服务，微服务会在解析token时识别出其system partner的权限，执行相应的业务逻辑。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlNlQ.png" alt="UjlNlQ.png"></p>
<h2 id="基于OAuth2-0的授权中心实现"><a href="#基于OAuth2-0的授权中心实现" class="headerlink" title="基于OAuth2.0的授权中心实现"></a>基于OAuth2.0的授权中心实现</h2><p>在实现中，我们使用spring security作为技术基础，完全遵循OAuth2.0协议，将其进行改造，让spring security支持我们的自定义的token encode方式，并重新实现了user details provider来扩展权限系统。并且得益于JWE的使用，我们无需提供具体的storage来保存token，redis仅仅用于在token有效期内避免再次与权限服务交互，加速接口请求速度。 </p>
<p>一个好的微服务权限系统应该至少具有三层结构的权限体系： </p>
<ul>
<li>是否有权限访问此微服务 </li>
<li>是否有权限访问微服务中的某一个特定的endpoint </li>
<li>是否包含一些用户特定的权限数据 </li>
</ul>
<p>其中前两层只包含权限的名字和id，而第三层因为涉及到具体的权限数据，我们将其设计成为开放接口，由开发者自行封装响应的权限获取实现逻辑。这样做的好处是，我们可以在请求权限token时使用一些additional parameter来自主的切换我们想要的权限获取逻辑（例如system-partner的实现）。 </p>
<p>同时，additional parameter和开放权限接口相互配合，不同的微服务系统就可以使用同一个authorization 来提供不同的权限，这样可以更容易集中化管理用户权限，并节省开发资源。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlUyj.png" alt="UjlUyj.png"></p>
<p>秉承着避免与authorization 交互的原则，JWE token使用client secret作为密钥进行加密，因此resource 可以通过client secret对获得的JWE token进行自解析，并由全局的http intercepter来决定用户是否有权限访问服务或着服务的某个endpoint，以及endpoint背后与权限有关的业务逻辑。微服务可以自行用各种开源的JWE工具进行解析，也符合微服务跨语言的基本特性。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlrkV.png" alt="UjlrkV.png"></p>
<h2 id="一次性token"><a href="#一次性token" class="headerlink" title="一次性token"></a>一次性token</h2><p>对于一个庞大的微服务系统来说，可能不仅仅有浏览器、移动端，还包括类似于CLI（Command-Line Interface）的应用程序。因为此类应用程序的特殊性，他们无法正常的通过页面重定向的方式与认证服务和授权服务交流，因此，我们设计了一种一次性token的交互模式。 </p>
<p>用户会被要求用浏览器申请一个特殊的url，得到一个有限时长的一次性token，CLI应用可以使用这一个token来正常的从网关访问后端微服务。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlyfU.png" alt="UjlyfU.png"></p>
<p>其背后是一个独立的OAuth client在做支撑，这个OAuth client会以授权码模式先申请身份认证服务（OIDC ），得到ID token后再在后端直接申请授权服务（OAuth ）获取JWE token，并将两个token保存在redis中，并生成一个unique ID作为一次性token返回。同时用一个job来进行token过期前的刷新，以确保一次性token可以在其较长的有效时间内一直保持其有效性。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/UjlRX9.png" alt="UjlRX9.png"></p>
<p>而微服务网关在接收并识别出一次性token后，会直接请求这个特殊的OAuth client来获取其真正的ID token和JWE token，再进行验证并申请转发微服务。 </p>
<p><img src="https://s1.ax1x.com/2020/07/24/Ujlh01.png" alt="Ujlh01.png"></p>
<p>这种方式巧妙的避免了类似CLI应用在界面交互上的限制，并能以一个较长的时间使用一个token来作为用户凭证访问微服务，拓展了这个微服务系统的涵盖范围。 </p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本文详细描写了在微服务架构下，针对不同的应用场景，如何实现基于OIDC协议和OAUTH2.0框架的认证和授权，通过引入JWE token，将用户授权信息在微服务架构下以自解析的方式完成权限传递，使得单个微服务能够更加容易的将用户权限用于自身的业务逻辑中。基于标准协议和框架的设计，使得该系统可以很容易的集成到现有的认证和授权系统中，而不需要对原有认证和授权系统做大的修改，这样的设计也减少了复杂微服务系统对于授权系统的依赖，更加简洁和高效。 </p>
<p>参考资料： </p>
<p><a href="https://insights.thoughtworks.cn/api-2/" target="_blank" rel="noopener">https://insights.thoughtworks.cn/api-2/</a></p>
<p><a href="https://www.oauth.com/" target="_blank" rel="noopener">https://www.oauth.com/</a> </p>
<p> <a href="https://www.cnblogs.com/linianhui/p/openid-connect-core.html" target="_blank" rel="noopener">https://www.cnblogs.com/linianhui/p/openid-connect-core.html</a> </p>
<p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p>
<p><a href="https://www.jianshu.com/p/50ade6f2e4fd" target="_blank" rel="noopener">https://www.jianshu.com/p/50ade6f2e4fd</a></p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在spring中使用cors]]></title>
      <url>/2018/11/06/spring-cors/</url>
      <content type="html"><![CDATA[<p>网上有很多教程，基本上都是清一色的<code>@CrossOrigin</code>，<code>@CrossOrigin</code>在和spring security一起用的时候不生效，因为filter chain order的原因。</p>
<p>解决方案：</p>
<pre><code class="java">import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;


@Configuration
public class WebCorsConfig {

    @Bean
    public FilterRegistrationBean customCorsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin(&quot;*&quot;);
        config.addAllowedHeader(&quot;*&quot;);
        config.addAllowedMethod(&quot;*&quot;);
        source.registerCorsConfiguration(&quot;/**&quot;, config);
        FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source));
        bean.setOrder(Ordered.HIGHEST_PRECEDENCE);
        return bean;
    }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用oidc id token验证spring security resource server]]></title>
      <url>/2018/11/06/spring-security-jwt/</url>
      <content type="html"><![CDATA[<p>在前后端分离的项目中，前端因为不能保证密钥的安全，通常会使用oidc implicit grant type来获取access token和id token，后端会验证token的合法性并获得用户信息。</p>
<p>后端使用spring，如果后端是验证access token，那好说，使用spring-security-oauth2-autoconfigure，详见<a href="https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/" target="_blank" rel="noopener">文档</a>。</p>
<p>如果后端是验证id token，并且提供jwks url，那也好说，详见<a href="https://spring.io/blog/2018/08/21/spring-security-5-1-0-rc1-released#oauth2-resource-server" target="_blank" rel="noopener">文档</a>。</p>
<p>可惜的是IBM ID OAuth server暂时还没有提供jwks url，只给了一个rsa public key的证书，因此记录一下解决方案。</p>
<p><strong>版本：spring boot 2.1.0.RELEASE</strong></p>
<pre><code class="gradle">dependencies{
    compile(&#39;org.springframework.boot:spring-boot-starter-security&#39;)
    compile(&#39;org.springframework.security:spring-security-oauth2-jose:5.1.1.RELEASE&#39;)
    compile(&#39;org.springframework.security:spring-security-oauth2-client:5.1.1.RELEASE&#39;)
    compile(&#39;org.springframework.security:spring-security-oauth2-resource-server:5.1.1.RELEASE&#39;)
    compile(&#39;org.bouncycastle:bcprov-jdk15on:1.60&#39;)
}
</code></pre>
<pre><code class="java">import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileReader;
import java.io.InputStream;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPublicKey;


@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Value(&quot;${JWK-certificate}&quot;)
    String jwkCertificate;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .oauth2ResourceServer()
                .jwt();
    }

    @Bean
    JwtDecoder getJwtDecoder() throws Exception {
        NimbusReactiveJwtDecoder nimbusReactiveJwtDecoder = new NimbusReactiveJwtDecoder(WebSecurityConfig.get(jwkCertificate));
        return token -&gt; nimbusReactiveJwtDecoder.decode(token).block();
    }

    public static RSAPublicKey get(String filePath) throws Exception {
        PemReader pemReader = new PemReader(new FileReader(new File(WebSecurityConfig.class.getResource(filePath).getPath())));
        PemObject pemObject = pemReader.readPemObject();
        pemReader.close();
        CertificateFactory fact = CertificateFactory.getInstance(&quot;X.509&quot;);
        InputStream input = new ByteArrayInputStream(pemObject.getContent());
        X509Certificate cert = (X509Certificate) fact.generateCertificate(input);
        return (RSAPublicKey)cert.getPublicKey();
    }

}
</code></pre>
<p><strong>版本：spring boot 2.0.6.RELEASE</strong></p>
<pre><code class="gradle">dependencies{
    compile(&#39;org.springframework.security:spring-security-oauth2-core:5.1.1.RELEASE&#39;)
    compile(&#39;org.springframework.security:spring-security-oauth2-jose:5.1.1.RELEASE&#39;)
    compile(&#39;org.springframework.security:spring-security-oauth2-client:5.1.1.RELEASE&#39;)
    compile(&#39;org.springframework.security:spring-security-oauth2-resource-server:5.1.1.RELEASE&#39;)
    compile(&#39;org.springframework.security:spring-security-core:5.1.1.RELEASE&#39;)
    compile(&#39;org.springframework.security:spring-security-config:5.1.1.RELEASE&#39;)
    compile(&#39;org.springframework.security:spring-security-web:5.1.1.RELEASE&#39;)
    compile(&#39;org.springframework.security:spring-security-crypto&#39;:5.1.1.RELEASE)
    compile(&#39;org.bouncycastle:bcprov-jdk15on:1.60&#39;)
}
</code></pre>
<pre><code class="java">import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.configurers.oauth2.server.resource.OAuth2ResourceServerConfigurer;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileReader;
import java.io.InputStream;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPublicKey;



@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Value(&quot;${JWK-certificate}&quot;)
    String jwkCertificate;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        OAuth2ResourceServerConfigurer&lt;HttpSecurity&gt; oauth2ResourceServerConfigurer = new OAuth2ResourceServerConfigurer&lt;&gt;(http.getSharedObject(ApplicationContext.class));
        oauth2ResourceServerConfigurer.jwt();
        http
                .authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .apply(oauth2ResourceServerConfigurer);
    }

    @Bean
    JwtDecoder getJwtDecoder() throws Exception {
        NimbusReactiveJwtDecoder nimbusReactiveJwtDecoder = new NimbusReactiveJwtDecoder(WebSecurityConfig.get(jwkCertificate));
        return token -&gt; nimbusReactiveJwtDecoder.decode(token).block();
    }

    public static RSAPublicKey get(String filePath) throws Exception {
        PemReader pemReader = new PemReader(new FileReader(new File(WebSecurityConfig.class.getResource(filePath).getPath())));
        PemObject pemObject = pemReader.readPemObject();
        pemReader.close();
        CertificateFactory fact = CertificateFactory.getInstance(&quot;X.509&quot;);
        InputStream input = new ByteArrayInputStream(pemObject.getContent());
        X509Certificate cert = (X509Certificate) fact.generateCertificate(input);
        return (RSAPublicKey)cert.getPublicKey();
    }

}
</code></pre>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
            <category> OIDC </category>
            
            <category> spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
            <tag> spring </tag>
            
            <tag> OIDC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[倒鸭子]]></title>
      <url>/2018/09/30/daoyazi/</url>
      <content type="html"><![CDATA[<h1 id="倒鸭子台词"><a href="#倒鸭子台词" class="headerlink" title="倒鸭子台词"></a>倒鸭子台词</h1><ul>
<li>你好，请问有什么可以帮到您？</li>
<li><strong>喂，您好</strong></li>
<li>您好</li>
<li><strong>你这边有杂音，我听不清楚，那个，我的车，刚才，我这才买的车，刚才，那个，在那个，马路边，低大梁擦道牙子擦了个坑</strong></li>
<li>先生您好，您的车辆出保险了，现在要报案是么？</li>
<li><strong>对对对</strong></li>
<li>唉，先生你好，是什么时候出的事情？</li>
<li><strong>刚刚时间，刚刚出的</strong></li>
<li>大概有几分钟了</li>
<li><strong>嗯，就刚刚的事</strong></li>
<li>半个小时是么？</li>
<li><strong>五，十分钟</strong></li>
<li>十分钟？</li>
<li><strong>对</strong></li>
<li>是在哪里出的事情？是在大连吗？</li>
<li><strong>在革镇堡</strong></li>
<li>是在辽宁，辽宁省的大连市，是吗？</li>
<li><strong>对，甘井子，革镇堡</strong></li>
<li>是在大连市的那条路？</li>
<li><strong>甘井子，革镇堡！</strong></li>
<li>干警市</li>
<li><strong>甘井子区，革镇堡镇</strong></li>
<li>先生您好，是在大连市的干警，干警两个字是怎么写的？</li>
<li><strong>甘井子区，甘井子开发区，呃，甘井子区</strong></li>
<li>干警市区是么？</li>
<li><strong>对</strong></li>
<li>干警市区，那个干是两横一竖那个干吗？警是警察的警吗？</li>
<li><strong>对对对</strong></li>
<li>干警市区哪里？</li>
<li><strong>甘井子区，就是大连市甘井子区革镇堡镇</strong></li>
<li>革陈铺，是吗？</li>
<li><strong>革镇堡</strong></li>
<li>啊，好啦，先生我知道了，您在那边发生什么事情了</li>
<li><strong>刚刚，开车，不小心，刮在底下道，刮在道牙子上了，倒车刮道牙子上了，那个，低保险，低杠，低大梁，大，大梁，大架子，底下大架子，刮那个保险杠刮了个坑</strong></li>
<li>先生您好，是您的车在直行的时候，还是倒车的时候？</li>
<li><strong>倒车</strong></li>
<li>倒车的时候是吧？</li>
<li><strong>对</strong></li>
<li>倒车的时候刮到哪个部位了？</li>
<li><strong>就是车，左侧地盘，低杆那个大梁，大架子</strong></li>
<li>左侧，就是您的车的左侧地盘受损了，是吗？</li>
<li><strong>对对对，底下，大架子，侧面大架子</strong></li>
<li>还有没有其他地方受损么？</li>
<li><strong>嗯，别的地方没有。</strong></li>
<li>其他地方没有啦，是您的车擦到哪里了？擦到墙了还是擦到哪里了？</li>
<li><strong>擦到就是道边的那个道牙子</strong></li>
<li>倒鸭子？</li>
<li><strong>对呀</strong></li>
<li>是一个什么物体呢？</li>
<li><strong>道牙子，什么物体，哎呀妈呀，就是道边的，公路道边不是有道牙子吗？</strong></li>
<li>是，是那个是墙还是铁杆还是怎么的？</li>
<li><strong>石头</strong></li>
<li>是土是吗？</li>
<li><strong>石块，就是道边铺道牙子的那个石块，那个，每个公路道边不都有那个道边那个道牙子么？</strong></li>
<li>倒鸭子？</li>
<li><strong>就是道边道牙子的那个石块，你叫那个，过来，出险的过来看一下就知道了</strong></li>
<li>那我想请问一下，对方的那个道牙子有没有什么事情呀？</li>
<li><strong>那些都不要紧，那都是大道，那个道边，那都不要紧，就是我车出事了</strong></li>
<li>就是您的车受损了，对方不要求您赔的，是吗？</li>
<li><strong>没有对方，就是车受损了</strong></li>
<li>呃，就是您的车受损了，然后对方的那个不需要您赔是吗？</li>
<li><strong>啊，那些都没有没有，就是我车有点，有毛病，你让过来看一下，要不，我这才买的新车</strong></li>
<li>唉，先生您好，我再跟您核对一下当时的信息，是您的车在倒车的时候刮到了倒鸭子，造成您本车的左侧底盘受损，对方没事是吧？</li>
<li><strong>对对对对，呵呵</strong></li>
<li>啊好叻，那那个麻烦您先在现场暂时不要移动好吗？</li>
<li><strong>啊，行</strong></li>
<li>啊好，感谢您的配合，再见</li>
<li><strong>哎呀妈呀，这女的</strong></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 台词 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 台词 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程]]></title>
      <url>/2018/07/14/oauth-guide/</url>
      <content type="html"><![CDATA[<p>翻译了oauth.com上的教程，地址：<code>http://seanthefish.com/oauth-guide/#/</code></p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--附录]]></title>
      <url>/2018/07/14/oauth-guide-26/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul>
<li><a href="http://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">OAuth 2.0 RFC 6749</a></li>
<li><a href="http://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">承载令牌使用RFC 6750</a></li>
<li><a href="http://tools.ietf.org/html/rfc6819" target="_blank" rel="noopener">OAuth 2.0威胁模型和安全注意事项RFC 6819</a></li>
<li><a href="https://tools.ietf.org/html/draft-ietf-oauth-device-flow" target="_blank" rel="noopener">OAuth 2.0设备流程</a></li>
<li><a href="https://tools.ietf.org/html/draft-ietf-oauth-native-apps" target="_blank" rel="noopener">适用于原生应用的OAuth 2.0</a></li>
<li><a href="https://tools.ietf.org/html/rfc7636" target="_blank" rel="noopener">代码交换RFC 7636的证明密钥</a></li>
<li><a href="http://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">JSON Web Token RFC 7519</a></li>
<li><a href="https://openid.net/connect/" target="_blank" rel="noopener">OpenID Connect</a></li>
<li><a href="https://www.w3.org/TR/indieauth/" target="_blank" rel="noopener">IndieAuth</a></li>
<li><a href="https://tools.ietf.org/wg/oauth/" target="_blank" rel="noopener">所有OAuth工作组规范</a></li>
</ul>
<h3 id="供应商文档"><a href="#供应商文档" class="headerlink" title="供应商文档"></a>供应商文档</h3><ul>
<li><a href="https://developers.google.com/identity/protocols/OAuth2" target="_blank" rel="noopener">Google OAuth 2.0</a></li>
<li><a href="https://developers.facebook.com/" target="_blank" rel="noopener">Facebook开发者</a></li>
<li><a href="https://developer.github.com/apps/" target="_blank" rel="noopener">GitHub文档</a></li>
<li><a href="https://developer.foursquare.com/overview/auth" target="_blank" rel="noopener">Foursquare文档</a></li>
</ul>
<h3 id="社区资源"><a href="#社区资源" class="headerlink" title="社区资源"></a>社区资源</h3><ul>
<li><a href="https://aaronparecki.com/oauth/" target="_blank" rel="noopener">由Aaron Parecki提供的OAuth资源</a></li>
<li><a href="https://alexbilbie.com/tag/oauth/" target="_blank" rel="noopener">Alex Bilbie撰写的OAuth文章</a></li>
<li><a href="https://hueniverse.com/tagged/oauth" target="_blank" rel="noopener">Eran Hammer撰写的OAuth文章</a></li>
<li><a href="https://oauth.net/articles/authentication/" target="_blank" rel="noopener">使用OAuth 2.0进行用户身份验证</a></li>
<li><a href="https://www.ietf.org/mailman/listinfo/oauth" target="_blank" rel="noopener">OAuth IETF邮件列表</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--工具和帮助文档]]></title>
      <url>/2018/07/14/oauth-guide-25/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<h3 id="OAuth-2-0游乐场"><a href="#OAuth-2-0游乐场" class="headerlink" title="OAuth 2.0游乐场"></a>OAuth 2.0游乐场</h3><p><code>https://www.oauth.com/playground/</code></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ftoj9ztdrzj30sg0kw41k.jpg" alt="play"></p>
<p>OAuth 2.0 Playground通过与真正的OAuth 2.0授权服务器交互，引导您完成各种OAuth流程。</p>
<p>它包含授权码流，PKCE，设备流以及OpenID Connect的简单示例。</p>
<h3 id="Google-OAuth-2-0-Playground"><a href="#Google-OAuth-2-0-Playground" class="headerlink" title="Google OAuth 2.0 Playground"></a>Google OAuth 2.0 Playground</h3><p><code>https://developers.google.com/oauthplayground/</code></p>
<p>Google的OAuth 2.0 Playground允许您手动逐步完成从此测试应用程序访问您自己的Google帐户的授权过程。</p>
<p>您可以从可用范围列表中进行选择，点击“授权”以转到标准Google授权页面，重定向会将您返回到OAuth 2.0 Playground。在那里，您可以查看交换访问令牌的授权代码的请求，然后使用访问令牌进行测试以发出API请求。</p>
<p>该工具还允许您通过自定义授权和令牌endpoint来对其他OAuth 2.0服务器进行授权。</p>
<h3 id="OpenID-Connect-Debugger"><a href="#OpenID-Connect-Debugger" class="headerlink" title="OpenID Connect Debugger"></a>OpenID Connect Debugger</h3><p><code>https://oidcdebugger.com</code></p>
<p>OpenID Connect Debugger允许您测试OpenID Connect请求并调试来自服务器的响应。您可以将该工具配置为与任何OpenID服务器（如Google）配合使用。</p>
<h3 id="服务器和客户端库目录"><a href="#服务器和客户端库目录" class="headerlink" title="服务器和客户端库目录"></a>服务器和客户端库目录</h3><p><code>https://oauth.net/code/</code></p>
<p>oauth.net网站包含支持OAuth 2.0的服务器，客户端和服务的目录。您可以找到从完整的OAuth 2.0服务器实现到促进流程的每个步骤的库的任何内容，以及客户端库和代理服务。</p>
<p>如果您要提供任何库或服务，也可以将它们添加到目录中。</p>
<h3 id="jsonwebtoken-io"><a href="#jsonwebtoken-io" class="headerlink" title="jsonwebtoken.io"></a>jsonwebtoken.io</h3><p><code>https://jsonwebtoken.io</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftojc727cbj30sg0ovahn.jpg" alt="jwt"></p>
<p>jsonwebtoken.io是一个用于调试JSON Web令牌的工具。它允许您粘贴JWT，它将对其进行解码并显示各个组件。如果您向其提供用于签署JWT的秘钥，它还可以验证签名。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--OAuth 2.0规范]]></title>
      <url>/2018/07/14/oauth-guide-24/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>OAuth 2.0核心框架（RFC 6749）定义了角色和基本功能级别，但未指定大量实现细节。自RFC发布以来，OAuth工作组已经发布了许多基于此框架构建的其他规范，以填补缺失的部分。查看该小组正在进行的完整规范列表可能有点困难。本章列出了各种规范如何相互关联。</p>
<h3 id="核心规格"><a href="#核心规格" class="headerlink" title="核心规格"></a>核心规格</h3><h4 id="OAuth-2-0核心（RFC-6749）"><a href="#OAuth-2-0核心（RFC-6749）" class="headerlink" title="OAuth 2.0核心（RFC 6749）"></a>OAuth 2.0核心（RFC 6749）</h4><p><code>https://tools.ietf.org/html/rfc6749</code></p>
<p>RFC 6749是核心OAuth 2.0框架。这描述了角色（资源所有者，客户端，授权服务器等，在术语参考中有更详细的描述，几个授权流程和几个错误定义。重要的是要记住这是一个“框架”，因为有很多方面未指明您在构建完整实施时需要填写。其中大部分细节已记录为扩展规范。</p>
<h4 id="承载令牌使用（RFC-6750）"><a href="#承载令牌使用（RFC-6750）" class="headerlink" title="承载令牌使用（RFC 6750）"></a>承载令牌使用（RFC 6750）</h4><p><code>https://tools.ietf.org/html/rfc6750</code></p>
<p>核心规范没有定义访问令牌的格式或如何使用它们。在开发核心规范的早期，访问令牌是争论的主要问题，结果是访问令牌完全取自核心规范，而不是让人们在不受欢迎的令牌上妥协。但是，从那时起，大多数实现已经标准化使用承载令牌。RFC 6750描述了使用承载令牌访问API的语法和方法。</p>
<h4 id="威胁模型和安全注意事项（RFC-6819）"><a href="#威胁模型和安全注意事项（RFC-6819）" class="headerlink" title="威胁模型和安全注意事项（RFC 6819）"></a>威胁模型和安全注意事项（RFC 6819）</h4><p><code>https://tools.ietf.org/html/rfc6819</code></p>
<p>编写威胁模型和安全注意事项文档是为了提供超出核心文档所述内容的其他指导。在主要提供商具有真正的实施经验之后，添加了大部分文档。该文件描述了许多已知的攻击，无论是理论攻击还是已经被证明的攻击。它描述了每种方法的对策。</p>
<p>实施OAuth 2.0服务器的每个人都应该阅读本文档，以避免陷入已经探索和解决过的陷阱。</p>
<h3 id="令牌"><a href="#令牌" class="headerlink" title="令牌"></a>令牌</h3><h4 id="令牌自解析（RFC-7662）"><a href="#令牌自解析（RFC-7662）" class="headerlink" title="令牌自解析（RFC 7662）"></a>令牌自解析（RFC 7662）</h4><p><code>https://tools.ietf.org/html/rfc7662</code></p>
<p>令牌自解析规范定义了资源服务器获取有关访问令牌的信息的机制。如果没有此规范，资源服务器必须有一种定制方式来检查访问令牌是否有效，并找出有关它们的用户数据等。这通常发生在自定义API endpoint上，或者因为资源服务器和授权服务器共享一个数据库或其他一些常见的存储。</p>
<p>使用此规范，资源服务器可以检查访问令牌的有效性，并通过HTTP API调用查找其他信息，从而更好地分离授权服务器与任何资源服务器之间的关注点。</p>
<h4 id="令牌绑定"><a href="#令牌绑定" class="headerlink" title="令牌绑定"></a>令牌绑定</h4><p><code>https://tools.ietf.org/html/draft-ietf-oauth-token-binding</code></p>
<p>令牌绑定扩展描述了一种将令牌加密绑定到客户端的技术，以保护令牌免受中间人和重放攻击。标准承载令牌和授权码与使用它们的客户端没有加密连接，这是OAuth 1中OAuth 2的重大变化。</p>
<h3 id="移动和其他设备"><a href="#移动和其他设备" class="headerlink" title="移动和其他设备"></a>移动和其他设备</h3><p>编写这些规范是为了在更广泛的设备上支持OAuth。</p>
<h4 id="适用于原生应用的OAuth-2-0"><a href="#适用于原生应用的OAuth-2-0" class="headerlink" title="适用于原生应用的OAuth 2.0"></a>适用于原生应用的OAuth 2.0</h4><p><code>https://tools.ietf.org/html/draft-ietf-oauth-native-apps</code></p>
<p>本文档更多的是一组准则而不是协议更改。在本文档中，您将找到针对这些环境特有的原生应用程序和安全建议的建议。它描述了诸如不允许第三方应用程序打开更容易受到网络钓鱼攻击的嵌入式Web视图以及有关如何执行此操作的特定于平台的建议。它还建议使用PKCE扩展，如下所述。</p>
<h4 id="PKCE：代码交换的证明密钥（RFC-7636）"><a href="#PKCE：代码交换的证明密钥（RFC-7636）" class="headerlink" title="PKCE：代码交换的证明密钥（RFC 7636）"></a>PKCE：代码交换的证明密钥（RFC 7636）</h4><p><code>https://tools.ietf.org/html/rfc7636</code></p>
<p>移动和桌面应用等公共客户端缺少使授权流程安全的Web应用程序的许多功能。Web应用程序具有使用HTTPS URL访问的好处，因此授权服务器可以合理地确信它在生成授权代码后,将用户的浏览器重定向到正确的应用程序。在用授权码交换访问令牌时，Web应用程序还能够利用客户端秘钥。由于移动和桌面应用程序都没有这些功能，因此授权服务器无法确定它是否将用户返回到正确的应用程序。</p>
<p>PKCE扩展描述了应用程序首先生成在请求访问令牌时使用秘钥的方式，以便拦截授权代码的攻击者无法使用被盗代码。</p>
<p>PKCE中详细介绍了PKCE扩展。</p>
<h4 id="设备流程"><a href="#设备流程" class="headerlink" title="设备流程"></a>设备流程</h4><p><code>https://tools.ietf.org/html/draft-ietf-oauth-device-flow</code></p>
<p>设备流是一种扩展，它使没有浏览器或有限输入功能的设备能够获得用户授权。您通常会在没有网络浏览器的Apple TV等设备上看到这种情况，或者除了几个按钮之外没有输入机制的流式视频编码器。</p>
<p>该流程的工作原理是让用户访问辅助设备（如智能手机）上的URL并输入设备上显示的代码。</p>
<h4 id="身份验证和会话管理"><a href="#身份验证和会话管理" class="headerlink" title="身份验证和会话管理"></a>身份验证和会话管理</h4><p>这些规范用于促进身份验证和会话管理，这两者都不是核心OAuth规范的一部分。</p>
<h4 id="OpenID-Connect"><a href="#OpenID-Connect" class="headerlink" title="OpenID Connect"></a>OpenID Connect</h4><p><code>https://openid.net/connect/</code></p>
<p>由于OAuth框架仅描述授权方法，并且未提供有关用户的任何详细信息，因此OpenID Connect通过描述身份验证和会话管理机制来填补这一空白。</p>
<h4 id="IndieAuth"><a href="#IndieAuth" class="headerlink" title="IndieAuth"></a>IndieAuth</h4><p><code>https://www.w3.org/TR/indieauth/</code></p>
<p>IndieAuth是一个基于OAuth 2.0构建的分散式身份协议，使用URL来识别用户和应用程序。这样就无需事先注册客户端，因为所有客户端都有内置的客户端ID：应用程序的URL。</p>
<h4 id="令牌撤销（RFC-7009）"><a href="#令牌撤销（RFC-7009）" class="headerlink" title="令牌撤销（RFC 7009）"></a>令牌撤销（RFC 7009）</h4><p><code>https://tools.ietf.org/html/rfc7009</code></p>
<p>本文档描述了授权服务器的新endpoint，客户端可以使用该endpoint通知服务器不再需要访问令牌或刷新令牌。这用于在客户端中启用“注销”功能，允许授权服务器清除与该会话关联的任何凭据。</p>
<h3 id="交互操作"><a href="#交互操作" class="headerlink" title="交互操作"></a>交互操作</h3><p>为了支持创建可以与任何OAuth 2.0服务器一起使用的完全通用的客户端，需要对发现和客户端注册等内容进行标准化，因为它们超出了核心规范的范围。</p>
<h4 id="授权服务器元数据"><a href="#授权服务器元数据" class="headerlink" title="授权服务器元数据"></a>授权服务器元数据</h4><p><code>https://tools.ietf.org/html/rfc8414</code></p>
<p>授权服务器元数据规范（也称为发现）定义了客户端用于查找与特定OAuth服务器交互所需的信息的格式。这包括查找授权endpoint和列出支持的范围等内容。</p>
<h4 id="动态客户端注册（RFC-7591）"><a href="#动态客户端注册（RFC-7591）" class="headerlink" title="动态客户端注册（RFC 7591）"></a>动态客户端注册（RFC 7591）</h4><p><code>https://tools.ietf.org/html/rfc7591</code></p>
<p>通常，开发人员将手动在服务中注册应用程序以获取客户端ID，并提供有关将在授权接口上使用的应用程序的信息。此规范提供了动态或以编程方式注册客户端的机制。此规范源自OpenID Connect动态客户端注册规范，并且仍与OpenID Connect服务器兼容。</p>
<h4 id="动态客户端管理（RFC-7592）"><a href="#动态客户端管理（RFC-7592）" class="headerlink" title="动态客户端管理（RFC 7592）"></a>动态客户端管理（RFC 7592）</h4><p><code>https://tools.ietf.org/html/rfc7592</code></p>
<p>在需要更新客户端信息的情况下，此规范提供了以编程方式执行此操作的机制。此规范扩展了动态注册RFC 7591。</p>
<h3 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h3><p>这些规范支持更高级的企业用例。</p>
<h4 id="断言框架（RFC-7521）"><a href="#断言框架（RFC-7521）" class="headerlink" title="断言框架（RFC 7521）"></a>断言框架（RFC 7521）</h4><p><code>https://tools.ietf.org/html/rfc7521</code></p>
<p>此规范提供了使用OAuth 2.0断言的框架。它定义了新的客户端身份验证机制和新的授权授予类型。由于此规范也是一个框架，因此它仅适用于下面描述的特定断言类型之一。</p>
<h4 id="JWT断言（RFC-7523）"><a href="#JWT断言（RFC-7523）" class="headerlink" title="JWT断言（RFC 7523）"></a>JWT断言（RFC 7523）</h4><p><code>https://tools.ietf.org/html/rfc7523</code></p>
<p>此规范描述了当JWT的内容与客户端存在信任关系时，如何使用JWT来请求访问令牌。它还描述了如何将JWT用作核心OAuth授权的客户端身份验证。</p>
<h4 id="SAML断言（RFC-7522）"><a href="#SAML断言（RFC-7522）" class="headerlink" title="SAML断言（RFC 7522）"></a>SAML断言（RFC 7522）</h4><p><code>https://tools.ietf.org/html/rfc7522</code></p>
<p>此规范描述了当与客户端存在信任关系时，如何使用SAML断言来请求访问令牌。例如，这可用于将旧版SAML工作流与新的OAuth 2.0系统集成。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--IndieAuth]]></title>
      <url>/2018/07/13/oauth-guide-23/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>IndieAuth是一个基于OAuth 2.0的分散式身份协议，它使用URL来识别用户和应用程序。它允许人们在使用该身份登录和授权应用程序时使用其控制下的域作为其身份。该规范可以在<code>https://www.w3.org/TR/indieauth/</code>找到。</p>
<p>所有用户ID都是URL，并且应用程序也通过其URL而不是预先注册的客户端ID进行标识。这使得它非常适用于您不希望开发人员在每个授权服务器上注册帐户的情况，例如在WordPress安装中对用户进行身份验证的应用程序。</p>
<p>IndieAuth分离授权服务器和发布访问令牌的角色，以便可以为流程的每个部分使用完全独立的实现和服务。</p>
<p>当应用程序只需要识别用户进行登录时，IndieAuth可以用作身份验证机制，或者应用程序可以使用IndieAuth来获取用户使用的访问令牌。</p>
<p>例如，Micropub客户端使用IndieAuth获取访问令牌，然后用于在用户的网站上创建内容。</p>
<p>IndieAuth建立在OAuth 2.0框架之上，如下所示：</p>
<ul>
<li>指定用于标识用户的机制和格式（可解析的URL）</li>
<li>指定在给定profile URL的情况下发现授权和令牌endpoint的方法</li>
<li>指定客户端ID的格式（也作为可解析的URL）</li>
<li>所有客户都是公共客户，因为不使用客户秘钥</li>
<li>客户端注册不是必需的，因为所有客户端都必须使用可解析的URL作为其客户端ID</li>
<li>重定向URI注册是由应用程序在其网站上公布其有效的重定向URL来完成的</li>
<li>指定令牌endpoint和授权endpoint进行通信的机制，类似于令牌自解析这是针对授权码的</li>
</ul>
<p>更多信息和规范可以在<a href="IndieAuth">indieauth.net</a>找到。下面是两个工作流程的简要概述。</p>
<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><p>在应用程序可以重定向到授权服务器之前，应用程序需要知道将用户引导到哪个授权服务器！这是因为每个用户都由URL标识，并且用户的URL指示其授权服务器所在的位置。</p>
<p>应用程序首先需要提示用户输入其URL，或以其他方式获取其URL。通常，应用程序将包含一个URL字段，供用户输入其URL。</p>
<p>该应用程序将向用户的URL发出HTTP GET请求，查找HTTP Link header或HTML <code>&lt;link&gt;</code>的标记的<code>authorization_endpoint</code>的<code>rel</code>值。在客户端也试图为用户获取访问令牌的情况下，它还将查找<code>token_endpoint</code>的<code>rel</code>值。</p>
<p>例如，GET请求<code>https://aaronparecki.com/</code>可能会返回以下内容，显示为缩写的HTTP请求。</p>
<pre><code class="http">HTTP/2 200
content-type: text/html; charset=UTF-8
link: &lt;https://aaronparecki.com/auth&gt;; rel=&quot;authorization_endpoint&quot;
link: &lt;https://aaronparecki.com/token&gt;; rel=&quot;token_endpoint&quot;
link: &lt;https://aaronparecki.com/micropub&gt;; rel=&quot;micropub&quot;

&lt;!doctype html&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Aaron Parecki&lt;/title&gt;
&lt;link rel=&quot;authorization_endpoint&quot; href=&quot;/auth&quot;&gt;
&lt;link rel=&quot;token_endpoint&quot; href=&quot;/token&quot;&gt;
&lt;link rel=&quot;micropub&quot; href=&quot;/micropub&quot;&gt;
</code></pre>
<p>请注意，endpoint URL可以是相对URL或绝对URL，并且可以位于与用户endpoint相同的域或不同的域上。这允许用户为任何组件使用托管服务。</p>
<p>有关发现的更多详细信息，请访问<br><code>https://www.w3.org/TR/indieauth/#discovery-by-clients</code>。</p>
<h3 id="登录工作流程"><a href="#登录工作流程" class="headerlink" title="登录工作流程"></a>登录工作流程</h3><p>用户登录应用程序的基本流程如下。</p>
<ul>
<li>用户以应用程序的登录形式输入其个人URL。</li>
<li>发现：应用程序获取URL并查找用户的授权endpoint。</li>
<li>授权请求：应用程序将用户的浏览器定向到发现的授权endpoint，作为标准OAuth 2.0授权以及在第一步中输入的用户URL。</li>
<li>身份验证/批准：用户在其授endpoint进行身份验证并批准登录请求。授权服务器生成授权代码并重定向回应用程序的重定向URL。</li>
<li>验证：应用程序检查授权endpoint处的代码，类似于交换访问令牌的代码，但不返回访问令牌，因为这只是对身份验证的检查。授权endpoint使用经过身份验证的用户的完整URL进行响应。</li>
</ul>
<h4 id="认证请求"><a href="#认证请求" class="headerlink" title="认证请求"></a>认证请求</h4><p>当应用程序构建URL以对用户进行身份验证时，该请求看起来与OAuth授权请求非常相似，除了不需要预先注册客户端，并且该请求还将包括用户的profile URL。URL将如下所示。</p>
<pre><code class="http">https://user.example.net/auth?
    me=https://user.example.net/
    &amp;amp;redirect_uri=https://example-app.com/redirect
    &amp;amp;client_id=https://example-app.com/
    &amp;amp;state=1234567890
</code></pre>
<p>然后授权服务器会要求用户登录，就像OAuth流程一样，然后询问用户是否要继续登录应用程序，如下所示。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ftoifez6zej311g0fywm8.jpg" alt="auth"></p>
<p>如果用户批准，将使用查询字符串中的授权码（和应用程序的状态值）将它们重定向回应用程序。</p>
<p>然后，应用程序将获取授权码并使用授权endpoint对其进行验证，以确认登录用户的身份。应用程序向授权endpoint发出POST请求code，<code>client_id</code>并且<code>redirect_uri</code>就像正常的授权码一样交换。</p>
<pre><code class="http">POST /auth
Host: user.example.net
Content-type: application/x-www-form-urlencoded

code=xxxxxxxx
&amp;amp;client_id=https://example-app.com/
&amp;amp;redirect_uri=https://example-app.com/redirect
</code></pre>
<p>响应将是一个简单的JSON对象，其中包含用户的完整profile URL。</p>
<pre><code class="http">HTTP/1.1 200 OK
Content-Type: application/json

{
  &quot;me&quot;: &quot;https://user.example.net/&quot;
}
</code></pre>
<p>有关处理请求和响应的更多详细信息，请参阅<br><code>https://www.w3.org/TR/indieauth/#authorization-code-verification</code>。</p>
<h3 id="授权工作流程"><a href="#授权工作流程" class="headerlink" title="授权工作流程"></a>授权工作流程</h3><p>当应用程序尝试获取用户的访问令牌以修改或访问用户的数据时，将使用授权工作流程。这类似于访问数据中描述的OAuth 2.0授权码工作流程，但不使用预先注册客户端，因为使用了URL。</p>
<p>下面是授权应用程序的用户的基本流程。</p>
<ul>
<li>用户以应用程序的登录形式输入其个人URL。</li>
<li>发现：应用程序获取URL并查找用户的授权和令牌endpoint。</li>
<li>授权请求：应用程序将用户的浏览器定向到发现的授权endpoint，作为标准OAuth 2.0授权授予和请求的范围，以及在第一步中输入的用户URL。</li>
<li>身份验证/批准：用户在其授权endpoint进行身份验证，查看请求的范围并批准请求。授权服务器生成授权代码并重定向回应用程序的重定向URL。</li>
<li>令牌交换：应用程序向令牌端点发出请求用授权码交换访问令牌。令牌端点使用访问令牌和经过身份验证的用户的完整URL进行响应。</li>
</ul>
<h4 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h4><p>当应用程序构建URL以对用户进行身份验证时，该请求看起来与OAuth授权请求非常相似，除了不需要预先注册客户端，并且该请求还将包括用户的profile URL。URL将如下所示。</p>
<pre><code class="http">https://user.example.net/auth?
    me=https://user.example.net/
    &amp;amp;response_type=code
    &amp;amp;redirect_uri=https://example-app.com/redirect
    &amp;amp;client_id=https://example-app.com/
    &amp;amp;state=1234567890
    &amp;amp;scope=create+update
</code></pre>
<p>请注意，与上述身份验证请求不同，此请求包括<code>response_type=code</code>和应用程序请求的请求范围列表。</p>
<p>授权服务器将要求用户登录，然后向他们提供授权提示。</p>
<p>不同的IndieAuth服务器可能会以不同的方式显示此提示，如我网站的授权服务器和下面显示的WordPress IndieAuth插件的屏幕截图所示。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftoininhyaj31020y47fr.jpg" alt="me"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ftoio589r3j30bd0hrt9i.jpg" alt="wordpress"></p>
<p>当用户批准该请求时，服务器将用户重定向回具有查询字符串中的授权码的应用程序。</p>
<p>为了获得访问令牌，应用程序使用授权码和其他所需数据向用户的令牌endpoint（在第一个发现步骤中发现的endpoint）发出POST请求。</p>
<pre><code class="http">POST /token
Host: user.example.net
Content-type: application/x-www-form-urlencoded&lt;/pre&gt;

&lt;pre class=&quot;break-before&quot;&gt;grant_type=authorization_code
&amp;amp;code=xxxxxxxx
&amp;amp;client_id=https://example-app.com/
&amp;amp;redirect_uri=https://example-app.com/redirect
&amp;amp;me=https://user.example.net/
</code></pre>
<p>令牌endpoint将为用户生成访问令牌，并使用正常的OAuth 2.0令牌响应进行响应，并添加授权应用程序的用户的profile URL。</p>
<pre><code class="http">HTTP/1.1 200 OK
Content-Type: application/json

{
  &quot;me&quot;: &quot;https://user.example.net/&quot;,
  &quot;token_type&quot;: &quot;Bearer&quot;,
  &quot;access_token&quot;: &quot;XXXXXX&quot;,
  &quot;scope&quot;: &quot;create update&quot;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--OpenID Connect]]></title>
      <url>/2018/07/13/oauth-guide-22/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>OAuth 2.0框架明确不提供有关已授权应用程序的用户的任何信息。OAuth 2.0是一个委派框架，允许第三方应用程序代表用户行事，而无需应用程序知道用户的身份。</p>
<p>OpenID Connect采用OAuth 2.0框架并在顶部添加标识层。它提供有关用户的信息，并使客户端能够建立登录会话。虽然本章并不是OpenID Connect的完整指南，但它旨在阐明OAuth 2.0和OpenID Connect如何相互关联。</p>
<h3 id="授权与身份验证"><a href="#授权与身份验证" class="headerlink" title="授权与身份验证"></a>授权与身份验证</h3><p>OAuth 2.0被称为授权“框架”而不是“协议”，因为核心规范实际上为各种实现留下了相当大的空间，根据其用例不同地执行操作。具体来说，OAuth 2.0不提供说明用户是谁或如何进行身份验证的机制，它只是说用户委托应用程序代表他们行事。OAuth 2.0框架以访问令牌的形式提供此委派，应用程序可以使用该令牌代表用户执行操作。访问令牌被呈现给API（“资源服务器”），其知道如何验证访问令牌是否是活动的。从应用程序的角度来看，它是一个不透明的字符串。</p>
<p>当您入住酒店时，您将获得一张钥匙卡，您可以使用该卡进入指定的房间。您可以将钥匙卡视为访问令牌。钥匙卡上没有说明您的身份，也没有说明您在前台的身份验证，但您可以在入住期间使用该卡进入酒店房间。同样，OAuth 2.0访问令牌不会指示用户是谁，它只是您可以用来访问数据的东西，它可能会在将来某个时候到期。</p>
<p>OAuth 2.0有意设计为在不提供用户身份和身份验证的情况下提供授权，因为这些问题具有非常不同的安全注意事项，这些注意事项不一定与授权协议的安全注意事项重叠。分别处理身份验证和身份允许是OAuth 2.0框架用作构建身份验证协议的一部分。</p>
<h3 id="构建身份验证框架"><a href="#构建身份验证框架" class="headerlink" title="构建身份验证框架"></a>构建身份验证框架</h3><p>OAuth 2.0框架是作为构建身份验证和身份协议的基础。</p>
<p>要使用OAuth 2.0作为身份验证协议的基础，您至少需要做一些事情。</p>
<ul>
<li>定义endpoint以返回有关用户的属性</li>
<li>定义第三方应用程序可用于进行请求用户身份信息的一个或多个范围</li>
<li>在处理身份验证时，需要定义其错误代码和必要的扩展参数，例如当会话超时重新提示用户输入凭据，或者如何允许用户选择新帐户登录应用程序。</li>
</ul>
<p>通常，当单个提供商尝试向OAuth 2.0添加内容以创建身份验证和身份协议时，这会导致另一个API具有不同程度的安全性。OpenID Connect从许多不同的实现中获取共享，并将其标准化为适合企业级实现的协议。</p>
<h3 id="ID令牌"><a href="#ID令牌" class="headerlink" title="ID令牌"></a>ID令牌</h3><p>OpenID Connect的核心基于一个名为“ID令牌”的概念。这是授权服务器将返回的新令牌类型，它对用户的身份验证信息进行编码。与仅旨在由资源服务器理解的访问令牌相反，ID令牌旨在被第三方应用程序理解。当客户端发出OpenID Connect请求时，它可以请求ID令牌以及访问令牌。</p>
<p>OpenID Connect的ID令牌采用JWT（JSON Web令牌）的形式，JWT是一个JSON有效负载，使用发行者的私钥进行签名，并且可以由应用程序进行解析和验证。</p>
<p>JWT内部是一些定义的属性名称，它们为应用程序提供信息。它们用简写名称表示，以保持JWT的整体大小。这包括用户的唯一标识符（sub即“subject”的缩写），发出令牌的服务器的标识符（iss即“issuer”的缩写），请求此令牌的客户端的标识符（aud即“audience”的缩写），以及少数属性，例如令牌的生命周期，以及用户在多长时间之前获得主要身份验证提示。</p>
<pre><code class="json">{
  &quot;iss&quot;: &quot;https://server.example.com&quot;,
  &quot;sub&quot;: &quot;24400320&quot;,
  &quot;aud&quot;: &quot;s6BhdRkqt3&quot;,
  &quot;nonce&quot;: &quot;n-0S6_WzA2Mj&quot;,
  &quot;exp&quot;: 1311281970,
  &quot;iat&quot;: 1311280970,
  &quot;auth_time&quot;: 1311280969,
  &quot;acr&quot;: &quot;urn:mace:incommon:iap:silver&quot;
}
</code></pre>
<p>标准化endpoint，名称和元数据有助于减少实现错误，并允许传递共享关于安全性考虑的知识。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OpenID Connect在OAuth 2.0框架之上提供用户身份和身份验证。您可以使用OpenID Connect建立登录会话，并使用OAuth访问受保护资源。</p>
<p>您可以是有与OAuth 2.0相同的流程，以便同时请求ID令牌和访问令牌两种认证，以及获得授权访问受保护的资源。</p>
<p>OpenID Connect由OpenID Foundation维护。可以在<code>https://openid.net/connect/</code>上完整阅读核心OpenID Connect规范以及许多扩展。</p>
<p><a href="https://oidcdebugger.com/" target="_blank" rel="noopener">OpenID Connect Debugger</a>是一个奇妙的资源，帮助您构建OpenID Connect请求。此外，<a href="https://www.oauth.com/playground/" target="_blank" rel="noopener">OAuth 2.0 Playground</a>还提供了针对实时服务器的OpenID Connect流程演练。</p>
<p>在使用Google登录时，我们将使用OpenID Connect构建一个示例应用。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--OAuth 1和2之间的差异]]></title>
      <url>/2018/07/13/oauth-guide-21/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>OAuth 2.0从头开始就完全重写了OAuth 1.0，仅共享总体目标和一般用户体验。OAuth 2.0不向后兼容OAuth 1.0或1.1，应该被视为一个全新的协议。</p>
<p>OAuth 1.0主要基于两个现有的专有协议：Flickr的授权API和Google的AuthSub。OAuth 1.0的工作是基于当时实际实施经验的最佳解决方案。在许多公司构建OAuth 1 API的过程中，以及许多编写代码来使用API​​的开发人员和社区了解到协议在哪些方面对人们产生了挑战。几个特定领域被确定为需要改进，因为它们要么限制API的能力，要么实施起来太具挑战性。</p>
<p>OAuth 2.0代表了多家公司和个人之间多年的讨论，包括Yahoo！，Facebook，Salesforce，Microsoft，Twitter，Deutsche Telekom，Intuit，Mozilla和Google。</p>
<p>本节介绍OAuth 1.0和2.0之间的主要差异，以及它们背后的动机。如果您熟悉OAuth 1.0，这是快速了解OAuth 2.0中主要更改的良好起点。</p>
<h3 id="术语和角色"><a href="#术语和角色" class="headerlink" title="术语和角色"></a>术语和角色</h3><p>OAuth 2.0定义了四个角色（客户端，授权服务器，资源服务器和资源所有者），OAuth 1对这些角色使用不同的术语集。OAuth 2.0的“客户端”被称为“消费者”，“资源所有者”被简称为“用户”，“资源服务器”被称为“服务提供者”。OAuth 1也未明确区分资源服务器和授权服务器的角色。</p>
<p>“two-legged”和“three-legged”这两个术语已被授权类型的概念所取代，例如客户凭证授权类型和授权码授权类型。</p>
<h3 id="身份验证和签名"><a href="#身份验证和签名" class="headerlink" title="身份验证和签名"></a>身份验证和签名</h3><p>由于协议的加密要求，大多数OAuth 1.0实施尝试都失败了。对于任何来自简单用户名/密码身份验证的人来说，OAuth 1.0签名的复杂性是一个主要的痛点。</p>
<p>过去，开发人员只需使用用户名和密码即可快速编写Twitter脚本以执行有用的操作。随着迁移到OAuth 1.0，这些开发人员被迫查找，安装和配置库，以便向Twitter API发出请求，因为它需要对每个请求进行加密签名。</p>
<p>随着OAuth 2.0承载令牌的引入，再次可以通过cURL命令快速进行API调用。使用访问令牌而不是使用用户名和密码。</p>
<p>例如，在OAuth之前，您可能已经看过API文档中的示例，例如：</p>
<pre><code class="bash">curl --user bob:pa55 https://api.example.com/profile
</code></pre>
<p>使用OAuth 1 API，不再可能对此类示例进行硬编码，因为请求必须使用应用程序的密钥进行签名。Twitter等一些服务开始在其开发者网站中提供“签名生成器”工具，这样您就可以在不使用库的情况下从网站生成curl命令。例如，Twitter上的工具生成一个curl命令，例如：</p>
<pre><code class="bash">curl --get &#39;https://api.twitter.com/1.1/statuses/show.json&#39; \
--data &#39;id=210462857140252672&#39; \
--header &#39;Authorization: OAuth oauth_consumer_key=&quot;xRhHSKcKLl9VF7fbyP2eEw&quot;, oauth_nonce=&quot;33ec5af28add281c63db55d1839d90f1&quot;, oauth_signature=&quot;oBO19fJO8imCAMvRxmQJsA6idXk%3D&quot;, oauth_signature_method=&quot;HMAC-SHA1&quot;, oauth_timestamp=&quot;1471026075&quot;, oauth_token=&quot;12341234-ZgJYZOh5Z3ldYXH2sm5voEs0pPXOPv8vC0mFjMFtG&quot;, oauth_version=&quot;1.0&quot;&#39;
</code></pre>
<p>使用OAuth 2.0承载令牌，请求中只需要令牌本身，因此示例再次变得非常简单：</p>
<pre><code class="bash">curl https://api.example.com/profile -H &quot;Authorization: Bearer XXXXXXXXXXX&quot;
</code></pre>
<p>这在API的易用性和良好的安全实践之间提供了良好的平衡。</p>
<h3 id="用户体验和备用令牌颁发选项"><a href="#用户体验和备用令牌颁发选项" class="headerlink" title="用户体验和备用令牌颁发选项"></a>用户体验和备用令牌颁发选项</h3><p>OAuth 2.0有两个主要部分：用户获取授权（最终结果是应用程序具有该用户的访问令牌），并使用访问令牌代表用户发出请求。获取访问令牌的方法称为流程。</p>
<p>OAuth 1.0最初有3个流程，适用于基于Web的应用程序，桌面客户端以及移动或“有限”设备。但是，随着规范的发展，这三个流程合并为一个理论上支持所有三种客户端类型的流程。在实践中，流程适用于基于Web的应用程序，但在其他地方提供了较差的体验。</p>
<p>随着越来越多的网站开始使用OAuth，尤其是Twitter，开发人员意识到OAuth提供的单一流程非常有限，并且通常会产生糟糕的用户体验。另一方面，Facebook Connect提供了更丰富的流程，适用于Web应用程序，移动设备和游戏控制台。</p>
<p>OAuth 2.0通过再次定义多个流程来解决这个问题，称为“授权类型”，可以灵活地支持各种应用程序类型。还有一种机制来开发扩展来处理以前没想过的用例。</p>
<p>服务器端应用程序使用“授权码”授权类型和客户端秘钥，提示用户授权应用程序，并生成一个授权码，该代码将传回应用程序。然后，应用程序的服务器用授权码交换访问令牌。服务器端应用程序使用其秘钥来和授权码交换访问令牌，可以获得此流程的安全性。</p>
<p>单页或移动应用程序使用相同的授权类型，但不使用客户机秘钥。相反，安全性在于验证重定向URL以及可选的PKCE扩展。</p>
<p>OAuth 2.0正式定义了“密码”授权类型，允许应用程序收集用户的用户名和密码，并将其交换为访问令牌。虽然这是规范的一部分，但它仅供受信任的客户端使用，例如服务自己的第一方应用程序。它不应该被第三方应用程序使用，因为这将允许第三方应用程序访问用户的用户名和密码。</p>
<p>当应用程序访问其自己的资源时，将使用“客户端凭据”授予。此授权类型只是交换<code>client_id</code>和<code>client_secret</code>来获取访问令牌。</p>
<p>OAuth 2.0还支持扩展授予类型，允许组织定义自己的自定义授权类型以支持其他客户端类型或在OAuth与现有系统之间提供桥接。</p>
<p>其中一个扩展是用于在没有Web浏览器的设备上授权应用程序的设备流程。</p>
<h3 id="规模表现"><a href="#规模表现" class="headerlink" title="规模表现"></a>规模表现</h3><p>随着较大的提供商开始使用OAuth 1.0，社区意识到该协议有一些限制，使得难以扩展到大型系统。OAuth 1.0需要跨不同步骤进行状态管理，并且通常跨不同服务器进行。它需要生成临时凭证，这些凭证通常被丢弃未使用，并且通常需要发布安全性较低且难以管理的持久凭证。</p>
<p>此外，OAuth 1.0要求受保护资源endpoint可以访问客户端凭据以验证请求。这打破了大多数大型提供商的典型架构，其中集中授权服务器用于颁发凭证，并且单独的服务器用于处理API调用。由于OAuth 1.0需要使用客户端凭据来验证签名，因此这种分离非常困难。</p>
<p>OAuth 2.0仅在应用程序从用户获取授权时使用客户端凭据来解决此问题。在授权步骤中使用凭据后，在进行API调用时仅使用生成的访问令牌。这意味着API服务器不需要知道客户端凭据，因为它们可以自己验证访问令牌。</p>
<h3 id="承载令牌（Bearer-Tokens）"><a href="#承载令牌（Bearer-Tokens）" class="headerlink" title="承载令牌（Bearer Tokens）"></a>承载令牌（Bearer Tokens）</h3><p>在OAuth 1中，访问令牌有两个组件，即公共字符串和私有字符串。签名请求时使用私有字符串，并且从不通过网络发送。</p>
<p>访问OAuth 2.0 API的最常用方法是使用“承载令牌”。这是一个单个字符串，用作API请求的身份验证，在HTTP“授权”header中发送。该字符串对于使用它的客户来说毫无意义，并且可能具有不同的长度。</p>
<p>承载令牌是一种更简单的API请求方式，因为它们不需要对每个请求进行加密签名。权衡是所有API请求必须通过HTTPS连接进行，因为请求包含一个明文标记，如果被截获，任何人都可以使用该标记。优点是它不需要复杂的库来发出请求，并且客户端和服务器实现起来要简单得多。</p>
<p>承载令牌的缺点是没有任何东西阻止其他应用程序使用Bearer令牌，如果这个应用程序可以访问它。这是对OAuth 2.0的常见批评，尽管大多数提供商仍然只使用Bearer令牌。在正常情况下，当应用程序正确保护其控制下的访问令牌时，这不是问题，尽管从技术上讲它不太安全。如果您的服务需要更安全的方法，则可以使用可满足安全要求的其他访问令牌类型。</p>
<h3 id="具有长期授权的短期令牌"><a href="#具有长期授权的短期令牌" class="headerlink" title="具有长期授权的短期令牌"></a>具有长期授权的短期令牌</h3><p>OAuth 1.0 API通常会发布极其持久的访问令牌。这些令牌可以无限期地持续，或者大约一年。虽然对开发人员来说很方便，但在某些情况下，这证明限制了一些服务。</p>
<p>负责任的API提供商应允许用户查看他们已授权使用其帐户的第三方应用，并且应该能够根据需要撤消应用。如果用户撤消了应用，则API应该停止尽快结束发布到该应用的访问令牌。根据API的实现方式，这可能具有挑战性，或者需要系统内部部件之间的其他联系。</p>
<p>使用OAuth 2.0，授权服务器可以发出短期访问令牌和长期刷新令牌。这允许应用程序在不涉及用户的情况下获得新的访问令牌，但也增加了服务器更容易撤销令牌的能力。此功能是从Yahoo！的BBAuth协议和后来的OAuth 1.0会话扩展中采用的。</p>
<h3 id="角色分离"><a href="#角色分离" class="headerlink" title="角色分离"></a>角色分离</h3><p>OAuth 2.0的设计决策之一是明确地将授权服务器的角色与API服务器分开。这意味着您可以将授权服务器构建为独立组件，该组件仅负责从用户获取授权并向客户端发送令牌。这两个角色可以位于物理上独立的服务器上，甚至可以位于不同的域名上，从而允许系统的每个部分独立扩展。某些提供程序有许多资源服务器，每个服务器位于不同的子域中。</p>
<p>授权服务器需要了解应用程序的<code>client_id</code>和<code>client_secret</code>，但API服务器将只需要接受访问令牌。通过将授权服务器构建为独立组件，您可以避免与API服务器共享数据库，从而可以更轻松地独立于授权服务器扩展API服务器，因为它们不需要共享公共数据存储。</p>
<p>例如，Google的OAuth 2.0实施使用“accounts.google.com”上的服务器进行授权请求，但在向Google+ API发出请求时使用“www.gooogleapis.com”。</p>
<p>服务提供商的好处是这些系统的开发可以完全独立地由不同的团队和不同的时间线发生。由于它们是完全独立的，因此可以独立扩展，升级或更换，而无需考虑系统的其他部分。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--术语参考]]></title>
      <url>/2018/07/13/oauth-guide-20/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>OAuth定义了四个角色：</p>
<ul>
<li>资源所有者（用户）</li>
<li>资源服务器（API）</li>
<li>授权服务器（可以是与API相同的服务器）</li>
<li>客户端（第三方应用）</li>
</ul>
<h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>OAuth 2.0规范将用户称为“资源所有者”。资源所有者是能够允许访问其部分帐户的人员。在这种情况下，资源可以是数据（照片，文档，联系人），服务（发布博客条目，转移资金）或任何其他需要访问限制的资源。任何想要代表用户行事的系统必须首先获得他们的许可。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>规范指的是您通常认为的主要API作为“资源服务器”。资源服务器是包含用户信息的服务器，用于第三方应用程序的访问。资源服务器必须能够接受并验证访问令牌，并在用户允许的情况下授予请求。资源服务器不一定需要了解第三方的应用程序。</p>
<h3 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h3><p>授权服务器是用户在请求访问其帐户时与之交互的内容。这是显示OAuth提示的服务器，以及用户批准或拒绝访问请求的位置。授权服务器还负责在用户授权应用程序后授予访问令牌。因此，授权服务器通常具有两个主URL，一个用于授权请求，一个用于用于授予访问令牌的应用程序。这些通常是这样的：</p>
<ul>
<li><code>https://authorization-server.com/authorize</code></li>
<li><code>https://authorization-server.com/token</code></li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端是试图代表用户行动或访问用户资源的应用程序。在客户端可以访问用户的帐户之前，它需要获得许可。客户端通过将用户引导至授权服务器或通过直接与授权服务器断言权限，来实现无需用户交互来获得许可。</p>
<h3 id="私密客户端（Confidential-Clients）"><a href="#私密客户端（Confidential-Clients）" class="headerlink" title="私密客户端（Confidential Clients）"></a>私密客户端（Confidential Clients）</h3><p>私密客户端是能够保持client_secret（客户端密钥）机密性的客户端。通常，这些客户端只是在开发人员控制下的服务器上运行的应用程序，用户无法访问源代码。这些类型的应用程序通常称为“Web应用程序”，因为它们通常由Web浏览器访问。</p>
<h3 id="公共客户端（Public-Clients）"><a href="#公共客户端（Public-Clients）" class="headerlink" title="公共客户端（Public Clients）"></a>公共客户端（Public Clients）</h3><p>公共客户端无法保持client_secret（客户端密钥）的机密性，因此密钥不会用于这些应用程序。移动应用和Javascript应用都被视为公共客户端。由于运行Javascript应用程序的任何人都可以轻松查看应用程序的源代码，因此可以轻松地看到密钥。对于移动应用程序，可以反编译二进制文件以提取字符串。</p>
<h3 id="访问令牌（Access-Token）"><a href="#访问令牌（Access-Token）" class="headerlink" title="访问令牌（Access Token）"></a>访问令牌（Access Token）</h3><p>访问令牌是向API发出经过身份验证的请求时使用的字符串。令牌表示用户已授权第三方应用程序访问该用户的帐户。令牌具有相应的访问持续时间，范围和可能的其他信息。令牌可以是自解析的（服务器可以从令牌字符串中检索所有必要的信息），也可以是数据库中的密钥。</p>
<h3 id="刷新令牌（Refresh-Token）"><a href="#刷新令牌（Refresh-Token）" class="headerlink" title="刷新令牌（Refresh Token）"></a>刷新令牌（Refresh Token）</h3><p>刷新令牌是一个字符串，用于在访问令牌过期时获取新的访问令牌。并非所有API都使用刷新令牌。</p>
<h3 id="授权码（Authorization-Code）"><a href="#授权码（Authorization-Code）" class="headerlink" title="授权码（Authorization Code）"></a>授权码（Authorization Code）</h3><p>授权码是在服务器端应用程序流程中使用的中间令牌，更详细地描述服务器端应用程序。授权步骤后，授权码返回给客户端，然后客户端将其交换为访问令牌。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--创建文档]]></title>
      <url>/2018/07/13/oauth-guide-19/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>正如您在阅读完这篇文章后可能已经注意到的那样，OAuth 2.0规范中有很多地方需要做出决策。其中许多事情都没有明确规定，以便允许根据自己的安全要求做出不同的实现。最终结果是大多数OAuth 2.0实现都不可互操作，尽管在实践中，许多实现仍然做出了相同的决策，并且非常相似。</p>
<p>由于实现可以有许多不同的方式，因此为您的服务构建良好的文档至关重要。</p>
<p>本节介绍了您需要记录的内容，以便开发人员能够使用您的API。其中一些项目可以在适当的界面中内联记录（例如开发人员用于客户端注册的界面），有些更适合在API文档的“概述”部分中进行记录。</p>
<h3 id="客户注册"><a href="#客户注册" class="headerlink" title="客户注册"></a>客户注册</h3><p>开发人员如何注册新的客户端应用程序以获取客户端ID和可选的秘钥？</p>
<ul>
<li>提供注册页面的链接。</li>
<li>您的服务可能会实施<a href="https://tools.ietf.org/html/rfc7591" target="_blank" rel="noopener">动态客户端注册规范</a>，或者拥有用于注册应用程序的专有API</li>
<li>您是否为开发人员注册应用程序提供了其他机制？如果是这样，您将需要描述注册应用程序的其他方法。</li>
</ul>
<p>您的服务应至少询问开发人员他们的应用程序是私密客户端还是公共客户端，并提供注册重定向URI的方法。除此之外，您还应记录您收集的有关应用程序的其他信息，并指出在授权请求期间向最终用户显示哪些信息。</p>
<ul>
<li>应用名称</li>
<li>有关应用程序的网页</li>
<li>描述</li>
<li>logo或其他图像</li>
<li>有关应用程序使用条款的网页</li>
<li>其他信息</li>
</ul>
<h3 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h3><p>开发人员将在OAuth流程中使用两个主要endpoint。您的授权endpoint是指导用户开始授权流程的位置。在应用程序获得授权码后，它将在令牌endpoint处交换该代码以获取访问令牌。令牌endpoint还负责为其他授权类型发出访问令牌。</p>
<p>您需要让开发人员知道他们将使用的这两个endpoint的URL。</p>
<h3 id="客户端认证"><a href="#客户端认证" class="headerlink" title="客户端认证"></a>客户端认证</h3><p>如果请求中需要客户端身份验证（例如授权码授权），则服务可以通过两种方式接受请求中的客户端ID和秘钥。您的服务可以使用客户端ID作为用户名和秘钥作为密码接受HTTP Basic Auth header中的身份验证，或者接受post body中的字符串作为<code>client_id</code>和<code>client_secret</code>。无论您是要接受这些方法中的一种还是两种，都取决于您的服务，因此您需要告诉开发人员您希望他们如何在请求中包含此身份验证。</p>
<p>此外，您的服务可能支持其他形式的客户端身份验证，例如公钥/私钥对。这在当前部署的OAuth 2.0实现中相对不常见，但是规范保留了开放的可能性。</p>
<p>对发布给应用程序的客户端ID和秘钥的最大或最小长度没有要求，因此通常最好让开发人员知道这些字符串有多大，以便他们可以适当地存储它们。</p>
<h3 id="字符串的大小"><a href="#字符串的大小" class="headerlink" title="字符串的大小"></a>字符串的大小</h3><p>由于开发人员在开始编写代码之前不会看到授权码或访问令牌，因此您应该记录他们将遇到的字符串的最大大小。</p>
<ul>
<li>客户端ID</li>
<li>客户端秘钥</li>
<li>授权码</li>
<li>访问令牌</li>
</ul>
<h3 id="响应类型"><a href="#响应类型" class="headerlink" title="响应类型"></a>响应类型</h3><p>您的服务支持哪些响应类型？通常，服务仅支持基于Web和本机应用程序的“code”响应类型。但是，如果您的服务还支持“token”响应类型（在没有中间授权码的情况下发出令牌），那么在文档中指出是很重要的。您应该记录您的服务是否支持其中一个或两个，以及您是否还有其他支持的响应类型。</p>
<h3 id="重定向URL限制"><a href="#重定向URL限制" class="headerlink" title="重定向URL限制"></a>重定向URL限制</h3><p>您的服务可能会对开发人员可以使用的已注册重定向URL进行限制。例如，服务通常会禁止开发人员使用非TLS httpendpoint，或限制非生产应用程序使用的endpoint。虽然支持自定义方案对于支持原生应用程序很重要，但某些服务也不允许这些。您应该记录您在注册重定向URL时的任何要求。</p>
<h3 id="默认范围"><a href="#默认范围" class="headerlink" title="默认范围"></a>默认范围</h3><p>如果开发人员在授权请求期间未指定范围，则服务可以假定该请求的默认范围。如果是这种情况，您应该记录默认范围。</p>
<p>授权服务器可以忽略开发人员请求的范围，或者添加超出请求范围的其他范围。服务器还可以允许用户根据请求改变范围。这些中的任何一种都是可能的，因此服务应该明确为开发人员指明，以便他们可以考虑访问令牌可能具有不同于他们请求的范围。</p>
<p>该服务还应记录授权码的生命周期，因此开发人员可以了解代码在发布和使用之间的持续时间。授权服务器还可以防止代码被多次使用，并且如果是这样则应该记录该代码。</p>
<h3 id="访问令牌响应"><a href="#访问令牌响应" class="headerlink" title="访问令牌响应"></a>访问令牌响应</h3><p>当您发出访问令牌时，访问令牌响应会列出许多可选的参数。您应该记录您的服务支持哪些，以便开发人员知道会发生什么。</p>
<p>响应何时包含<code>expires_in</code>参数？如果令牌会过期，您的服务可能始终包含它，如果没有此参数，您的服务应该可以记录开发人员应该期望的默认过期时间。</p>
<p>响应是否始终包含授予的访问令牌的范围？在响应中返回它通常是一个好主意，但是如果授权范围与请求的范围匹配，许多服务会将其遗漏。无论哪种方式，您都应该记录服务器对此参数的行为方式。</p>
<h3 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h3><p>OAuth 2.0 API开发人员面临的一个更令人困惑或令人沮丧的方面是刷新令牌。重要的是要非常清楚地了解您的服务如何处理刷新令牌（如果有的话）。</p>
<p>如果您的访问令牌过期，您可能希望支持刷新令牌，以便开发人员可以构建继续访问用户帐户的应用程序，而无需用户不断重新授权该应用程序。</p>
<p>您应该清楚地记录哪些受支持的授权类型在响应中应该包含刷新令牌。</p>
<p>当您的服务发出新的访问令牌以响应刷新令牌授权时，您的服务可以同时发出新的刷新令牌，并使之前的刷新令牌到期。这意味着刷新令牌经常刷新，这可能是您的应用程序所需要的。如果是这种情况，请确保开发人员知道这将发生，因此他们不会错误地假设他们获得的第一个刷新令牌将继续无限期地工作。</p>
<h3 id="扩展授权"><a href="#扩展授权" class="headerlink" title="扩展授权"></a>扩展授权</h3><p>除了四种基本授权类型（授权码，密码，客户端凭据和隐式）之外，您的服务还可以支持其他授权类型。</p>
<p>某些授权类型标准化为OAuth 2.0的扩展，例如设备流和SAML。某些服务还实现了自己的自定义授权类型，例如将旧版API迁移到OAuth 2.0时。记录您的服务支持的其他授权类型非常重要，并提供有关如何使用它们的文档。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--令牌自解析endpoint（Token Introspection Endpoint）]]></title>
      <url>/2018/07/13/oauth-guide-18/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>当OAuth 2.0客户端向资源服务器发出请求时，资源服务器需要某种方式来验证访问令牌。OAuth 2.0核心规范没有定义资源服务器应如何验证访问令牌，只是提到它需要在资源和授权服务器之间协调。在某些情况下，特别是对于小型服务，两个endpoint都是同一系统的一部分，并且可以在内部共享令牌信息，例如在数据库中。在两个endpoint位于不同服务器上的较大系统中，这导致了两个服务器之间通信的专有和非标准协议。</p>
<p>OAuth 2.0 令牌自解析扩展定义了一个协议，该协议返回有关访问令牌的信息，供资源服务器或其他内部服务器使用。</p>
<h3 id="令牌自解析规范"><a href="#令牌自解析规范" class="headerlink" title="令牌自解析规范"></a>令牌自解析规范</h3><p>令牌自解析规范可以在<code>https://tools.ietf.org/html/rfc7662</code>找到</p>
<h3 id="自解析endpoint"><a href="#自解析endpoint" class="headerlink" title="自解析endpoint"></a>自解析endpoint</h3><p>令牌自解析endpoint需要能够返回有关令牌的信息，因此您很可能将其构建在令牌endpoint所在的相同位置。两个endpoint需要共享数据库，或者如果您已实现自编码令牌，则需要共享密钥。</p>
<h3 id="令牌信息请求"><a href="#令牌信息请求" class="headerlink" title="令牌信息请求"></a>令牌信息请求</h3><p>该请求将是一个POST请求，仅包含名为“token”的参数。预计此endpoint不会公开给开发人员。不应允许最终用户客户端使用此endpoint，因为响应可能包含开发人员无权访问的特权信息。保护endpoint的一种方法是将其放在无法从外部访问的内部服务器上，或者可以使用HTTP basic auth证进行保护。</p>
<pre><code class="http">POST /token_info HTTP/1.1
Host: authorization-server.com
Authorization: Basic Y4NmE4MzFhZGFkNzU2YWRhN

token=c1MGYwNDJiYmYxNDFkZjVkOGI0MSAgLQ
</code></pre>
<h3 id="令牌信息响应"><a href="#令牌信息响应" class="headerlink" title="令牌信息响应"></a>令牌信息响应</h3><p>令牌自解析Endpoint应该使用具有下面列出的属性的JSON对象进行响应。必须的只有“active”属性，其余属性是可选的。自解析规范中的一些属性专门用于JWT令牌，因此我们将仅在此处介绍基本的属性。如果您有关于可能有用的令牌的其他信息，您还可以在响应中添加其他属性。</p>
<blockquote>
<p><strong>active</strong><br>必须。这是所呈现的令牌当前是否处于活动状态的布尔值。如果此授权服务器已发出令牌，用户尚未撤消该令牌且未过期，则该值应为“true”。</p>
<p><strong>scope</strong><br>一个JSON字符串，以空格分隔,包含与此标记关联的范围列表。</p>
<p><strong>client_id</strong><br>颁发令牌的OAuth 2.0客户端的客户端标识符。</p>
<p><strong>username</strong><br>授权此令牌的用户的可读标识符。</p>
<p><strong>exp</strong><br>unix时间戳（整数时间戳，UTC自1970年1月1日以来的秒数），指示此令牌何时到期。</p>
</blockquote>
<h3 id="示例响应"><a href="#示例响应" class="headerlink" title="示例响应"></a>示例响应</h3><p>下面是自解析endpoint返回的响应示例。</p>
<pre><code class="http">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;active&quot;: true,
  &quot;scope&quot;: &quot;read write email&quot;,
  &quot;client_id&quot;: &quot;J8NFmU4tJVgDxKaJFmXTWvaHO&quot;,
  &quot;username&quot;: &quot;aaronpk&quot;,
  &quot;exp&quot;: 1437275311
}
</code></pre>
<h3 id="错误响应"><a href="#错误响应" class="headerlink" title="错误响应"></a>错误响应</h3><p>如果自解析endpoint可公开访问，则endpoint必须首先验证身份验证。如果身份验证无效，则endpoint应使用<code>HTTP 401</code>状态代码和<code>invalid_client</code>响应进行响应。</p>
<pre><code class="http">HTTP/1.1 401 Unauthorized
Content-Type: application/json; charset=utf-8

{
  &quot;error&quot;: &quot;invalid_client&quot;,
  &quot;error_description&quot;: &quot;The client authentication was invalid&quot;
}
</code></pre>
<p>任何其他错误都被视为“inactive”令牌。</p>
<ul>
<li>请求的令牌不存在或无效</li>
<li>令牌已过期</li>
<li>令牌发送给不同的客户端而不是发出此请求</li>
</ul>
<p>在任何这些情况下，它都不被视为错误响应，并且endpoint仅返回非活动标志。</p>
<pre><code class="http">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;active&quot;: false
}
</code></pre>
<h3 id="安全考虑因素"><a href="#安全考虑因素" class="headerlink" title="安全考虑因素"></a>安全考虑因素</h3><p>使用令牌自解析endpoint意味着,任何资源服务器都将依赖endpoint来确定访问令牌当前是否处于活动状态。这意味着自解析endpoint独自负责决定API请求是否成功。因此，endpoint必须针对令牌的状态执行所有适用的检查，例如检查令牌是否已过期，验证签名等。</p>
<h4 id="令牌钓鱼攻击"><a href="#令牌钓鱼攻击" class="headerlink" title="令牌钓鱼攻击"></a>令牌钓鱼攻击</h4><p>如果自解析endpoint保持打开且不受限制，则它为攻击者提供了一种方法，用于轮询endpoint捕获有效令牌。为防止这种情况发生，服务器必须要求使用endpoint对客户端进行身份验证，或者仅通过其他方式（如防火墙）使endpoint只用于内部服务器。</p>
<p>请注意，资源服务器也是钓鱼攻击的潜在目标，并且应该采取诸如速率限制之类的对策来防止这种情况。</p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>自解析endpoint的使用者可能希望出于性能原因缓存endpoint的响应。因此，在决定缓存时考虑性能和安全性权衡非常重要。例如，较短的缓存到期时间将导致更高的安全性，因为资源服务器将不得不更频繁地查询自解析endpoint，但是这将导致endpoint上的负载增加。较长的到期时间会使一个窗口打开，其中令牌可能实际上已过期或被撤销，但由于缓存时间有剩余，仍然能够在资源服务器上被查到。</p>
<p>缓解问题的一种方法是，使用者永远不会缓存至超出令牌的到期时间，这将在自解析响应的“exp”参数中返回。</p>
<h4 id="限制信息"><a href="#限制信息" class="headerlink" title="限制信息"></a>限制信息</h4><p>自解析endpoint不一定需要为同一令牌的所有查询返回相同的信息。例如，两个不同的资源服务器（如果它们在进行自解析请求时进行身份验证）可能会获得令牌状态的不同视图。这可用于限制有关返回到特定资源服务器的令牌的信息。这使得多个资源服务器在互不知情上可以使用相同的令牌。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--使用PKCE保护移动应用程序]]></title>
      <url>/2018/07/13/oauth-guide-17/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>用于代码交换的证明密钥（PKCE，发音为pixie）扩展描述了一种,公共客户端用于减轻拦截授权代码的威胁的技术。该技术涉及客户端首先创建秘钥，然后在交换访问令牌的授权码时再次使用该秘钥。这样，如果代码被截获，它将不能被使用，因为令牌请求依赖于初始秘钥。</p>
<p>完整规范以<a href="https://tools.ietf.org/html/rfc7636" target="_blank" rel="noopener">RFC7636</a>的形式提供。我们将在下面介绍协议的摘要。</p>
<h3 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h3><p>当原生应用程序开始授权请求时，客户端首先创建所谓的“代码验证程序” ，而不是立即启动浏览器。这是使用随机字符串A-Z，a-z，0-9和标点字符-._~（连字符，期间，下划线和波浪线）来进行加密，长字符43和128之间。</p>
<p>一旦应用程序生成了代码验证程序，它就会使用它来创建代码验证。对于可以执行SHA256哈希的设备，代码验证是代码验证程序的SHA256哈希的BASE64-URL编码字符串。允许无法执行SHA256哈希的客户端使用普通代码验证程序字符串作为验证。</p>
<p>现在客户端有一个代码验证字符串，它包含了一个参数，该参数指示用于生成验证的方法（plain或S256）以及授权请求的标准参数。这意味着完整的授权请求将包括以下参数。</p>
<blockquote>
<p><strong>response_type = code</strong> - 表示您的服务器希望收到授权代码<br><strong>client_id =</strong> - 首次创建应用程序时收到的客户端ID<br><strong>redirect_uri =</strong> - 表示授权完成后返回用户的URL，例如org.example.app://redirect<br><strong>state = 1234zyx</strong> - 应用程序生成的随机字符串，稍后您将验证该字符串<br><strong>code_challenge = XXXXXXXXX</strong> - 如前所述生成的代码验证<br><strong>code_challenge_method = S256</strong> - plain或者S256，取决于验证是普通验证者字符串还是字符串的SHA256哈希。如果省略此参数，则服务器将采用plain。</p>
</blockquote>
<p>授权服务器应识别code_challenge请求中的参数，并将其与其生成的授权码相关联。将其与授权码一起存储在数据库中，或者如果您使用自编码授权码，则可以将其包含在代码本身中。服务器正常返回授权码，并且不包括返回数据中的验证。</p>
<h4 id="错误响应"><a href="#错误响应" class="headerlink" title="错误响应"></a>错误响应</h4><p>授权服务器可以要求公共客户端必须使用PKCE扩展。这实际上是允许公共客户端在不使用客户端密钥的情况下拥有安全授权流的唯一方法。由于对应于公共客户端，授权服务器应该知道特定客户端ID，因此它可以拒绝对不包含代码验证的公共客户端的授权请求。</p>
<p>如果授权服务器要求公共客户端使用PKCE，并且授权请求缺少代码验证，则服务器应返回错误响应，<code>error=invalid_request</code>并且应该使用<code>error_description</code>或者<code>error_uri</code>解释错误的性质。</p>
<h3 id="授权码交换"><a href="#授权码交换" class="headerlink" title="授权码交换"></a>授权码交换</h3><p>本机应用程序将用授权码交换访问令牌。除了授权码请求中定义的参数之外，客户端还将发送<code>code_verifier</code>参数。完整的访问令牌请求将包括以下参数：</p>
<blockquote>
<p><strong>grant_type = authorization_code</strong> - 表示此令牌请求的授权类型<br><strong>code</strong> - 客户端将发送它在重定向中获得的授权代码<br><strong>redirect_uri</strong> - 初始授权请求中使用的重定向URL<br><strong>client_id</strong> - 应用程序注册的客户端ID<br><strong>code_verifier</strong> - 应用程序最初在授权请求之前生成的PKCE请求的代码验证程序。</p>
</blockquote>
<p>除了验证标准参数之外，授权服务器还将验证<code>code_verifier</code>请求中的内容。由于<code>code_challenge</code>和<code>code_challenge_method</code>用授权码相关联，因此服务器应该已经知道使用哪种方法（普通或SHA256）验证<code>code_verifier</code>。</p>
<p>如果方法是plain，那么授权服务器只需要检查提供的<code>code_verifier</code>是否与预期的<code>code_challenge</code>字符串匹配。</p>
<p>如果方法是S256，那么授权服务器应该使用提供的<code>code_verifier</code>, 并使用客户端最初使用的相同方法对其进行转换。这意味着计算其SHA256哈希值并对其进行base64-url编码，然后将其与存储的<code>code_challenge</code>字符串进行比较。</p>
<p>如果验证程序与期望值匹配，则服务器可以正常继续，发出访问令牌并进行适当响应。如果出现问题，则服务器会响应<code>invalid_grant</code>错误。</p>
<p>PKCE扩展不会添加任何新响应，因此即使授权服务器不支持，客户端也可以始终使用PKCE扩展。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--无浏览器和输入约束设备的OAuth]]></title>
      <url>/2018/07/13/oauth-guide-16/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>OAuth 2.0“设备流”扩展程序可在具有Internet连接但没有浏览器或简单方法输入文本的设备上启用OAuth。如果您曾在Apple TV等设备上登录过自己的YouTube帐户，那么您已经遇到过此工作流程。谷歌参与了这个扩展的开发，并且也是它在生产中的早期实现者。</p>
<p>此流程也可在智能电视，媒体控制台，相框，打印机或硬件视频编码器等设备上看到。在该流程中，设备指示用户在诸如智能电话或计算机的辅助设备上打开URL以完成授权。用户的两个设备之间不需要通信通道。</p>
<h3 id="用户流程"><a href="#用户流程" class="headerlink" title="用户流程"></a>用户流程</h3><p>当您开始登录设备（例如此硬件视频编码器）时，设备会与Google通话以获取设备代码，如下所示。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fto9emscc3j30sg07nwf7.jpg" alt="设备发出API请求以获取设备代码"></p>
<p>接下来，我们看到设备会显示代码以及URL。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fto9f6gvy7j30sg07nt9h.jpg" alt="设备显示设备代码和URL"></p>
<p>登录Google帐户后访问该网址会显示一个界面，提示您输入设备上显示的代码。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fto9frx7oxj30me0jdgm9.jpg" alt="Google会提示用户输入代码"></p>
<p>输入代码并单击“下一步”后，您将看到标准OAuth授权提示，该提示描述了应用程序请求的范围，如下所示。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fto9g4x5oxj30ok0dhaay.jpg" alt="Google会显示应用程序请求的范围"></p>
<p>一旦您允许该请求，Google就会显示一条消息，说明要返回您的设备，如下所示。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fto9gir6bij30lp0izmxt.jpg" alt="Google会指示用户返回设备"></p>
<p>几秒钟后，设备完成并且您已登录。</p>
<p>总的来说，这是一次非常轻松的体验。由于您可以使用任何想要打开URL的设备，因此可以使用您可能已登录的授权服务器的主计算机或电话。这也使您在设备上无需输入数据！</p>
<p>让我们逐步了解设备所需的功能。</p>
<h3 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h3><p>首先，客户端向授权服务器发出请求以请求设备代码的请求。</p>
<pre><code class="http">POST /token HTTP/1.1
Host: authorization-server.com
Content-type: application/x-www-form-urlencoded

client_id=a17c21ed
</code></pre>
<p>请注意，某些授权服务器将允许设备在此请求中指定范围，稍后将在授权界面上向用户显示该范围。</p>
<p>授权服务器使用JSON进行响应，该json包含设备代码，用户将输入的代码，用户应访问的URL以及轮询间隔。</p>
<pre><code class="json">HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
{
    &quot;device_code&quot;: &quot;NGU5OWFiNjQ5YmQwNGY3YTdmZTEyNzQ3YzQ1YSA&quot;,
    &quot;user_code&quot;: &quot;BDWP-HQPK&quot;,
    &quot;verification_uri&quot;: &quot;https://authorization-server.com/device&quot;,
    &quot;interval&quot;: 5,
    &quot;expires_in&quot;: 1800
}
</code></pre>
<p>设备在其显示屏上向用户显示<code>verification_uri</code>和<code>user_code</code>，指示用户输入该URL处的代码。</p>
<h3 id="令牌请求"><a href="#令牌请求" class="headerlink" title="令牌请求"></a>令牌请求</h3><p>当设备等待用户在他们自己的计算机或电话上完成授权流程时，设备同时开始轮询令牌端点以请求访问令牌。</p>
<p>设备以<code>device_code</code>指定的速率发出POST请求轮询。设备应继续请求访问令牌，直到<code>authorization_pending</code>返回，显示用户授予或拒绝请求或设备代码到期。</p>
<pre><code class="http">POST /token HTTP/1.1
Host: authorization-server.com
Content-type: application/x-www-form-urlencoded

grant_type=urn:ietf:params:oauth:grant-type:device_code&amp;amp;
client_id=a17c21ed&amp;amp;
device_code=NGU5OWFiNjQ5YmQwNGY3YTdmZTEyNzQ3YzQ1YSA
</code></pre>
<p>授权服务器将回复错误或访问令牌。设备流程规范定义了两个额外的错误代码，这超越了OAuth 2.0用户核心定义，即<code>authorization_pending</code>和<code>slow_down</code>。</p>
<p>如果设备过于频繁地轮询，授权服务器将返回<code>slow_down</code>错误。</p>
<pre><code class="http">HTTP/1.1 400 Bad Request
Content-Type: application/json
Cache-Control: no-store

{
  &quot;error&quot;: &quot;slow_down&quot;
}
</code></pre>
<p>如果用户尚未允许或拒绝该请求，则授权服务器将返回<code>authorization_pending</code>错误。</p>
<pre><code class="http">HTTP/1.1 400 Bad Request
Content-Type: application/json
Cache-Control: no-store

{
  &quot;error&quot;: &quot;authorization_pending&quot;
}
</code></pre>
<p>如果用户拒绝请求，授权服务器将返回<code>access_denied</code>错误。</p>
<pre><code class="http">HTTP/1.1 400 Bad Request
Content-Type: application/json
Cache-Control: no-store

{
  &quot;error&quot;: &quot;access_denied&quot;
}
</code></pre>
<p>如果设备代码已过期，授权服务器将返回<code>expired_token</code>错误。设备可以立即请求新的设备代码。</p>
<pre><code class="http">HTTP/1.1 400 Bad Request
Content-Type: application/json
Cache-Control: no-store

{
  &quot;error&quot;: &quot;expired_token&quot;
}
</code></pre>
<p>最后，如果用户允许请求，则授权服务器像正常一样发出访问令牌并返回标准访问令牌响应。</p>
<pre><code class="json">HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store

{
  &quot;access_token&quot;: &quot;AYjcyMzY3ZDhiNmJkNTY&quot;,
  &quot;refresh_token&quot;: &quot;RjY2NjM5NzA2OWJjuE7c&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;expires&quot;: 3600
}
</code></pre>
<h3 id="授权服务器要求"><a href="#授权服务器要求" class="headerlink" title="授权服务器要求"></a>授权服务器要求</h3><p>支持设备流并不是授权服务器的大量额外工作。在向现有授权服务器添加对设备流的支持时，请记住以下几点。</p>
<h4 id="设备代码请求"><a href="#设备代码请求" class="headerlink" title="设备代码请求"></a>设备代码请求</h4><p>设备将向授权服务器发出请求以获取该流程所需的验证码集合。以下参数是请求的一部分。</p>
<blockquote>
<p><strong>client_id</strong> - 必需，客户端注册中描述的客户端标识符。<br><strong>scope</strong> - 可选，范围中描述的请求范围。</p>
</blockquote>
<p>验证客户端ID和范围后，授权服务器返回带有验证码的URL，设备代码和用户代码的响应。除了上面给出的示例之外，授权服务器还可以返回一些可选参数。</p>
<blockquote>
<p><strong>device_code</strong> - 必需，授权服务器生成的验证码。<br><strong>user_code</strong> - 必需的，用户将在设备屏幕上输入的代码应该相对较短。通常使用6-8个数字和字母。<br><strong>verification_uri</strong> - 必需，用户应访问的授权服务器上的URL以开始授权。用户需要在他们的计算机或移动电话上手动输入此URL。<br><strong>expires_in</strong> - 可选，设备代码和用户代码的生命周期（以秒为单位）。<br><strong>interval</strong> - 可选，客户端轮询令牌端点的请求之间应等待的最短时间（以秒为单位）。</p>
</blockquote>
<h4 id="用户代码（user-code）"><a href="#用户代码（user-code）" class="headerlink" title="用户代码（user code）"></a>用户代码（user code）</h4><p>在许多情况下，用户的设备将是他们的移动电话。通常，这些界面比完整的计算机键盘更受限制，例如iPhone需要额外的选项来切换到数字输入。为了帮助减少数据输入错误并加快代码输入，用户代码的字符集应考虑到这些限制，例如仅使用大写字母。</p>
<p>用于设备代码的合理字符集是不区分大小写的AZ字符的，而且没有元音，以避免意外拼写单词。最好使用base-20字符集BCDFGHJKLMNPQRSTVWXZ。比较输入的代码时，最好忽略字符集中没有的任何字符，如标点符号。例如用户码为BDWP-HQPK，授权服务器应该不区分大小写忽略标点符号来比较输入的字符串，所以应该允许以下匹配：bdwphqpk。</p>
<h4 id="验证网址"><a href="#验证网址" class="headerlink" title="验证网址"></a>验证网址</h4><p>设备将显示的验证URL应尽可能短，并且易于记忆。它将显示在可能非常小的屏幕上，用户必须在他们的计算机或手机上手动输入。</p>
<p>请注意，服务器应返回包含URL方案的完整URL，但某些设备可能会在显示URL时选择对其进行修剪。因此，服务器应配置为将http重定向到https，并在普通域和www前缀上提供服务，以防用户输入错误或设备省略该部分URL。</p>
<p>Google的授权服务器是一个很容易输入的短网址的很好的例子。代码请求的响应是<code>https://www.google.com/device</code>, 但所有显示<code>google.com/device</code>的设备，Google都会相应地重定向。</p>
<h4 id="非文本接口的优化"><a href="#非文本接口的优化" class="headerlink" title="非文本接口的优化"></a>非文本接口的优化</h4><p>没有显示或具有非文本显示的客户端显然无法向用户显示URL。因此，可以使用一些其他方法将验证URL和用户代码传达给用户。</p>
<p>该设备可能能够通过NFC或蓝牙或甚至通过显示QR码来广播验证URL。在这些情况下，设备可以使用参数将用户代码包括为验证URL的一部分。例如：<br><code>https://authorization-server.com/device?user_code=BDWP-HQPK</code><br>这样，当用户启动URL时，可以在验证界面中预填充用户代码。建议授权服务器仍然要求用户确认代码而不是自动进行。</p>
<p>如果设备能够显示代码，即使它无法显示URL，也可以通过提示用户确认验证界面上的代码与其设备上显示的代码相匹配来获得额外的安全性。如果这不是一个必需项，那么授权服务器至少可以要求用户确认他们刚刚请求授权的设备。</p>
<h3 id="安全考虑因素"><a href="#安全考虑因素" class="headerlink" title="安全考虑因素"></a>安全考虑因素</h3><h4 id="用户代码暴力攻击"><a href="#用户代码暴力攻击" class="headerlink" title="用户代码暴力攻击"></a>用户代码暴力攻击</h4><p>由于用户有可能手动将用户代码输入到尚未了解的等待授权设备的界面中，因此应采取预防措施以避免对用户代码进行暴力攻击的可能性。</p>
<p>通常使用具有比授权码所使用的熵少得多的短代码，以便容易地手动输入。因此，建议授权服务器对用于验证用户代码的端点进行速率限制。</p>
<p>速率限制应基于用户代码的熵，以使暴力攻击变得不可行。例如，在上述20个字符集中有8个字符，它提供大约34位的熵。在选择可接受的速率限制时，您可以使用此公式计算熵的位数。log2(208) = 34.57</p>
<h4 id="远程网络钓鱼"><a href="#远程网络钓鱼" class="headerlink" title="远程网络钓鱼"></a>远程网络钓鱼</h4><p>设备流程可能在攻击者拥有的设备上启动，以欺骗用户授权攻击者的设备。例如，攻击者可能发送短信指示用户访问URL并输入用户代码。</p>
<p>为了降低此风险，除了用户界面中描述的授权界面中包含的标准信息之外，建议授权界面要让用户非常清楚他们正在授权物理设备访问其帐户。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--原生应用的OAuth]]></title>
      <url>/2018/07/13/oauth-guide-15/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>本章介绍了在为原生应用程序支持OAuth时要记住的一些特殊注意事项。与基于浏览器的应用程序一样，原生应用程序无法在开发人员注册后保留客户端密钥，因为这需要开发人员在其应用程序的二进制版本中保存秘钥。目前已经证明，通过反编译提取秘钥是相对容易。因此，原生应用必须使用不需要秘钥的OAuth流程。</p>
<p>当前的行业最佳实践是在省略客户端密钥的同时使用授权流程，并使用外部用户代理来完成流程。外部用户代理通常是设备的原生浏览器（具有与原生应用程序不同的安全域），因此应用程序无法访问cookie存储或检查或修改浏览器内的页面内容。由于应用程序无法访问此情况下使用内部浏览器，因此这为设备提供了在授权不同应用程序时让用户保持登录的机会，这样他们无需在每次授权新应用程序时输入密码。</p>
<p>近年来，像iOS这样的平台一直在努力通过提供可以从应用程序内部启动的原生用户代理来进一步改善原生应用程序的OAuth用户体验，同时仍然与启动它的应用程序隔离。结果是用户不再需要离开应用程序以启动共享系统cookie的原生浏览器。这在iOS上称为SFSafariViewController。</p>
<p>针对原生应用程序的这些建议被发布为<a href="https://tools.ietf.org/html/rfc8252" target="_blank" rel="noopener">RFC 8252</a>，这其中更详细地描述了这些概念。</p>
<h3 id="使用系统浏览器"><a href="#使用系统浏览器" class="headerlink" title="使用系统浏览器"></a>使用系统浏览器</h3><p>截至撰写本文时，许多原生应用程序仍然在应用程序内部的Web视图中嵌入OAuth界面。此方法存在多个问题，包括客户端应用程序可能会在登录时窃听用户输入其凭据，甚至提供虚假授权页面。以操作系统级别安全性的实现方式是嵌入式Web视图不与系统的原生浏览器共享cookie，因此用户的体验更糟糕，因为他们每次都需要输入密码。</p>
<p>完成授权流程的更安全和可信的方法是启动系统浏览器。然而，直到最近，这还有一个缺点，即应用程序弹出并启动浏览器，然后重定向回应用程序，这也不是一个理想的用户体验。</p>
<p>值得庆幸的是，移动平台一直在解决这个问题。在iOS 9和10中，开发人员现在可以使用SFSafariViewControllerAPI启动从应用程序内共享系统cookie的系统浏览器。这是通过API实现的，不允许客户端应用程序窥视浏览器，从而获得使用外部浏览器的安全优势以及用户在整个过程中保留在应用程序中的优秀用户体验。</p>
<p>强烈建议为iOS编写应用程序的原生应用程序开发人员使用SFSafariViewControllerAPI，如果API不可用，则启动外部Safari窗口（例如，如果应用程序需要支持iOS 8及更低版本）。</p>
<p>授权服务器应通过尝试检测授权URL是否在嵌入式Web视图中启动来强制执行此行为，如果是，则拒绝该请求。用于检测页面是否在嵌入式Web视图中与系统浏览器进行访问的特定技术将取决于平台，但通常涉及检查用户代理haeder。</p>
<h3 id="重定向原生应用程序的URL"><a href="#重定向原生应用程序的URL" class="headerlink" title="重定向原生应用程序的URL"></a>重定向原生应用程序的URL</h3><p>为了支持各种类型的原生应用程序，您的服务器需要支持注册三种类型的重定向URL，每种URL都支持稍微不同的用例。</p>
<h4 id="自定义URL方案"><a href="#自定义URL方案" class="headerlink" title="自定义URL方案"></a>自定义URL方案</h4><p>某些平台（如iOS）允许应用程序注册自定义URL方案，只要在浏览器或其他应用程序中打开具有该方案的URL，该方案就会启动应用程序。支持具有自定义URL方案的重定向URL允许客户端启动外部浏览器以完成授权流程，然后在授权完成后重定向回应用程序。</p>
<p>应用程序开发人员应该选择全局唯一的URL方案，以及他们可以断言控制权的URL方案。由于操作系统通常没有关于特定应用程序是否已声明这种URL方案的注册的汇总，因此理论上两种应用程序可以独立地选择相同的方案，例如<code>myapp://</code>。如果您希望帮助防止应用程序开发人员使用自定义方案时发生冲突，您应该建议（甚至强制执行）他们使用的方案是他们的反向域名模式。至少，您可以要求重定向URL至少包含一个<code>.</code>以免与其他系统方案（如mailto或ftp）冲突。</p>
<p>例如，如果某个应用程序有一个相应的网站<code>photoprintr.example.org</code>，则可以使用反向域名作为其URL方案<code>org.example.photoprintr</code>。然后开发人员将注册<code>org.example.photoprintr://</code>开头的重定向URL。通过强制执行此操作，您可以帮助鼓励开发人员选择不会与其他已安装的应用程序冲突的显式URL方案。</p>
<p>使用自定义URL方案的应用程序将正常启动授权请求，如授权请求中所述，但将提供具有其自定义URL方案的重定向URL。授权服务器仍应验证此URL是否已注册为允许的重定向URL，并且可将其视为Web应用程序注册的重定向URL一样的URL。</p>
<p>当授权服务器使用自定义方案将原生应用程序重定向到URL时，操作系统将启动应用程序并使原始应用程序可以访问整个重定向URL。该应用可以像常规OAuth 2.0客户端一样提取授权代码。</p>
<h4 id="HTTPS-URL匹配"><a href="#HTTPS-URL匹配" class="headerlink" title="HTTPS URL匹配"></a>HTTPS URL匹配</h4><p>某些平台允许应用程序注册URL模式，当系统浏览器访问的URL与注册模式的URL匹配时，应启动应用程序。这通常被应用程序用于“深层链接”到原生应用程序，例如在浏览器中查看Yelp URL时打开到Yelp应用程序的餐厅页面。</p>
<p>应用程序也可以使用此技术向URL注册一个模式，该模式将在授权服务器重定向回应用程序时启动应用程序。如果平台提供此功能，则这是原生应用程序的推荐选择，因为这提供了应用程序属于其匹配的URL的最大完整性。在平台不支持应用程序声明URL的情况下，这也提供了合理的后备选择。</p>
<h4 id="loopback-URL"><a href="#loopback-URL" class="headerlink" title="loopback URL"></a>loopback URL</h4><p>原生应用程序可用于支持无缝重定向的另一种技术是在loopback接口的随机端口上打开新的HTTP服务器。这通常仅在桌面操作系统上完成，因为移动操作系统通常不向应用开发者提供此功能。</p>
<p>这种方法适用于命令行应用程序以及桌面GUI应用程序。该应用程序将启动HTTP服务器，然后开始授权请求，将重定向URL设置为loopback地址，例如<code>http://127.0.0.1:49152/redirect</code>启动浏览器。当授权服务器将浏览器重定向回loopback地址时，应用程序可以从请求中获取授权代码。</p>
<p>为了支承实这种使用情况，授权服务器必须支持注册重定向URL以<code>http://127.0.0.1:[port]/</code>或<code>http://::1:[port]/</code>或<code>http://localhost:[port]/</code>开始。授权服务器应允许任意路径组件以及任意端口号。请注意，在这种情况下，可以使用HTTP方案而不是HTTPS，因为请求永远不会离开设备。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>与服务器端应用程序一样，原生应用程序还必须使用授权服务器注册其重定向URL。这意味着除了服务器端应用程序的传统HTTPS URL之外，授权服务器还需要允许注册与上述所有模式匹配的重定向URL。</p>
<p>在授权服务器上启动授权请求时，服务器将验证所有请求参数，包括给定的重定向URL。授权应拒绝请求中无法识别的URL，以帮助避免授权代码拦截攻击。</p>
<h3 id="PKCE扩展"><a href="#PKCE扩展" class="headerlink" title="PKCE扩展"></a>PKCE扩展</h3><p>由于原生平台上的重定向URL的强制执行能力是有限的，因此还有另一种获得额外安全性的技术，称为代码交换的证明秘钥，或简称PKCE。</p>
<p>此技术涉及原生应用程序创建初始随机密钥，并在交换访问令牌的授权代码时再次使用该秘密。这样，如果另一个应用程序截获授权代码，则在没有原始秘钥的情况下它将无法使用。</p>
<h3 id="本地应用程序的服务器支持清单"><a href="#本地应用程序的服务器支持清单" class="headerlink" title="本地应用程序的服务器支持清单"></a>本地应用程序的服务器支持清单</h3><p>要总结本章，您的授权服务器应支持以下内容，以便完全支持原生应用程序的安全授权。</p>
<ul>
<li>允许客户为其重定向URL注册自定义URL方案。</li>
<li>支持loopback IP重定向具有任意端口号的URL，以支持桌面应用程序。</li>
<li>不要假设本机应用程序可以保守秘钥。要求所有应用程序声明它们是公开的还是保密的，并且只向机密应用程序发出客户秘钥。</li>
<li>支持PKCE扩展，并要求公共客户端使用它。</li>
<li>尝试检测并拒绝授权界面嵌入原生应用程序的Web视图的请求，要求其在系统浏览器中启动请求。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--资源服务器]]></title>
      <url>/2018/07/13/oauth-guide-14/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>资源服务器是API服务器的OAuth 2.0术语。资源服务器在应用程序获取访问令牌后处理经过身份验证的请求。</p>
<p>大规模部署可能有多个资源服务器。例如，Google的服务拥有数十种资源服务器，例如Google云平台，Google地图，Google云端硬盘，Youtube，Google +等等。这些资源服务器中的每一个都明显是分开的，但它们都共享相同的授权服务器。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftiyxmx2rrj30ox0dbgoc.jpg" alt="谷歌的一些API"></p>
<p>较小的部署通常只有一个资源服务器，并且通常构建为与授权服务器相同的代码库或相同部署的一部分。</p>
<h3 id="验证访问令牌"><a href="#验证访问令牌" class="headerlink" title="验证访问令牌"></a>验证访问令牌</h3><p>资源服务器将从应用发出的请求中的具有的HTTP Authorization header获取访问令牌。资源服务器需要能够验证访问令牌以确定是否处理请求，并找到关联的用户帐户等。</p>
<p>如果您使用的是自编码访问令牌，则可以在资源服务器中完全验证令牌，而无需与数据库或外部服务器交互。</p>
<p>如果您的令牌存储在数据库中，则验证令牌需要在数据库中查找。</p>
<p>另一种选择是使用令牌自解析规范来构建API以验证访问令牌。这是处理在大量资源服务器上验证访问令牌的好方法，因为这意味着您可以将访问令牌的所有逻辑封装在单个服务器中，通过API将信息暴露给系统的其他部分。令牌自解析endpoint仅供内部使用，因此您需要使用某些内部授权来保护它，或者仅在系统防火墙内的服务器上启用它。</p>
<h3 id="验证范围"><a href="#验证范围" class="headerlink" title="验证范围"></a>验证范围</h3><p>资源服务器需要知道与访问令牌关联的范围列表。如果访问令牌中的作用域不包含执行指定操作所需的作用域，则服务器负责拒绝请求。</p>
<p>OAuth 2.0规范本身没有定义任何范围，也没有范围的注册表。范围列表由服务决定。</p>
<h3 id="错误代码和未经授权的访问"><a href="#错误代码和未经授权的访问" class="headerlink" title="错误代码和未经授权的访问"></a>错误代码和未经授权的访问</h3><p>如果访问令牌不允许访问所请求的资源，或者请求中没有访问令牌，则服务器必须回复HTTP 401响应并在相应header中包含WWW-Authenticate。</p>
<p>最简单的WWW-Authenticate标头包括字符串Bearer，表示需要承载令牌。标题还可以指示附加信息，例如“realm”和“scope”。“realm”值用于传统的<a href="https://tools.ietf.org/html/rfc2617" target="_blank" rel="noopener">HTTP身份验证</a>。“scope”值允许资源服务器指示访问资源所需的作用域列表，因此应用程序可以在启动授权流时请求适当的作用域。响应还应包括适当的“error”值，具体取决于发生的错误类型。</p>
<blockquote>
<p><strong>invalid_request （HTTP 400）</strong> - 请求缺少参数，否则会出现格式错误。<br><strong>invalid_token（HTTP 401）</strong> - 由于其他原因，访问令牌已过期，已撤销，格式错误或无效。客户端可以获取新的访问令牌，然后重试。<br><strong>insufficient_scope （HTTP 403）</strong> - 访问令牌请求范围错误</p>
</blockquote>
<p>例如：</p>
<pre><code class="http">HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm=&quot;example&quot;,
                  scope=&quot;delete&quot;,
                  error=&quot;insufficient_scope&quot;
</code></pre>
<p>如果请求没有身份验证，则不需要错误代码或其他错误信息。</p>
<pre><code class="http">HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm=&quot;example&quot;
</code></pre>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--授权列表与撤销]]></title>
      <url>/2018/07/13/oauth-guide-13/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<h3 id="授权列表"><a href="#授权列表" class="headerlink" title="授权列表"></a>授权列表</h3><p>一旦用户开始授权多个应用程序，让许多应用程序访问其帐户，就有必要提供一种方法来允许用户管理具有访问权限的应用程序。这通常在帐户设置页面或帐户隐私页面中呈现给用户。</p>
<p>OAuth 2.0规范中没有任何内容要求用户能够撤销访问权限，或者对如何执行此操作的建议，因此我们将查看几个主要的API提供商，以获取有关如何实现此目的的灵感。</p>
<p>大多数提供商都有一个页面，其中列出了用户授权其帐户的所有应用程序。通常会显示有关应用程序的一些信息，以及用于向用户提供有关此应用程序何时以及为何具有访问权限的上下文的信息。</p>
<h4 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h4><p>Google会在<code>https://security.google.com/settings/security/permissions</code>上提供您在帐户中授权的应用程序列表。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ftgh6j6yqmj30mm0iiq4r.jpg" alt="google"></p>
<p>该列表显示应用程序图标，名称以及授予应用程序范围的摘要。单击其中一个将展开以显示更多详细信息。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1ftgha78weuj30j40ijq4c.jpg" alt="一个授权访问您的Google帐户的应用程序的详细信息"></p>
<p>此视图提供了已授予范围的更详细列表，以及您授权应用程序的日期。</p>
<h4 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h4><p>Twitter在<code>https://twitter.com/settings/applications</code>上提供了您授权的应用程序列表。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1ftghc5l2bmj30sg0jz79r.jpg" alt="您授权访问Twitter帐户的应用程序列表"></p>
<p>Twitter显示授予的范围（只读，读/写，读/写/直接消息），以及应用程序是否可以看到您的电子邮件地址。该列表包括您授权申请的日期。这使用户可以轻松地从他们暂时未使用的应用程序中撤消凭据。</p>
<h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><p>GitHub在<code>https://github.com/settings/applications</code>上提供了您授权的应用程序列表。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ftghef8w6qj30sg0cu40n.jpg" alt="您授权访问GitHub帐户的应用程序列表"></p>
<p>GitHub提供的列表包括上次使用应用程序的描述，以便您了解是否可以安全地撤销应用程序的授权（如果它在一段时间内没有使用过）。</p>
<p>单击应用程序可提供有关该应用程序访问权限的更多详细信息。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ftghezcvrqj30kw0cmab1.jpg" alt="一个授权访问您的GitHub帐户的应用程序的详细信息"></p>
<p>在这里，您可以看到应用程序对您帐户的权限（范围）。</p>
<p>您可以在此处找到指向其他服务授权页面的<a href="https://indieweb.org/appaccess" target="_blank" rel="noopener">链接</a>。</p>
<h3 id="撤销访问权限"><a href="#撤销访问权限" class="headerlink" title="撤销访问权限"></a>撤销访问权限</h3><p>您可能需要撤销应用程序对用户帐户的访问权限的原因有几个。</p>
<ul>
<li>用户明确希望撤销应用程序的访问权限，例如，如果他们在授权页面上找到了他们不再想要使用的应用程序</li>
<li>开发人员想要撤消其应用程序的所有用户令牌</li>
<li>开发者删除了他们的申请</li>
<li>您作为服务提供商已确定应用程序已被盗用或恶意，并希望禁用它</li>
</ul>
<p>根据您实现生成访问令牌的方式，将用不同的方式撤销他们。</p>
<h4 id="令牌数据库"><a href="#令牌数据库" class="headerlink" title="令牌数据库"></a>令牌数据库</h4><p>如果将访问令牌存储在数据库中，则撤销属于特定用户的所有令牌相对容易。您可以轻松编写查找和删除属于该用户的令牌的查询，例如查找令牌表中的令牌user_id。假设您的资源服务器通过在数据库中查找它们来验证访问令牌，那么下次被撤销的客户端发出请求时，其令牌将无法验证。</p>
<h4 id="自编码令牌"><a href="#自编码令牌" class="headerlink" title="自编码令牌"></a>自编码令牌</h4><p>如果授权服务器发出自编码令牌，则撤销对特定应用程序的访问会稍微困难一些。</p>
<p>如果您有一个真正的无状态机制来验证令牌，并且您有资源服务器正在验证令牌而不与另一个系统共享服务，那么唯一的选择是等待所有未完成的令牌过期，并阻止应用程序生成新令牌。这是当您使用自编码令牌时，使用极短期令牌的主要原因。</p>
<p>由于没有使单个访问令牌无效的机制，因此您需要使特定用户的应用程序刷新令牌无效。这样，下次应用程序尝试刷新访问令牌时，将拒绝对新访问令牌的请求。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--访问令牌]]></title>
      <url>/2018/07/13/oauth-guide-12/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>访问令牌是应用程序用于代表用户发出API请求的内容。访问令牌表示特定应用程序访问用户数据的特定部分的授权。</p>
<p>访问令牌必须在运输和存储过程中保密。应该看到访问令牌的唯一方是应用程序本身，授权服务器和资源服务器。应用程序应确保同一设备上的其他应用程序无法访问访问令牌的存储。访问令牌只能在https连接上使用，因为通过非加密通道传递它会使第三方拦截变得非常容易。</p>
<p>令牌endpoint是应用程序发出请求以获取用户访问令牌的位置。本节介绍如何验证令牌请求以及如何返回相应的响应和错误。</p>
<h3 id="授权码请求"><a href="#授权码请求" class="headerlink" title="授权码请求"></a>授权码请求</h3><p>当应用试图交换访问令牌时，将使用授权码交换授予。用户通过重定向URL返回应用程序后，应用程序将从URL获取授权码并使用它来请求访问令牌。此请求将发送到令牌endpoint。</p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>访问令牌请求将包含以下参数。</p>
<blockquote>
<p><strong>grant_type （需要）</strong><br>grant_type参数必须设置为“authorization_code”。</p>
<p><strong>code （需要）</strong><br>code参数是客户端先前从授权服务器接收的授权码。</p>
<p><strong>redirect_uri （可能需要）</strong><br>如果重定向URI包含在初始授权请求中，则服务也必须在令牌请求中要求它。令牌请求中的重定向URI必须与生成授权代码时使用的重定向URI完全匹配。 否则服务必须拒绝该请求。</p>
<p><strong>client_id （如果不存在其他客户端身份验证，则需要）</strong><br>如果客户端通过HTTP Basic Auth或其他方法进行身份验证，则不需要此参数。否则，此参数是必需的。</p>
</blockquote>
<p>如果客户端发出了客户端密钥，则服务器必须对客户端进行身份验证。验证客户端的一种方法是接受此请求中的另一个参数client_secret。或者，授权服务器可以使用HTTP Basic Auth。从技术上讲，规范允许授权服务器支持任何形式的客户端身份验证，甚至提到公钥/私钥对作为选项。但实际上，大多数服务器都支持使用此处提到的方法之一或两者共同来验证客户端的简单方法。</p>
<h4 id="验证授权码"><a href="#验证授权码" class="headerlink" title="验证授权码"></a>验证授权码</h4><p>在检查所有必需参数并在客户端被发出秘钥时验证客户端之后，授权服务器可以继续验证请求的其他部分。</p>
<p>然后，服务器检查授权码是否有效，并且尚未过期。然后，该服务必须验证请求中提供的授权码是否已发送给所标识的客户端。最后，服务必须确保存的重定向URI参数与用于请求授权代码的重定向URI匹配。</p>
<p>如果所有内容都检出，该服务可以生成访问令牌并进行响应。</p>
<p>例<br>以下示例显示了私密客户端的授权授予请求。</p>
<pre><code class="http">POST /oauth/token HTTP/1.1
Host: authorization-server.com

grant_type=authorization_code
&amp;code=xxxxxxxxxxx
&amp;redirect_uri=https://example-app.com/redirect
&amp;client_id=xxxxxxxxxx
&amp;client_secret=xxxxxxxxxx
</code></pre>
<h4 id="安全考虑因素"><a href="#安全考虑因素" class="headerlink" title="安全考虑因素"></a>安全考虑因素</h4><h5 id="防止重复攻击"><a href="#防止重复攻击" class="headerlink" title="防止重复攻击"></a>防止重复攻击</h5><p>如果多次使用授权码，授权服务器必须拒绝后续请求。授权码存储在数据库中是很容易实现，因为它们可以简单地标记为已使用。</p>
<p>如果要实现自编码授权码（如我们的示例代码中所示），则需要跟踪已在令牌生命周期中使用的令牌。一种方法是通过生命周期之内，将授权码缓存在缓存中来实现此目的（具有过期时间的缓存）。这样在验证时，我们可以通过检查授权码的缓存来检查它们是否已被使用。一旦授权码到达其到期日期，它将不再在缓存中，但我们可以根据到期日期拒绝它。</p>
<p>如果授权码被多次使用，则应将其视为攻击。如果可能，服务应撤销此授权码发出的先前访问令牌。</p>
<h3 id="密码授予"><a href="#密码授予" class="headerlink" title="密码授予"></a>密码授予</h3><p>当应用程序交换用户的访问令牌的用户名和密码时，将使用密码授予。这正是首先要创建的OAuth，因此您绝不允许第三方应用使用此授权。</p>
<p>此授权类型的常见用途是用您的服务为应用启用密码登录。用户使用他们的用户名和密码登录来登录网站或原生应用程序，但绝不允许第三方应用程序直接询问用户的密码。</p>
<h4 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h4><p>访问令牌请求将包含以下参数。</p>
<blockquote>
<p><strong>grant_type（必填）</strong> - grant_type参数必须设置为“password”。<br><strong>username （必填）</strong> - 用户的用户名。<br><strong>password （必填）</strong> - 用户的密码。<br><strong>scope （可选）</strong> - 应用程序请求的范围。<br><strong>客户端身份验证</strong>（如果客户端被授予秘钥，则需要）</p>
</blockquote>
<p>如果客户端被授予秘钥，则必须验证此请求。通常，服务将允许其他请求参数如client_id和client_secret，或接受在HTTP Basic auth header中的客户端ID和秘钥。</p>
<p>例<br>以下是服务将接收的示例密码授予。</p>
<pre><code class="http">POST /oauth/token HTTP/1.1
Host: authorization-server.com

grant_type=password
&amp;username=user@example.com
&amp;password=1234luggage
&amp;client_id=xxxxxxxxxx
&amp;client_secret=xxxxxxxxxx
</code></pre>
<h3 id="客户端凭据"><a href="#客户端凭据" class="headerlink" title="客户端凭据"></a>客户端凭据</h3><p>当应用程序请求访问令牌来访问其自己的资源，而不是代表用户访问他们的资源时，将使用客户端凭据授予。</p>
<h4 id="请求参数-2"><a href="#请求参数-2" class="headerlink" title="请求参数"></a>请求参数</h4><blockquote>
<p><strong>grant_type （需要）</strong><br>grant_type参数必须设置为client_credentials。</p>
<p><strong>scope （可选的）</strong><br>您的服务可以支持客户端凭据授予的不同范围。实际上，实际上并没有多少服务支持这一点。</p>
<p><strong>客户端验证（必填）</strong><br>客户端需要为此请求进行身份验证。通常，服务将接受请求参数client_id和client_secret，或接受在HTTP Basic auth header中的客户端ID和秘钥。</p>
</blockquote>
<p>例<br>以下是客户端凭据的请求例子。</p>
<pre><code class="http">POST /token HTTP/1.1
Host: authorization-server.com

grant_type=client_credentials
&amp;client_id=xxxxxxxxxx
&amp;client_secret=xxxxxxxxxx
</code></pre>
<h3 id="访问令牌响应"><a href="#访问令牌响应" class="headerlink" title="访问令牌响应"></a>访问令牌响应</h3><h4 id="响应成功"><a href="#响应成功" class="headerlink" title="响应成功"></a>响应成功</h4><p>如果访问令牌的请求有效，则授权服务器需要生成访问令牌（和可选的刷新令牌）并将这些令牌返回给客户端，通常还有一些有关授权的其他属性。</p>
<p>具有访问令牌的响应应包含以下属性：</p>
<blockquote>
<p><strong>access_token （必需）</strong> 授权服务器发出的访问令牌字符串。<br><strong>token_type （必需）</strong> 这是令牌的类型，通常只是字符串“bearer”。<br><strong>expires_in （推荐）</strong> 如果访问令牌会过期，服务器应回复授予访问令牌的持续时间。<br><strong>refresh_token（可选）</strong> 如果访问令牌会过期，则应该返回刷新令牌，应用程序可以使用该令牌来获取新的访问令牌。但是，使用隐式授权发出的令牌无法发出刷新令牌。<br><strong>scope（可选）</strong> 如果用户授予的范围与应用程序请求的范围相同，则此参数是可选的。如果授予的范围与请求的范围不同，例如，如果用户修改了范围，则此参数是必需的。</p>
</blockquote>
<p>使用访问令牌进行响应时，服务器还必须包含附加<code>Cache-Control: no-store</code>和<code>Pragma: no-cache</code>的HTTP header，以确保客户端不会缓存此请求。</p>
<p>例如，成功的令牌响应可能如下所示：</p>
<pre><code class="json">HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
  &quot;access_token&quot;:&quot;MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3&quot;,
  &quot;token_type&quot;:&quot;bearer&quot;,
  &quot;expires_in&quot;:3600,
  &quot;refresh_token&quot;:&quot;IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk&quot;,
  &quot;scope&quot;:&quot;create&quot;
}
</code></pre>
<p>####访问令牌</p>
<p>OAuth 2.0 Bearer Token的格式实际上是在单独的规范<a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">RFC 6750</a>中描述的。规范要求的令牌没有已定义的结构，因此您可以生成任意字符串并实现所需的令牌。令牌中的有效字符是字母数字，和标点字符：-._~+/</p>
<p>通常，服务将生成随机字符串并将其与相关的用户和范围信息一起存储在数据库中，或者将使用自编码令牌，其中令牌字符串本身包含所有必要的信息。</p>
<h4 id="响应失败"><a href="#响应失败" class="headerlink" title="响应失败"></a>响应失败</h4><p>如果访问令牌请求无效，例如重定向URL与授权期间使用的URL不匹配，则服务器需要返回错误响应。</p>
<p>使用HTTP 400状态代码（除非另有说明）返回错误响应，带有<code>error</code>和<code>error_description</code>参数。该<code>error</code>参数将始终是下面列出的值之一。</p>
<blockquote>
<p><strong>invalid_request</strong> - 请求缺少参数，因此服务器无法继续执行请求。如果请求包含不受支持的参数或重复参数，也可能会返回此信息。<br><strong>invalid_client</strong> - 客户端身份验证失败，例如请求包含无效的客户端ID或秘钥。在这种情况下发送HTTP 401响应。<br><strong>invalid_grant</strong> - 授权码（或密码授予类型的用户密码）无效或已过期。或者授权中给出的重定向URL与此访问令牌请求中提供的URL不匹配，也将返回这个的错误。<br><strong>invalid_scope</strong> - 对于包含范围（密码或client_credentials授权）的访问令牌请求，此错误表示请求中的范围值无效。<br><strong>unauthorized_client</strong> - 此客户端无权使用请求的授权类型。例如，如果限制哪些应用程序可以使用隐式授权，则会为其他应用程序返回此错误。<br><strong>unsupported_grant_type</strong> - 如果请求授权服务器无法识别的授权类型，请使用此代码。请注意，未知的授权类型也使用此特定错误代码而不是使用invalid_request。</p>
</blockquote>
<p>返回错误响应时有两个可选参数，<code>error_description</code>和<code>error_uri</code>。这些旨在为开发人员提供有关错误的更多信息，而不是向最终用户显示。但是，请记住，无论您多么警告，许多开发人员都会将此错误文本直接传递给最终用户，因此最好确保它对最终用户至少有所帮助。</p>
<p>该<code>error_description</code>参数只能包含ASCII字符，最多应该是一两句话来描述错误的情况。这<code>error_uri</code>是链接到API文档的好地方，可以获取有关如何更正遇到的特定错误的信息。</p>
<p>整个错误响应作为JSON字符串返回，类似于成功响应。以下是错误响应的示例。</p>
<pre><code class="json">HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  &quot;error&quot;: &quot;invalid_request&quot;,
  &quot;error_description&quot;: &quot;Request was missing the &#39;redirect_uri&#39; parameter.&quot;,
  &quot;error_uri&quot;: &quot;See the full API docs at https://authorization-server.com/docs/access_token&quot;
}
</code></pre>
<h3 id="自编码访问令牌"><a href="#自编码访问令牌" class="headerlink" title="自编码访问令牌"></a>自编码访问令牌</h3><p>自编码令牌提供了一种通过编码令牌字符串中的所有必要信息来避免在数据库中存储令牌的方法。这样做的主要好处是API服务器能够在不对每个API请求进行数据库查找的情况下验证访问令牌，从而使API更容易扩展。</p>
<p>OAuth 2.0 Bearer Tokens的好处是应用程序无需了解服务中如何实现访问令牌。这意味着可以在不影响客户端的情况下更改令牌的实现规则。</p>
<p>如果您已经拥有可水平扩展的分布式数据库系统，那么使用自编码令牌可能无法获得任何好处。实际上，如果已经解决了分布式数据库问题，使用自编码令牌只会引入新问题，因为使自编码令牌失效会成为额外的障碍。</p>
<p>有许多方法可以自编码令牌。您选择的实际方法仅对您的实现很重要，因为令牌信息不会暴露给外部开发人员。</p>
<p>创建自编码标记的一种方法是创建序列化的json串来包含在token中的所有数据，并使用仅为您的服务器知道的密钥对结果字符串进行签名。</p>
<p>一种常见的技术是使用<a href="https://tools.ietf.org/html/rfc7515" target="_blank" rel="noopener">JSON Web Signature（JWS）</a>标准来处理令牌的编码，解码和验证。 <a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">JSON Web Token (JWT)</a>规范定义了一些字段，你可以在JWS中使用，或定义一些时间戳字段来确定令牌是否有效。我们将在此示例中使用JWT库，因为它提供了时间到期的内置处理。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>下面的代码是用PHP编写的，使用Firebase PHP-JWT库来编码和验证令牌。您需要包含该库才能运行示例代码</p>
<pre><code class="php">&lt;?php
use \Firebase\JWT\JWT;

# Define the secret key used to create and verify the signature
$jwt_key = &#39;secret&#39;;

# Set the user ID of the user this token is for
$user_id = 1000;

# Set the client ID of the app that is generating this token
$client_id = &#39;https://example-app.com&#39;;

# Provide the list of scopes this token is valid for
$scope = &#39;read write&#39;;

$token_data = array(

  # Subject (The user ID)
  &#39;sub&#39; =&gt; $user_id,

  # Issuer (the token endpoint)
  &#39;iss&#39; =&gt; &#39;https://&#39; . $_SERVER[&#39;PHP_SELF&#39;],

  # Client ID (this is a non-standard claim)
  &#39;cid&#39; =&gt; $client_id,

  # Issued At
  &#39;iat&#39; =&gt; time(),

  # Expires At
  &#39;exp&#39; =&gt; time()+7200, // Valid for 2 hours

  # The list of OAuth scopes this token includes
  &#39;scope&#39; =&gt; $scope
);
$token_string = JWT::encode($token_data, $jwt_key);
</code></pre>
<p>这将产生一个字符串，如：</p>
<pre><code class="jwt">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjEwMDAsI
mlzcyI6Imh0dHBzOi8vYXV0aG9yaXphdGlvbi1zZXJ2ZXIuY29tIiw
iY2lkIjoiaHR0cHM6Ly9leGFtcGxlLWFwcC5jb20iLCJpYXQiOjE0N
zAwMDI3MDMsImV4cCI6MTUyOTE3NDg1MSwic2NvcGUiOiJyZWFkIHd
yaXRlIn0.QiIrnmaC4VrbAYAsu0YPeuJ992p20fSxrXWPLw-gkFA
</code></pre>
<p>此令牌由三部分组成，以句点分隔。第一部分描述了使用的签名方法。第二部分包含令牌数据。第三部分是签名。</p>
<p>例如，此令牌的第一个部分是JSON对象：</p>
<pre><code class="json">{
   &quot;typ&quot;:&quot;JWT&quot;,
   &quot;alg&quot;:&quot;HS256”
}
</code></pre>
<p>第二个部分包含API端点处理请求所需的实际数据，例如用户标识和范围访问。</p>
<pre><code class="json">{
  &quot;sub&quot;: 1000,
  &quot;iss&quot;: &quot;https://authorization-server.com&quot;,
  &quot;cid&quot;: &quot;https://example-app.com&quot;,
  &quot;iat&quot;: 1470002703,
  &quot;exp&quot;: 1470009903,
  &quot;scope&quot;: &quot;read write&quot;
}
</code></pre>
<p>Base64编码前两个部分产生以下两个字符串：</p>
<pre><code class="jwt">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
</code></pre>
<pre><code class="jwt">eyJzdWIiOjEwMDAsImlzcyI6Imh0dHBzOi8vYXV0aG9yaXphdGlvbi1z
ZXJ2ZXIuY29tIiwiY2lkIjoiaHR0cHM6Ly9leGFtcGxlLWFwcC5jb20i
LCJpYXQiOjE0NzAwMDI3MDMsImV4cCI6MTUyOTE3NDg1MSwic2NvcGUi
OiJyZWFkIHdyaXRlIn0
</code></pre>
<p>然后我们计算两个字符串和秘钥的散列，从而产生另一个字符串：</p>
<pre><code class="jwt">QiIrnmaC4VrbAYAsu0YPeuJ992p20fSxrXWPLw-gkFA
</code></pre>
<p>最后，将所有三个字符串连接在一起，用句点分隔。</p>
<pre><code class="jwt">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjEwMDAsI
mlzcyI6Imh0dHBzOi8vYXV0aG9yaXphdGlvbi1zZXJ2ZXIuY29tIiw
iY2lkIjoiaHR0cHM6Ly9leGFtcGxlLWFwcC5jb20iLCJpYXQiOjE0N
zAwMDI3MDMsImV4cCI6MTUyOTE3NDg1MSwic2NvcGUiOiJyZWFkIHd
yaXRlIn0.QiIrnmaC4VrbAYAsu0YPeuJ992p20fSxrXWPLw-gkFA
</code></pre>
<h4 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h4><p>可以使用相同的JWT库来验证访问令牌。库将同时解码和验证签名，如果签名无效，或者令牌的过期日期已经过去，则会抛出异常。</p>
<p>注意：任何人都可以通过base64解码令牌信息来解码令牌字符串的中间部分。因此，您不要存储您不希望用户或开发人员在令牌中看到的私人信息或信息，这一点很重要。如果要隐藏令牌信息，可以使用JSON Web加密规范加密令牌中的数据。</p>
<pre><code class="php">try {
  # Note: You must provide the list of supported algorithms in order to prevent 
  # an attacker from bypassing the signature verification. See:
  # https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/
  $token = JWT::decode($token_string, $jwt_key, [&#39;HS256&#39;]);
  $error = false;
} catch(\Firebase\JWT\ExpiredException $e) {
  $token = false;
  $error = &#39;expired&#39;;
  $error_description = &#39;The token has expired&#39;;
} catch(\Firebase\JWT\SignatureInvalidException $e) {
  $token = false;
  $error = &#39;invalid&#39;;
  $error_description = &#39;The token provided was malformed&#39;;
} catch(Exception $e) {
  $token = false;
  $error = &#39;unauthorized&#39;;
  $error_description = $e-&gt;getMessage();
}

if($error) {
  header(&#39;HTTP/1.1 401 Unauthorized&#39;);
  echo json_encode(array(
    &#39;error&#39;=&gt;$error, 
    &#39;error_description&#39;=&gt;$error_description
  ));
  die();
} else {
  // Now $token has all the data that we encoded in it originally
  print_r($token);
}
</code></pre>
<p>此时，该服务具有所需的所有信息，例如可用的用户ID，范围等，并且不必进行数据库查找。接下来，它可以检查以确保访问令牌未过期，可以验证范围是否足以执行所请求的操作，然后可以处理该请求。</p>
<p>因为可以在不进行数据库查找的情况下验证令牌，所以在令牌过期之前无法使令牌无效。您需要采取其他步骤来使自编码的令牌无效。</p>
<h3 id="访问令牌生命周期"><a href="#访问令牌生命周期" class="headerlink" title="访问令牌生命周期"></a>访问令牌生命周期</h3><p>当您的服务发出访问令牌时，您需要做出一些关于您希望令牌持续多久的决定。不幸的是，每项服务都没有全面的解决方案。不同的选项会有各种权衡，因此您应该选择最适合您应用需求的选项（或选项组合）。</p>
<h4 id="短期访问令牌和长期刷新令牌"><a href="#短期访问令牌和长期刷新令牌" class="headerlink" title="短期访问令牌和长期刷新令牌"></a>短期访问令牌和长期刷新令牌</h4><p>授予令牌的常用方法是使用访问令牌和刷新令牌的组合，以获得最大的安全性和灵活性。OAuth 2.0规范建议使用此选项，并且一些实现已采用此方法。</p>
<p>通常，使用此方法的服务将发出持续时间从几小时到几周的访问令牌。当服务发出访问令牌时，它还会生成一个永不过期的刷新令牌，并在响应中返回该令牌。（请注意，无法使用隐式授权发布刷新令牌。）</p>
<p>当访问令牌到期时，应用程序可以使用刷新令牌来获取新的访问令牌。它可以在幕后进行，无需用户参与，因此对用户来说是一个无缝的过程。</p>
<p>这种方法的主要好处是该服务可以使用自编码访问令牌，无需数据库查找即可对其进行验证。但是，这意味着没有办法直接使这些令牌过期，因此，令牌的发布时间很短，因此应用程序被迫不断刷新它们，从而使服务有机会在需要时撤销应用程序的访问权限。</p>
<p>从第三方开发人员的角度来看，处理刷新令牌往往令人沮丧。开发人员非常喜欢不会过期的访问令牌，因为处理的代码要少得多。为了帮助缓解这些问题，服务通常会在其SDK中构建令牌刷新逻辑，以便该流程对开发人员而言是透明的。</p>
<p>总之，在以下情况下使用短期访问令牌和长期刷新令牌：</p>
<ul>
<li>您想使用自编码访问令牌</li>
<li>您希望限制泄露访问令牌的风险</li>
<li>您将提供给开发人员处理刷新逻辑的SDK</li>
</ul>
<h4 id="短期访问令牌，没有刷新令牌"><a href="#短期访问令牌，没有刷新令牌" class="headerlink" title="短期访问令牌，没有刷新令牌"></a>短期访问令牌，没有刷新令牌</h4><p>如果要确保用户了解正在访问其帐户的应用程序，则该服务可以在不刷新令牌的情况下发出相对短期的访问令牌。访问令牌可以持续从当前应用程序会话到几周。当访问令牌到期时，应用程序将被强制使用户再次登录，以便您作为服务知道用户不断参与重新授权应用程序。</p>
<p>通常，此选项由服务使用，如果第三方应用程序意外或恶意泄漏访问令牌，则存在高风险。通过要求用户不断重新授权应用程序，如果攻击者从服务中窃取访问权限，则该服务可以确保潜在的损害受到限制。</p>
<p>通过不发布刷新令牌，这使得应用程序无法在用户不在屏幕前的情况下持续使用访问令牌。这使得连续同步数据的应用程序将无法在此方法下执行此操作。</p>
<p>从用户的角度来看，这是最有可能让人感到沮丧的选项，因为用户必须不断重新授权应用程序。</p>
<p>总之，在以下情况下使用没有刷新令牌的短期访问令牌：</p>
<ul>
<li>您希望最大程度地防范泄露访问令牌的风险</li>
<li>您希望强制用户了解他们授予的第三方访问权限</li>
<li>您不希望第三方应用程序对用户数据进行脱机访问</li>
</ul>
<h4 id="非过期访问令牌"><a href="#非过期访问令牌" class="headerlink" title="非过期访问令牌"></a>非过期访问令牌</h4><p>非过期访问令牌是开发人员最简单的方法。如果您选择此选项，请务必考虑您所做的权衡。</p>
<p>如果你想能够任意撤销它们，那么使用自编码令牌是不切实际的。因此，您需要将这些令牌存储在某种数据库中，因此可以根据需要删除它们或将其标记为无效。</p>
<p>请注意，即使服务打算发布非过期访问令牌以供正常使用，您仍需要提供一种机制，以便在特殊情况下使其过期，例如，如果用户明确要撤消应用程序的访问权限，或者用户帐户已删除。</p>
<p>对于测试自己的应用程序的开发人员来说，非过期访问令牌就更容易。您甚至可以为开发人员预生成一个或多个非过期访问令牌，并在应用程序详细信息页面上显示给他们。通过这种方式，他们可以立即开始使用令牌发出API请求，而不必担心设置OAuth流程以开始测试API。</p>
<p>总之，在以下情况下使用非过期访问令牌：</p>
<ul>
<li>你有一个机制来随时撤销访问令牌</li>
<li>如果令牌泄露，你没有巨大的风险</li>
<li>您希望为开发人员提供简单的身份验证机制</li>
<li>您希望第三方应用程序可以脱机访问用户的数据</li>
</ul>
<h3 id="刷新访问令牌"><a href="#刷新访问令牌" class="headerlink" title="刷新访问令牌"></a>刷新访问令牌</h3><p>本节介绍如何允许开发人员使用刷新令牌获取新的访问令牌。如果您的服务与访问令牌一起发布刷新令牌，那么您需要实现此处描述的刷新授权类型。</p>
<h4 id="请求参数-3"><a href="#请求参数-3" class="headerlink" title="请求参数"></a>请求参数</h4><p>访问令牌请求将包含以下参数。</p>
<blockquote>
<p><strong>grant_type （需要）</strong><br>grant_type参数必须设置为“refresh_token”。</p>
<p><strong>refresh_token （需要）</strong><br>先前发布给客户端的刷新令牌。</p>
<p><strong>scope （可选的）</strong><br>请求的范围不得包含原始访问令牌中未发布的其他范围。通常，这不会包含在请求中，如果省略，服务应发出一个访问令牌，其范围与先前发布的相同。</p>
<p><strong>客户端身份验证（如果客户端被授予秘钥，则需要）</strong><br>通常，刷新令牌仅用于私密客户端。但是，由于可以在没有客户端秘钥的情况下使用授权码流程，因此刷新授权也可以给没有秘钥的客户端使用。如果客户端被授予秘钥，则客户端必须验证此请求。通常，该服务将允许额外的查询参数client_id和client_secret，或接受在HTTP Basic auth header中的客户端ID和秘钥。如果客户端没有秘钥，则此请求中不会出现客户端身份验证。</p>
</blockquote>
<h4 id="验证刷新令牌授权"><a href="#验证刷新令牌授权" class="headerlink" title="验证刷新令牌授权"></a>验证刷新令牌授权</h4><p>在检查所有必需参数并在客户端被授予秘钥时验证客户端之后，授权服务器可以继续验证请求的其他部分。</p>
<p>然后，服务器检查刷新令牌是否有效，并且尚未过期。如果向私密客户端发出刷新令牌，则服务必须确保将请求中的刷新令牌发送给经过身份验证的客户端。</p>
<p>如果所有内容都检出，该服务可以生成访问令牌并进行响应。服务器可以在响应中发出新的刷新令牌，但是如果响应不包括新的刷新令牌，则客户端假定现有的刷新令牌仍然有效。</p>
<p>例<br>以下是服务将接收的示例刷新授权。</p>
<pre><code class="http">POST /oauth/token HTTP/1.1
Host: authorization-server.com

grant_type=refresh_token
&amp;refresh_token=xxxxxxxxxxx
&amp;client_id=xxxxxxxxxx
&amp;client_secret=xxxxxxxxxx
</code></pre>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--重定向URI]]></title>
      <url>/2018/07/13/oauth-guide-11/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>重定向网址是OAuth流程的重要组成部分。用户成功授权应用程序后，授权服务器将带着URL中的授权码或访问令牌将用户重定向回应用程序。由于重定向URL将包含敏感信息，因此服务不会将用户重定向到任意位置就显得至关重要。</p>
<p>确保用户仅被定向到适当位置的最佳方法是要求开发人员在创建应用程序时注册一个或多个重定向URL。在这些部分中，我们将介绍如何处理移动应用程序的重定向URL，如何验证重定向URL以及如何处理错误。</p>
<h3 id="重定向URI注册"><a href="#重定向URI注册" class="headerlink" title="重定向URI注册"></a>重定向URI注册</h3><p>为了确保服务的安全性，您必须要求开发人员为应用程序注册一个或多个重定向URL。授权服务器绝不能重定向到任何其他位置。注册新应用程序包括创建注册表单，以允许开发人员为其应用程序注册重定向URL。</p>
<p>如果攻击者可以在用户到达授权服务器之前操纵重定向URL，则可能导致服务器将用户重定向到恶意服务器，恶意服务器会将授权码发送给攻击者。对于没有client_secret的公共客户端，只需要client_id和授权码就可以获取访问令牌。如果攻击者可以获得授权码，则可以将其交换为公共客户端的访问令牌。这是授权服务器在应用程序注册期间就应该知道应用程序是公共还是私有的另一个重要原因。</p>
<h4 id="有效的重定向网址"><a href="#有效的重定向网址" class="headerlink" title="有效的重定向网址"></a>有效的重定向网址</h4><p>在构建表单以允许开发人员注册重定向URL时，您应该对他们输入的URL进行一些基本验证。</p>
<p>已注册的重定向URL可能包含查询字符串参数，但不得在fragment中包含任何内容。如果开发人员尝试注册包含fragment的重定向URL，则注册服务器应拒绝该请求。</p>
<p>请注意，对于原生和移动应用程序，该平台可能允许开发人员注册URL方案<code>myapp://</code>，然后可以在重定向URL中使用该方案。这意味着授权服务器应允许注册任意URL方案，以支持为原生应用程序注册重定向URL。</p>
<h4 id="按请求自定义"><a href="#按请求自定义" class="headerlink" title="按请求自定义"></a>按请求自定义</h4><p>通常，开发人员会认为他们需要能够在每个授权请求上使用不同的重定向URL，并且会尝试更改每个请求的查询字符串参数。这不是重定向URL的预期用途，授权服务器不应该允许这样的URL。服务器应拒绝任何具有与注册URL不完全匹配的重定向URL的授权请求。</p>
<p>如果客户端希望在重定向URL中包含特定于请求的数据，则可以使用“state”参数来存储在重定向用户之后将包括的数据。可以在state参数本身中对数据进行编码，也可以使用state参数作为会话ID来在服务器上存储状态。</p>
<h3 id="原生应用程序的重定向URI"><a href="#原生应用程序的重定向URI" class="headerlink" title="原生应用程序的重定向URI"></a>原生应用程序的重定向URI</h3><p>原生应用程序是安装在设备上的客户端，例如桌面应用程序或移动应用程序。在支持与安全性和用户体验相关的原生应用程序时，需要记住一些事项。</p>
<p>授权endpoint通常会将用户重定向回客户端注册的重定向URL。根据平台，应用程序可以声明URL模式，也可以注册启动应用程序的自定义URL方案。例如，iOS应用程序可以注册自定义协议，例如<code>myapp://</code>，然后使用redirect_uri <code>myapp://callback</code>。</p>
<h4 id="应用程序声明的https-URL重定向"><a href="#应用程序声明的https-URL重定向" class="headerlink" title="应用程序声明的https URL重定向"></a>应用程序声明的https URL重定向</h4><p>某些平台（从iOS 9开始的Android和iOS）允许应用程序覆盖特定的URL模式以启应用程序而不是Web浏览器。例如，应用程序可以注册<code>https://app.example.com/auth</code>，只要Web浏览器尝试重定向到该URL，操作系统就会启动应用程序。</p>
<p>如果操作系统支持声明URL，则应使用此方法。这允许操作系统保证应用程序的标识。如果操作系统不支持此操作，则应用程序必须使用自定义URL方案。</p>
<h4 id="自定义URL方案"><a href="#自定义URL方案" class="headerlink" title="自定义URL方案"></a>自定义URL方案</h4><p>大多数移动和桌面操作系统允许应用注册自定义URL方案，当从系统浏览器访问具有该方案的URL时，该方案将启动应用程序。</p>
<p>使用此方法，本机应用程序正常启动OAuth流，方法是使用标准授权码参数启动系统浏览器。唯一的区别是重定向URL将是具有应用程序自定义方案的URL。</p>
<p>当授权服务器发送打算将用户重定向到<code>myapp://callback#token=....</code>的Location header时，手机将启动应用程序，应用程序将能够恢复授权过程，从URL解析访问令牌并在内部存储它。</p>
<h4 id="自定义URL方案命名空间"><a href="#自定义URL方案命名空间" class="headerlink" title="自定义URL方案命名空间"></a>自定义URL方案命名空间</h4><p>由于没有集中注册URL方案的方法，因此应用程序必须尽力选择不会相互冲突的URL方案。</p>
<p>您的服务可以通过要求URL方案遵循特定模式来提供帮助，并且只允许开发人员注册与该模式匹配的自定义方案。</p>
<p>例如，Facebook根据应用的客户端ID为每个应用生成一个URL方案。例如，<code>fb00000000://</code>数字对应于应用程序的客户端ID。这提供了一种生成全局唯一URL方案的合理可靠方法，因为其他应用程序不太可能使用具有此模式的URL方案。</p>
<p>应用程序的另一个选项是将反向域名模式与应用程序发布者控制的域一起使用。这也可以由服务强制执行。</p>
<h3 id="重定向URI验证"><a href="#重定向URI验证" class="headerlink" title="重定向URI验证"></a>重定向URI验证</h3><p>有三种情况需要验证重定向网址。</p>
<ul>
<li>当开发人员将重定向URL注册为创建应用程序的一部分时</li>
<li>在授权请求中（授权码类型和隐式授权类型）</li>
<li>当应用程序交换访问令牌的授权码时</li>
</ul>
<h4 id="重定向URL注册"><a href="#重定向URL注册" class="headerlink" title="重定向URL注册"></a>重定向URL注册</h4><p>如创建应用程序中所述，该服务应允许开发人员在创建应用程序时注册一个或多个重定向URL。重定向URL的唯一限制是它不能包含fragment组件。该服务必须允许开发人员使用自定义URL方案注册重定向URL，以便在某些平台上支持应用程序。</p>
<h4 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h4><p>当应用程序启动OAuth流程时，它会将用户定向到您服务的授权endpoint。该请求将在URL中包含多个参数，包括重定向URL。</p>
<p>此时，授权服务器必须验证重定向URL，以确保请求中的URL与应用程序的一个已注册URL匹配。请求还将有一个client_id参数，因此服务应该根据该id查找重定向URL。攻击者完全有可能使用一个应用程序的客户端ID和攻击者的重定向URL来创建授权请求，这就是需要注册的原因。</p>
<p>服务应查找URL的完全匹配，并避免仅匹配特定URL的一部分。（如果需要自定义每个请求，客户端可以使用state参数。）简单的字符串匹配就足够了，因为无法根据请求自定义重定向URL。服务器需要做的就是检查请求中的重定向URL是否与开发人员在注册其应​​用程序时输入的重定向URL相匹配。</p>
<p>如果重定向URL不是已注册的重定向URL之一，则服务器必须立即显示指示此类的错误，而不是重定向用户。这样可以避免将授权服务器用作打开的重定向程序。</p>
<h4 id="授予访问令牌"><a href="#授予访问令牌" class="headerlink" title="授予访问令牌"></a>授予访问令牌</h4><p>令牌endpoint时用授权码交换访问令牌的的请求。此请求将包含重定向URL以及授权码。作为安全性的附加度量，服务器应验证此请求中的重定向URL是否与授权码的初始授权请求中包含的重定向URL完全匹配。如果重定向URL不匹配，则服务器会拒绝该请求并显示错误。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--范围]]></title>
      <url>/2018/07/13/oauth-guide-10/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>本章是对OAuth服务提供商的指导。</p>
<p>范围(scope)是一种限制应用访问用户数据的方法。与授予对用户帐户的完全访问权限相比，为应用程序提供一种方式，来限制他们代表用户访问和操作的范围，通常是一种更有效的方式。</p>
<p>某些应用仅使用OAuth来识别用户，因此他们只需要访问用户ID和基本配置文件信息。其他应用可能需要知道更敏感的信息，例如用户的生日，或者他们可能需要能够代表用户发布内容，或修改个人资料数据。如果用户确切知道应用程序可以和不能对他们的帐户做什么，他们将更愿意授权应用程序。范围是一种控制访问权限的方法，可帮助用户识别他们授予应用程序的权限。</p>
<h3 id="定义范围"><a href="#定义范围" class="headerlink" title="定义范围"></a>定义范围</h3><p>定义范围的好地方是分别定义读取与写入。这适用于Twitter，因为并非所有应用程序实际上都希望能够将内容发布到您的Twitter帐户，有些只需要访问您的个人资料信息。</p>
<p>定义服务范围时的挑战是不要因定义太多范围而被忽略。用户需要能够理解他们授予的授权范围，并且这将在列表中呈现给用户。当呈现给用户时，他们需要真正了解正在发生的事情。如果您为用户设计的过度复杂，他们可能会单击“确定”直到应用程序正常工作，并忽略任何警告。</p>
<h4 id="读与写"><a href="#读与写" class="headerlink" title="读与写"></a>读与写</h4><p>通常，在定义服务范围时，读取和写入访问是一个很好的起点。通常，对想要更新配置文件信息的应用程序，使用单独的访问控制来处理对用户的私有配置文件信息的读访问。</p>
<p>需要能够代表用户创建内容的应用程序（例如，将推文发布到用户的时间线的第三方Twitter应用程序），与仅需要读取用户的公共数据的应用程序相比，需要获得不同级别的访问权限。</p>
<h4 id="限制对敏感信息的访问"><a href="#限制对敏感信息的访问" class="headerlink" title="限制对敏感信息的访问"></a>限制对敏感信息的访问</h4><p>通常，对于不同安全级别的用户，服务将具有不同的配置。例如，GitHub有一个单独的范围，允许应用程序访问私有存储库。默认情况下，应用程序无权访问私有存储库，除非他们要求该范围，因此用户可以放心地知道他们选择的应用只能访问属于其组织的私有存储库。</p>
<p>GitHub提供了一个单独的范围，允许应用程序删除repos，因此用户可以放心，随机应用程序无法绕过这个范围删除其存储库。</p>
<p>Dropbox为应用程序提供了一种限制自己只能编辑单个文件夹中文件的方法。这为尝试使用Dropbox作为存储或同步机制的应用程序提供了一种方法，用户无需担心应用程序可能会读取其所有文件。</p>
<h4 id="通过功能选择性地启用访问"><a href="#通过功能选择性地启用访问" class="headerlink" title="通过功能选择性地启用访问"></a>通过功能选择性地启用访问</h4><p>范围的一个很好的用途是根据所需的功能选择性地启用对用户帐户的访问。例如，Google为其各种服务提供了一组范围，例如Google云端硬盘，Gmail，YouTube等。这意味着需要访问YouTube API的应用程序也不一定能够访问用户的Gmail帐户。</p>
<p>谷歌的API是有效使用范围的一个很好的例子。有关Google OAuth API支持的范围的完整列表，请访问<code>https://developers.google.com/oauthplayground/</code>上的 OAuth 2.0 Playground。</p>
<h4 id="限制对可结算资源的访问"><a href="#限制对可结算资源的访问" class="headerlink" title="限制对可结算资源的访问"></a>限制对可结算资源的访问</h4><p>如果您的服务提供的API可能会导致用户产生费用，那么设定范围是防止滥用此功能的应用程序的好方法。</p>
<p>例如，在提供使用许可内容的高级功能的情况下，提供用于聚合给定区域的人口统计数据的API。用户在使用服务时收取费用，费用取决于要查询的区域的大小。当用户登录使用完全不同的API部分的应用时，用户希望确保此应用无法使用人口统计信息API，因为这会导致该用户产生费用。在这种情况下，服务应定义一个特殊范围，例如“人口统计”。人口统计信息API应仅响应来自包含此范围的令牌的API请求。</p>
<p>在此示例中，人口统计信息API可以使用<a href="https://www.oauth.com/oauth2-servers/token-introspection-endpoint/" target="_blank" rel="noopener">令牌自解析端点</a>来查找对此令牌有效的范围列表。如果响应在范围列表中不包含“人口统计”，则端点将使用HTTP 403响应拒绝该请求。</p>
<h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p>用户在授权应用程序时看到的界面需要清楚地显示应用程序请求的范围列表。用户可能不知道服务提供的范围的所有可能性，因此最好使该文本尽可能清晰明了，避免使用行话和缩写。</p>
<p>如果请求授予应用程序对用户帐户的完全访问权限，或访问其帐户的大部分内容，例如除了更改密码之外能够执行所有操作，则该服务应该非常清楚。例如，Dropbox授权用户界面上的第一句话是“示例OAuth应用程序希望访问Dropbox中的文件和文件夹”，其中包含“了解更多”链接，该链接指向帮助页面，该帮助页面准确描述了应用程序将具有哪些访问权限。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/dropbox.png" alt="dropbox"></p>
<p>Flickr授权界面显示用户在登录时授予应用程序的三件事，并清楚地显示应用程序不具有的权限。显示这一点的好处是，用户可以放心，他们授权的应用程序将无法进行潜在的破坏性操作。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/flickr.png" alt="flickr"></p>
<p>GitHub在提供有关用户授予范围的详细信息方面做得非常出色。请求的每个范围都会在页面上显示一个部分，其中包含名称，图标，突出显示是只读还是读写的简短说明，以及下拉列表以查看更详细的说明。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/github.png" alt="github"></p>
<p>Google为其所有服务提供单一授权终端，包括Gmail API，Google云端硬盘，Youtube等。其授权界面会在列表中显示每个范围，并包含一个“信息”图标，您可以点击该图标以获取有关特定内容的详细信息范围。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/google.png" alt="google"></p>
<p>单击信息图标会显示一个叠加层，详细描述此范围允许的内容。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/google-scope-popup.png" alt="google_scope"></p>
<p>您可以看到有多种方法可以为用户提供有关OAuth授权范围的信息，并且各种服务采用了截然不同的方法。在您定义范围时，请务必考虑应用程序的隐私和安全要求。</p>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>虽然这是一个看似未充分利用的功能，但OAuth 2.0规范明确允许授权服务器授予访问令牌的范围小于应用程序的请求。这为一些有趣的可能性留下了空间。</p>
<p>在开始开发OAuth 2.0规范之前，OAuth 1已部署在Twitter上，Twitter应用程序生态系统正在迅速发展。在创建Twitter应用程序时，您可以选择您的应用程序是需要读取+写入权限还是只读取对用户帐户的访问权限。这是一种开发OAuth 2.0范围概念的机制。但是，这种实现是相当有限的，因为应用程序要么不请求写访问权限，要么用户可能只是拒绝该请求，如果他们不想授予应用程序写访问权限。</p>
<p>很快就开发了一种常见的Twitter应用程序的反模式，它只使用写访问权来发布推文给应用程序做广告。其中一个更臭名昭着的事件发生在2010年，当时应用程序“Twifficiency”声称“根据你的推特活动计算你的推特效率”，但这却很快失控。您将使用您的Twitter帐户登录该应用程序，它会抓取您过去的推文并对其进行分析。但是，它也自动发推文“我的Twifficiency得分是__％。你的是多少？”从而链接到第三方网站。许多人甚至不知道应用程序正在执行此操作，或者他们已授予此应用程序权限以发布到其帐户。这导致应用程序变成病毒式传播，因为使用该应用程序的任何人的关注者都会在他们的时间轴中看到它。</p>
<p>许多人对此感到不安，并在Twitter上大声抱怨。当时雅虎的开发人员Ben Ward更进一步，创建了一个可以解决这个问题的潜在用户界面的模型，并写了一篇简短的博客文章解释它。<code>https://benward.uk/blog/tumblr-968515729</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftfc4um00ij30lp0cftat.jpg" alt="twitter"></p>
<p>在帖子中，Ward描述了一个允许应用程序请求特定权限的用户界面，用户可以选择授予或不授予每个权限。这将允许用户登录应用程序但不允许其首先发布到其帐户。稍后，如果用户确实想要允许该应用发布，则该应用可以提供在Twitter上重新授权用户的机制。几个月后，沃德在Twitter被聘用。</p>
<p>这篇文章引发了一些参与OAuth规范开发的人们之间的讨论，这个讨论现在只存在于archive.org上的Google Buzz主题：<code>http://web.archive.org/web/20100823114908/</code>,<code>http://www.google.com/buzz/tantek/5YHAAmztLcD/t-Look-BenWard-schools-Twitter-on-OAuth</code>。</p>
<p>直到今天，Twitter仍然没有提供这种细粒度的授权。但是，其他服务已经开始实现类似的功能，在授权流程中为用户提供更多控制，而不是使其看起来像“单击确定以继续”对话框。</p>
<p>Facebook推出了最近的更新，为初始页面提供了一个简单的用户界面，允许用户点击编辑应用程序将被授予的范围，如下所示。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftfc74seznj30sc0f7jso.jpg" alt="facebook"></p>
<p>如果单击“编辑您提供的信息”，则会转到一个界面，列出应用程序请求的每个范围，您可以根据需要取消选中它们。在下面的屏幕截图中，我选择不允许应用程序查看我的朋友列表。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftfc7yma0rj30si0f775b.jpg" alt="facebook checkbox"></p>
<p>只有应用程序请求的范围才会出现在此列表中。这为用户提供了更好的体验，因为他们能够保持控制并更好地了解应用程序如何使用其帐户。</p>
<p>FitBit跟踪用户健康的许多方面，例如步数，心率，消耗的食物和饮料，睡眠质量，体重等。FitBit API对第三方应用程序提供对所有这些数据的访问。由于许多第三方应用程序只会读取或写入某些类型的数据，FitBit会提供精细的范围，以便用户只能授予对其配置文件的某些部分的访问权限。</p>
<p>FitBit的授权页面（如下所示）允许用户有选择地授予或拒绝访问应用程序请求的每个特定范围。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ftfcao2nejj30pw0r4n14.jpg" alt="fitbit"></p>
<p>GitHub 在2013 年的博客文章中描述了他们计划允许用户编辑范围，但截至2018年，依旧没有后续跟进。</p>
<p>使用户能够选择授予哪些范围是让人们对使用第三方应用感到更舒服的好方法。每个范围旁边加复选框就足够了，或者您可以将控件移动到像Facebook这样的单独屏幕。您需要确保在发送访问令牌响应时，它包括用户所授予的范围列表，而不是应用程序请求的。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--授权]]></title>
      <url>/2018/07/13/oauth-guide-9/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>本章是对OAuth服务提供商的指导。</p>
<p>授权界面是用户在授予应用程序访问其帐户时看到的页面。以下部分介绍如何构建授权页面，界面中包含哪些组件以及如何最好地向用户显示界面。</p>
<p>在实施OAuth服务时，您正在使开发人员能够构建利用您的平台的应用程序，允许应用程序访问并可能修改私有用户内容，或代表用户行事。因此，您需要确保为用户提供尽可能多的信息以保护其帐户，并确保他们了解应用程序对其帐户执行的操作。</p>
<h3 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h3><p>客户端会将用户的浏览器定向到授权服务器以开始OAuth流程。客户端可以使用授权码授予类型或隐式授权。除了response_type参数指定的授权类型外，请求还有许多其他参数来指示请求的细节。</p>
<p><a href="http://seanthefish.com/2018/06/29/oauth-guide-2/">OAuth 2.0客户端</a>描述了客户端如何为您的服务构建授权URL。授权服务器第一次看到用户申请此授权请求时，将使用客户端设置的查询参数将用户定向到服务器。此时，授权服务器将需要验证请求并提供授权接口，允许用户批准或拒绝该请求。</p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>以下参数用于开始授权请求。例如，如果授权服务器URL是<code>https://authorization-server.com/auth</code>, 客户端将创建如下的URL并将用户的浏览器指向它：</p>
<pre><code class="html">https://authorization-server.com/auth?response_type=code
&amp;client_id=29352735982374239857
&amp;redirect_uri=https://example-app.com/callback
&amp;scope=create+delete
&amp;state=xcoivjuywkdkhvusuye3kch
</code></pre>
<blockquote>
<p><strong>response_type</strong><br>response_type将设置为code，表示应用程序希望在成功时收到授权码。</p>
<p><strong>client_id</strong><br>client_id是应用程序的公共标识符。</p>
<p><strong>redirect_uri （可选的）</strong><br>redirect_uri不规范所要求的，但你的服务应该需要它。此URL必须与开发人员在创建应用程序时注册的其中一个URL匹配，如果请求不匹配，授权服务器应拒绝该请求。</p>
<p><strong>scope （可选的）</strong><br>请求可以具有一个或多个scope值，指示应用程序请求的附加访问。授权服务器需要向用户显示请求的scope。</p>
<p><strong>state （推荐的）</strong><br>state应用程序使用该参数来存储特定于请求的数据和/或防止CSRF攻击。授权服务器必须将未修改的state值返回给应用程序。</p>
</blockquote>
<h4 id="授予类型"><a href="#授予类型" class="headerlink" title="授予类型"></a>授予类型</h4><p>当客户端应用程序期望授权码作为响应时，授权码授予类型将与密钥和公共客户端一起工作。要启动授权码授予，客户端将使用查询参数response_type=code以及其他所需参数将用户的浏览器定向到授权服务器。</p>
<h4 id="验证授权请求"><a href="#验证授权请求" class="headerlink" title="验证授权请求"></a>验证授权请求</h4><p>授权服务器必须首先验证client_id请求中的对应的有效的应用程序。</p>
<p>如果您的服务器允许应用程序注册多个重定向URL，则验证重定向URL有两个步骤。如果请求包含redirect_uri参数，则服务器必须确认它是此应用程序的有效重定向URL。如果redirect_uri请求中没有参数，并且只注册了一个URL，则服务器使用先前注册的重定向URL。否则，如果请求中没有重定向URL，并且没有注册重定向URL，就将会返回一个错误。</p>
<p>如果client_id无效，服务器应立即拒绝请求并向用户显示错误。</p>
<h4 id="无效的重定向网址"><a href="#无效的重定向网址" class="headerlink" title="无效的重定向网址"></a>无效的重定向网址</h4><p>如果授权服务器检测到重定向URL有问题，则需要通知用户该问题。由于多种原因，重定向网址可能无效，包括：</p>
<ul>
<li>缺少重定向URL参数</li>
<li>重定向URL参数无效，例如，如果它是不解析为URL的字符串</li>
<li>重定向URL与应用程序的已注册重定向URL之一不匹配</li>
</ul>
<p>在这些情况下，授权服务器应向用户显示错误，通知他们问题。服务器不得将用户重定向回应用程序。这避免了所谓的“<a href="https://oauth.net/advisories/2014-1-covert-redirect/" target="_blank" rel="noopener">开放重定向器攻击</a>”。如果已注册重定向URL，则服务器应仅将用户重定向到重定向URL。</p>
<h4 id="其他错误"><a href="#其他错误" class="headerlink" title="其他错误"></a>其他错误</h4><p>通过将用户重定向到重定向URL，并使用查询字符串中的错误代码来处理所有其他错误。有关如何响应错误的详细信息，请参阅“<a href="https://www.oauth.com/oauth2-servers/authorization/the-authorization-response/" target="_blank" rel="noopener">授权响应</a>”部分。</p>
<p>如果请求缺少response_type参数，或者该参数的值是除了code和token之外的任何内容，则服务器会返回invalid_request错误。</p>
<p>由于授权服务器可能要求客户端指定它们是公共的还是机密的，因此它可以拒绝不允许的授权请求。例如，如果客户端指定它们是机密客户端，则服务器可以拒绝使用令牌授权类型的请求。拒绝时，请使用错误代码unauthorized_client。</p>
<p>如果存在无法识别的scope值，授权服务器应拒绝该请求。在这种情况下，服务器可以使用invalid_scope错误代码重定向到回调URL 。</p>
<p>授权服务器需要存储此请求的“state”值，以便将其包含在访问令牌响应中。服务器不得修改或对state值包含的内容做出任何假设，因为它纯粹是为了客户端的便利。</p>
<h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>用户在单击应用程序的“登录”或“连接”按钮后将看到的第一件事是您的授权服务器UI。由授权服务器决定是否在每次访问授权屏幕时要求用户登录，或者让用户登录一段时间。如果授权服务器要在请求之间记住用户，那么它将需要请求用户在将来访问时授权该应用程序。</p>
<p>通常像Twitter或Facebook这样的网站希望他们的用户在大多数时间都是签名的，因此他们为他们的授权屏幕提供了一种方式，通过不要求他们每次登录来为用户提供简化的体验。但是，根据服务以及第三方应用程序的安全要求，可能需要或允许开发人员选择要求用户在每次访问授权屏幕时登录。</p>
<p>在Google的API中，应用程序可以添加prompt=login到授权请求，这会导致授权服务器在显示授权提示之前强制用户再次登录。</p>
<p>在任何情况下，如果用户已退出，或者在您的服务上还没有帐户，则需要为他们提供在此屏幕上登录或创建帐户的方法。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/twitter_logged_out_auth_screen.png" alt="Twitter的授权屏幕的退出视图"></p>
<p>因为OAuth 2.0规范中未指定，您可以按照您希望的方式对用户进行身份验证。大多数服务使用传统的用户名/密码登录来验证其用户，但这绝不是解决问题的唯一方法。在企业环境中，常见的技术是使用SAML（一种基于XML的身份验证标准）来利用组织中的现有身份验证机制，同时避免创建另一个用户名/密码数据库。</p>
<p>一旦用户使用授权服务器进行身份验证，它就可以继续处理授权请求并将用户重定向回应用程序。通常，服务器将认为成功登录也意味着用户授权该应用程序。在这种情况下，具有登录提示的授权页面将需要包括描述以下事实的文本：通过登录，用户正在批准该授权请求。这将导致以下用户流程。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/github_create_new_application_1.png" alt="登录和未登录的用户流程"></p>
<p>如果授权服务器需要通过SAML或其他内部系统对用户进行身份验证，则用户流程将如下所示</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/okta_oauth-diagrams_2.png" alt="用于单独验证服务器的用户流"></p>
<p>在此流程中，用户在登录后被定向回授权服务器，在那里他们看到授权请求，就像他们已经登录一样。</p>
<h3 id="授权接口"><a href="#授权接口" class="headerlink" title="授权接口"></a>授权接口</h3><p>授权界面是用户在收到来自第三方应用程序的授权请求时将看到的屏幕。由于第三方应用程序会要求用户授予某种级别的访问权限，因此您需要确保用户在授权应用程序权限时做出明智决策所需的所有信息。授权接口通常具有以下组件：</p>
<h4 id="网站名称和logo"><a href="#网站名称和logo" class="headerlink" title="网站名称和logo"></a>网站名称和logo</h4><p>该服务应该易于用户识别，因为他们需要知道他们授予哪些服务访问权限。但是，您确定主页上的网站应与授权界面一致。通常，这通过在屏幕的一定的位置显示应用程序名称和logo，或在整个网站上使用一致的颜色方案来完成。</p>
<h4 id="用户识别"><a href="#用户识别" class="headerlink" title="用户识别"></a>用户识别</h4><p>如果用户已登录，则应向用户指明。这可能就像在屏幕的右上角显示他们的名字和照片一样，就像在网站的其他部分一样。</p>
<p>重要的是，用户知道他们当前登录的帐户，以防他们管理多个帐户，以便他们不会错误地授权不同的用户帐户。</p>
<h5 id="申请细节"><a href="#申请细节" class="headerlink" title="申请细节"></a>申请细节</h5><p>授权接口应清楚地标识发出请求的应用程序。除了开发人员提供的应用程序名称之外，通常还应该显示网站和应用程序的logo，这是开发人员注册应用程序时收集的信息。我们在<a href="http://seanthefish.com/2018/07/08/oauth-guide-7/">客户端注册</a>中详细讨论了这一点。</p>
<h4 id="要求的范围"><a href="#要求的范围" class="headerlink" title="要求的范围"></a>要求的范围</h4><p>应该向用户清楚地显示授权请求中提供的范围值。范围值通常是表示特定访问的短字符串，因此应向用户显示更易于阅读的版本。</p>
<p>例如，如果服务将“私有”范围定义为对私有配置文件数据的读取访问权限，则授权服务器应该说“此应用程序将能够查看您的私有配置文件数据”。如果范围明确允许写入访问，也应该在描述中标识，例如“此应用程序将能够编辑您的配置文件数据”。</p>
<p>如果没有范围，但您的服务仍然授予对用户帐户的一些基本访问级别，则应该包含描述应用程序将访问的内容的消息。如果省略范围意味着应用程序获得的唯一内容是用户标识，则可以包含一条消息，以表示“此应用程序希望您登录”。</p>
<p>有关如何在服务中有效使用范围的更多信息，请参阅<a href="https://www.oauth.com/oauth2-servers/scope/" target="_blank" rel="noopener">范围</a>。</p>
<h4 id="请求的或有效的生命周期"><a href="#请求的或有效的生命周期" class="headerlink" title="请求的或有效的生命周期"></a>请求的或有效的生命周期</h4><p>授权服务器必须决定授权的有效期，访问令牌的持续时间以及刷新令牌的持续时间。</p>
<p>大多数服务不会自动使授权失效，而是希望用户定期查看和撤消对他们不再想要使用的应用的访问权限。但是，默认情况下，某些服务提供有限的令牌生存期，并允许应用程序请求更长的持续时间，或强制用户在授权过期后重新授权应用程序。</p>
<p>无论您对授权的有效期做出何种决定，都应该向用户明确说明应用程序能够代表用户执行多长时间。这可能是一个句子，加单的表明：“这个应用程序将能够访问您的帐户，直到您撤销访问”或者“这个应用程序将能够访问您的帐户，时效为一个星期。”关于令牌生命周期的更多信息请参见<a href="https://www.oauth.com/oauth2-servers/access-tokens/access-token-lifetime/" target="_blank" rel="noopener">访问令牌生命周期</a>。</p>
<h4 id="允许否认"><a href="#允许否认" class="headerlink" title="允许否认"></a>允许否认</h4><p>最后，授权服务器应该向用户提供两个按钮，以允许或拒绝该请求。如果用户未登录，则应提供登录提示而不是“允许”按钮。</p>
<p>如果用户批准该请求，则授权服务器将生成访问令牌并使用令牌信息重定向到应用程序。如果用户单击“拒绝”，则服务器会重定向到应用程序，并在URL中显示错误代码。</p>
<h3 id="授权响应"><a href="#授权响应" class="headerlink" title="授权响应"></a>授权响应</h3><p>根据授权类型，授权服务器将使用授权码或访问令牌进行响应。</p>
<h4 id="授权码响应"><a href="#授权码响应" class="headerlink" title="授权码响应"></a>授权码响应</h4><p>如果请求有效并且用户授予授权请求，则授权服务器生成授权码并将用户重定向回应用程序，将代码和先前的“state”值添加到重定向URL。</p>
<h4 id="生成授权码"><a href="#生成授权码" class="headerlink" title="生成授权码"></a>生成授权码</h4><p>授权码必须在颁发后不久到期。OAuth 2.0规范建议最长生命周期为10分钟，但实际上，大多数服务设置的到期时间要短得多，大约30-60秒。授权代码本身可以是任意长度，但应记录代码的长度。</p>
<p>因为授权代码是短暂的并且是单次使用的，所以它们是实现自编码的很好的候选者。使用此技术，您可以避免将授权代码存储在数据库中，而是将所有必要的信息编码到代码本身中。您可以使用服务器端环境的内置加密库，也可以使用JSON Web Signature（JWS）等标准。由于此字符串只需要您的授权服务器可以理解，因此不需要使用JWS等标准来实现此字符串。也就是说，如果您没有可以轻松访问的已经可用的加密库，JWS是一个很好的候选者，因为有许多语言的库可用。</p>
<p>需要与授权代码关联的信息如下。</p>
<blockquote>
<p><strong>client_id</strong><br>请求此代码的客户端ID（或其他客户端标识符）</p>
<p><strong>redirect_uri</strong><br>使用的重定向网址。需要存储，因为访问令牌请求必须包含相同的重定向URL，以便在发出访问令牌时进行验证。</p>
<p><strong>用户信息(User info)</strong><br>用于标识此授权代码所针对的用户的某种方式，例如用户ID。</p>
<p><strong>到期日期(Expiration Date)</strong><br>代码需要包含到期日期，以便使它能只持续很短的时间。</p>
<p><strong>唯一ID(Unique ID)</strong><br>代码需要其自己的某种ID，以便能够检查代码之前是否已被使用过。数据库ID或随机字符串就足够了。</p>
</blockquote>
<p>通过创建JWS令牌或生成随机字符串并将关联信息存储在数据库中生成授权码后，您需要将用户重定向到指定的应用程序重定向URL。要添加到重定向URL的查询字符串的参数如下：</p>
<blockquote>
<p><strong>code</strong><br>此参数包含客户端稍后将为访问令牌交换的授权码。</p>
<p><strong>state</strong><br>如果初始请求包含state参数，则响应还必须包含请求中的确切值。客户端将使用此将此响应与初始请求相关联。</p>
</blockquote>
<p>例如，授权服务器通过发送以下HTTP响应来重定向用户。</p>
<pre><code class="http">HTTP/1.1 302 Found
Location: https://oauth2client.com/redirect?code=g0ZGZmNjVmOWI&amp;state=dkZmYxMzE2
</code></pre>
<h4 id="隐式授权类型响应"><a href="#隐式授权类型响应" class="headerlink" title="隐式授权类型响应"></a>隐式授权类型响应</h4><p>使用隐式授权，授权服务器立即生成访问令牌，并使用令牌和其他参数重定向到回调URL。有关生成访问令牌的详细信息以及响应中所需参数的详细信息，请参阅访问<a href="https://www.oauth.com/oauth2-servers/access-tokens/access-token-response/" target="_blank" rel="noopener">令牌响应</a>。</p>
<p>例如，授权服务器通过发送以下HTTP响应来重定向用户（出于显示目的，需要额外的换行符）。</p>
<pre><code class="http">HTTP/1.1 302 Found
Location: https://example-app.com/redirect#access_token=MyMzFjNTk2NTk4ZTYyZGI3
 &amp;state=dkZmYxMzE2
 &amp;token_type=bearer
 &amp;expires_in=86400
</code></pre>
<h5 id="错误响应"><a href="#错误响应" class="headerlink" title="错误响应"></a>错误响应</h5><p>在两种情况下，授权服务器应直接显示错误消息，而不是将用户重定向到应用程序：如果client_id无效，或者redirect_uri无效。在所有其他情况下，可以将用户重定向到应用程序的重定向URL以及描述错误的查询字符串参数。</p>
<p>重定向到应用程序时，服务器会将以下参数添加到重定向URL：</p>
<blockquote>
<p><strong>error</strong><br>通常是以下列表中的一个ASCII错误代码：</p>
<ul>
<li><em>invalid_request</em> - 请求缺少参数，包含无效参数，多次包含参数，或者无效。</li>
<li><em>access_denied</em> - 用户或授权服务器拒绝该请求</li>
<li><em>unauthorized_client</em> - 不允许客户端使用此方法请求授权码，例如，如果机密客户端尝试使用隐式授权类型。</li>
<li><em>unsupported_response_type8</em> - 服务器不支持使用此方法获取授权代码，例如，如果授权服务器从未实现隐式授权类型。</li>
<li><em>invalid_scope</em> - 请求的范围无效或未知。</li>
<li><em>server_error</em> - 服务器可以使用此错误代码重定向，而不是向用户显示500内部服务器错误页面。</li>
<li><em>temporarily_unavailable</em> - 如果服务器正在进行维护或不可用，则可以返回此错误代码，而不是使用503 Service Unavailable状态代码进行响应。</li>
</ul>
<p><strong>error_description</strong><br>授权服务器可以可选地包括错误的描述。此参数旨在供开发人员理解错误，而不是要向最终用户显示。除双引号和反斜杠外，此参数的有效字符是ASCII字符集，特别是十六进制代码20-21,23-5B和5D-7E。</p>
<p><strong>error_uri</strong><br>服务器还可以将URL返回到人类可读的网页，其中包含有关错误的信息。这是为了让开发人员获得有关错误的更多信息，而不是要向最终用户显示。</p>
<p><strong>state</strong><br>如果请求包含状态参数，则错误响应还必须包含请求中的确切值。客户端可以使用它将此响应与初始请求相关联。</p>
</blockquote>
<p>例如，如果用户拒绝授权请求，服务器将构造以下URL并发送HTTP重定向响应（如下所示）（URL中的换行符用于说明目的）。</p>
<pre><code class="http">HTTP/1.1 302 Found
Location: https://example-app.com/redirect?error=access_denied
 &amp;error_description=The+user+denied+the+request
 &amp;error_uri=https%3A%2F%2Foauth2server.com%2Ferror%2Faccess_denied
 &amp;state=wxyz1234
</code></pre>
<h3 id="安全考虑因素"><a href="#安全考虑因素" class="headerlink" title="安全考虑因素"></a>安全考虑因素</h3><p>以下是构建授权服务器时应考虑的一些已知问题。</p>
<p>除了此处列出的注意事项外，<a href="https://tools.ietf.org/html/rfc6819" target="_blank" rel="noopener">OAuth 2.0线程模型和安全注意事项草案</a>中还提供了更多信息。</p>
<h4 id="网络钓鱼攻击"><a href="#网络钓鱼攻击" class="headerlink" title="网络钓鱼攻击"></a>网络钓鱼攻击</h4><p>针对OAuth服务器的一种潜在攻击是网络钓鱼攻击。这是攻击者创建一个看起来与服务授权页面相同的网页的地方，该页面通常包含用户名和密码字段。然后，通过各种手段，攻击者可以诱骗用户访问该页面。除非用户可以检查浏览器的地址栏，否则该页面可能看起来与真正的授权页面相同，并且用户可以输入他们的用户名和密码。</p>
<p>攻击者可以尝试诱骗用户访问伪造服务器的一种方法是将此网络钓鱼页面嵌入到本机应用程序中的嵌入式Web视图中。由于嵌入式Web视图不显示地址栏，因此用户无法直观地确认它们位于合法站点上。遗憾的是，这在移动应用程序中很常见，并且开发人员通常希望通过整个登录过程将用户保留在应用程序中来提供更好的用户体验。某些OAuth提供商鼓励第三方应用程序打开Web浏览器或启动提供程序的本机应用程序，而不是允许它们在Web视图中嵌入授权页面。</p>
<h5 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h5><p>确保通过https提供授权服务器以避免DNS欺骗。</p>
<p>授权服务器应该向开发人员介绍网络钓鱼攻击的风险，并且可以采取措施防止该页面嵌入到本机应用程序或iframe中。</p>
<p>应该让用户了解网络钓鱼攻击的危险，并且应该教导用户最佳实践，例如只访问他们信任的应用程序，并定期查看应用程序列表，对不再使用的应用程序授权撤销的访问权限。</p>
<p>该服务可能希望在允许其他用户使用该应用程序之前验证第三方应用程序。Instagram和Dropbox等服务目前都是这样做的，在初始创建应用程序时，该应用程序只能由开发人员或其他白名单用户帐户使用。应用程序提交审批并进行审核后，可以由该服务的整个用户群使用。这使服务有机会检查应用程序如何与服务交互。</p>
<h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><p>在点击劫持攻击中，攻击者创建了一个恶意网站，在该网站中，攻击者网页上方的透明iframe中加载了授权服务器URL。攻击者的网页堆放在iframe下方，并且有一些看似无害的按钮或链接，非常小心地放在授权服务器的确认按钮下面。当用户单击误导性可见按钮时，他们实际上是单击授权页面上的隐藏按钮，从而授予对攻击者应用程序的访问权限。这允许攻击者欺骗用户在他们不知情的情况下授予访问权限。</p>
<h5 id="对策-1"><a href="#对策-1" class="headerlink" title="对策"></a>对策</h5><p>通过确保授权URL始终直接在本机浏览器中加载，而不是嵌入在iframe中，可以防止这种攻击。较新的浏览器可以让授权服务器设置HTTP标头，X-Frame-Options旧版浏览器可以使用常见的Javascript“框架破坏”技术。</p>
<h4 id="重定向URL操作"><a href="#重定向URL操作" class="headerlink" title="重定向URL操作"></a>重定向URL操作</h4><p>攻击者可以使用属于已知正常应用程序的客户端ID构建授权URL，将重定向URL设置为攻击者控制下的URL。如果授权服务器未验证重定向URL，并且攻击者使用“令牌”响应类型，则用户将使用URL中的访问令牌返回到攻击者的应用程序。如果客户端是公共客户端，并且攻击者拦截授权码，则攻击者还可以通过授权码交换访问令牌。</p>
<p>另一个类似的攻击是攻击者可以欺骗用户的DNS，并且注册的重定向不是https URL。这将允许攻击者伪装成有效的重定向URL，并以这种方式窃取访问令牌。</p>
<p>“打开重定向”攻击是指授权服务器不需要重定向URL的完全匹配，而是允许攻击者构建将重定向到攻击者网站的URL。无论这是否最终被用于窃取授权码或访问令牌，这也是一个危险，因为它可以用于发起其他无关的攻击。有关Open Redirect攻击的更多详细信息，请访问<code>https://oauth.net/advisories/2014-1-covert-redirect/</code>。</p>
<h4 id="对策-2"><a href="#对策-2" class="headerlink" title="对策"></a>对策</h4><p>授权服务器必须要求应用程序注册一个或多个重定向URL，并且重定向到先前注册的URL必须完全匹配。</p>
<p>授权服务器还应要求所有重定向URL均为https。由于这有时会给开发人员带来负担，特别是在应用程序运行之前，在应用程序处于“开发阶段”时允许非https重定向URL并且只能由开发人员访问，然后要求在发布应用程序之前，重定向URL应更改为https URL。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--客户端注册]]></title>
      <url>/2018/07/13/oauth-guide-8/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>本章是对OAuth服务提供商的指导。</p>
<h3 id="注册新的应用程序"><a href="#注册新的应用程序" class="headerlink" title="注册新的应用程序"></a>注册新的应用程序</h3><p>当开发人员访问您的网站时，他们需要一种方法来创建新的应用程序并获取凭据。通常，您可以让他们在创建应用程序之前创建开发人员帐户，或代表其组织创建帐户。</p>
<p>虽然OAuth 2.0规范不要求您在授予凭据之前特别收集任何应用程序信息，但大多数服务会在发出client_id和client_secret之前收集有关应用程序的基本信息，例如应用程序名称和图标。但是，为了安全起见，您需要开发人员为应用程序注册一个或多个重定向URL，这一点非常重要。重定向URL中对此进行了更详细的说明。</p>
<p>通常，服务收集有关应用程序的信息，例如：</p>
<ul>
<li>应用名称</li>
<li>应用程序的图标</li>
<li>应用程序主页的URL</li>
<li>应用程序的简短描述</li>
<li>应用程序隐私策略的链接</li>
<li>重定向网址列表</li>
</ul>
<p>下面是GitHub用于注册应用程序的界面。在其中，它们收集应用程序名称，主页URL，回调URL和可选描述。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/github_create_new_application_1.png" alt="在Github上创建一个新的应用程序"><br>在GitHub上创建一个新的应用程序</p>
<p>最好向开发人员展示您从中收集的信息是显示给最终用户，还是仅供内部使用。</p>
<p>Foursquare的应用程序注册页面要求提供类似的信息，但他们还要求提供简短的标语和隐私政策URL。这些在授权提示中显示给用户。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/foursquare_create_new_application.png" alt="在Foursquare上创建一个新的应用程序"><br>在Foursquare上创建一个新的应用程序</p>
<p>由于使用隐式授权类型的安全性考虑因素，某些服务（例如Instagram）默认情况下会禁用新应用程序的此授权类型，并要求开发人员在应用程序的设置中明确启用它，如下所示。或者，该服务可以使开发人员选择他们正在创建的应用程序类型（公共或私有），并仅向私有应用程序发出密钥。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/instagram_create_new_application.png" alt="在Instagram上创建一个新的应用程序"><br>在Instagram上创建一个新的应用程序</p>
<p>Instagram还提供了一个说明，指示开发人员不要用可能使应用程序看起来来自Instagram的单词命名他们的应用程序。这也是包含API使用条款链接的优势。</p>
<h3 id="客户端ID和秘钥"><a href="#客户端ID和秘钥" class="headerlink" title="客户端ID和秘钥"></a>客户端ID和秘钥</h3><p>此时，您已构建了应用程序注册页面，您已准备好让开发人员注册该应用程序。当开发人员注册应用程序时，您需要生成客户端ID和可选的密钥。在生成这些字符串时，在安全性和美学方面需要考虑一些重要的事项。</p>
<h4 id="客户端ID"><a href="#客户端ID" class="headerlink" title="客户端ID"></a>客户端ID</h4><p>client_id是应用程序的公共标识符。即使它是公开的，最好是第三方无法猜测，因此许多实现使用类似32字符的十六进制字符串。它在授权服务器处理的所有客户端中也必须是唯一的。如果客户端ID是可猜测的，则可以更轻松地针对任意应用程序进行网络钓鱼攻击。</p>
<p>以下是来自支持OAuth 2.0的服务的客户端ID的一些示例：</p>
<ul>
<li>Foursquare： ZYDPLLBWSK3MVQJSIYHB1OR2JXCY0X2C5UJ2QAR2MAAIT5Q</li>
<li>Github： 6779ef20e75817b79602</li>
<li>Google： 292085223830.apps.googleusercontent.com</li>
<li>Instagram： f2a1ed52710d4533bde25be6da03b6e3</li>
<li>SoundCloud： 269d98e4922fb3895e9ae2108cbb5064</li>
<li>Windows Live： 00000000400ECB04</li>
</ul>
<p>如果开发人员正在创建“公共”应用程序（移动或单页应用程序），那么您根本不应该向应用程序发出client_secret。这是确保开发人员不会意外地将其包含在应用程序中的唯一方法。如果它不存在，它就不会泄露！</p>
<p>因此，您应该询问开发人员在启动时创建的应用程序类型。您可以向他们提供以下选项，并仅为“Web服务器”应用程序发出密钥。</p>
<ul>
<li>Web服务器应用程序</li>
<li>基于浏览器的应用</li>
<li>原生应用</li>
<li>移动应用</li>
</ul>
<p>当然，没有什么可以阻止开发人员选择错误的选项，但是通过主动询问开发人员将使用哪种类型的应用程序，您可以帮助减少泄露秘密的可能性。了解正在创建哪种类型的应用程序的另一个原因是您需要注册公共客户端的重定向URL，但是对于私有客户端，重定向URL的注册在技术上是可选的。有关详细信息，请参阅<a href="https://www.oauth.com/oauth2-servers/redirect-uris/redirect-uri-registration/" target="_blank" rel="noopener">重定向URI注册</a>。</p>
<h4 id="客户端密钥"><a href="#客户端密钥" class="headerlink" title="客户端密钥"></a>客户端密钥</h4><p>client_secret是只有应用程序和授权服务器知道的密钥。它必须足够随机以至于无法猜测，这意味着您应该避免使用常见的UUID库，这些库通常会考虑生成它的服务器的时间戳或MAC地址。生成安全密钥的一个好方法是使用加密安全库生成256位值并将其转换为十六进制表示。</p>
<p>在PHP中，您可以使用OpenSSL函数生成随机字节并转换为十六进制字符串：</p>
<pre><code class="php">bin2hex(openssl_random_pseudo_bytes(32));
</code></pre>
<p>或者在PHP 7及更高版本中，random_bytes可以使用内置函数。</p>
<p>在Ruby中，您可以使用SecureRandom库生成十六进制字符串：</p>
<pre><code class="ruby">require &#39;securerandom&#39;
SecureRandom.hex(32)
</code></pre>
<p>开发人员永远不要将其client_secret公开（基于移动或基于浏览器的）应用程序包含在内是至关重 为了帮助开发人员避免意外地执行此操作，最好使客户端密钥在视觉上与ID不同。这种方式当开发人员复制并粘贴ID和密钥时，很容易识别哪个是哪个。通常使用较长的字符串来表示密钥是一种很好的方式来表明这一点，或者在密钥前加上“密钥”或“私密”。</p>
<h4 id="存储和显示客户端ID和密钥"><a href="#存储和显示客户端ID和密钥" class="headerlink" title="存储和显示客户端ID和密钥"></a>存储和显示客户端ID和密钥</h4><p>对于每个注册的应用程序，您需要存储公共client_id和私有client_secret。因为这些本质上等同于用户名和密码，所以不应以纯文本格式存储密钥，而应仅存储加密或散列版本，以帮助降低秘密泄露的可能性。</p>
<p>当您发出客户端ID和密钥时，您需要将它们显示给开发人员。大多数服务为开发人员提供了一种检索现有应用程序密钥的方法，尽管有些服务只显示一次密钥并要求开发人员立即自行存储。如果您只显示一次密钥，则可以存储它的散列版本以避免存储明文密码。</p>
<p>如果您选择稍后可以向开发人员显示的方式存储密钥，则在披露密钥时应采取额外的预防措施。保护密钥的常用方法是在开发人员尝试检索密钥时插入“重新授权”提示。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/github_confirm_password.png" alt="GitHub重新授权提示"><br>GitHub在进行敏感更改时要求确认您的密码</p>
<p>该服务要求开发人员在泄密之前确认其密码。当您尝试查看或更新敏感信息时，这在Amazon或GitHub的网站中很常见。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/dropbox_show_secret.png" alt="Dropbox&#39;显示秘密&#39;确认"><br>Dropbox会隐藏秘密，直到被点击为止</p>
<p>此外，在开发人员点击“显示”之前模糊应用程序详细信息页面上的密钥是防止意外泄露秘密的好方法。</p>
<h3 id="删除应用程序和撤消秘钥"><a href="#删除应用程序和撤消秘钥" class="headerlink" title="删除应用程序和撤消秘钥"></a>删除应用程序和撤消秘钥</h3><p>开发人员需要一种方法来删除（或至少停用）他们的应用程序。为开发人员提供一种方法来撤销秘钥，并为其应用程序生成新的客户端密钥也是一个好主意。</p>
<h4 id="删除应用程序"><a href="#删除应用程序" class="headerlink" title="删除应用程序"></a>删除应用程序</h4><p>当开发人员删除应用程序时，该服务应通知开发人员删除应用程序的后果。例如，GitHub告诉开发人员将撤销所有访问令牌，以及将受影响的用户数量。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1ftfbpd4ohnj30d106e0tk.jpg" alt="GitHub删除应用程序提示"><br>GitHub要求确认删除申请</p>
<p>删除应用程序应立即撤消颁发给应用程序的所有访问令牌和其他凭据，例如待处理的授权代码和刷新令牌。</p>
<h4 id="撤销秘钥"><a href="#撤销秘钥" class="headerlink" title="撤销秘钥"></a>撤销秘钥</h4><p>该服务应该为开发人员提供重置客户端密钥的方法。在秘钥被意外暴露的情况下，开发人员需要一种方法来确保可以撤销旧秘密。撤销秘密不一定会使用户的访问令牌无效，因为如果开发人员想要使所有用户令牌无效，他们也可以随时删除该应用程序。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1ftfbqqm2vzj30d607kq40.jpg" alt="GitHub重置客户端密码提示"><br>GitHub要求确认重置应用程序的秘钥</p>
<p>重置密钥应该保持所有现有的访问令牌都处于活动状态。但是，这确实意味着使用旧秘钥的任何已部署应用程序将无法使用旧秘钥刷新访问令牌。部署的应用程序需要在能够使用刷新令牌之前更新其秘密。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--进行身份验证请求]]></title>
      <url>/2018/07/13/oauth-guide-7/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>无论您使用哪种授权类型，或者您是否使用了客户端密钥，您现在都可以使用API​​来使用OAuth 2.0 Bearer Token。</p>
<p>API服务器可以通过两种方式接受Bearer Token。一个在HTTP Authorization标头中，另一个在post body参数中。它取决于它支持的服务，因此您需要检查文档以确定。</p>
<p>在HTTP标头中传入访问令牌时，您应该发出如下请求：</p>
<pre><code class="http">POST /resource/1/update HTTP/1.1
Authorization: Bearer RsT5OjbzRn430zqMLgV3Ia&quot;
Host: api.authorization-server.com

description=Hello+World
</code></pre>
<p>如果服务接受帖子正文中的访问令牌，那么您可以发出如下请求：</p>
<pre><code class="http">POST /resource/1/ HTTP/1.1
Host: api.authorization-server.com

access_token=RsT5OjbzRn430zqMLgV3Ia
&amp;description=Hello+World
</code></pre>
<p>请注意，由于OAuth 2.0规范实际上并不需要上面的任何一个选项，因此您必须阅读与之交互的特定服务的API文档，以了解它们是否支持post body参数或HTTP标头。</p>
<p>访问令牌不应由您的应用程序解析。你应用程序唯一应该做的就是使用它来发出API请求。一些服务将使用结构化令牌（如JWT）作为其访问令牌，但客户端在这种情况下无需担心解码令牌。</p>
<p>实际上，尝试解码访问令牌是危险的，因为服务器不保证访问令牌将始终保持相同的格式。完全有可能在下次从服务获得访问令牌时，它将采用不同的格式。要记住的是，访问令牌对客户端是不透明的，并且应该仅用于发出API请求而不是自己解释。</p>
<p>如果您试图找出您的访问令牌是否已过期，您可以存储您第一次获得访问令牌时返回的过期时间，或者只是尝试发出请求查看当前令牌是否过期，并获取新的访问令牌。</p>
<p>如果您正在尝试查找有关登录用户的更多信息，您应该阅读特定服务的API文档以了解他们的建议。例如，Google的API使用OpenID Connect提供userinfo endpoint，该endpoint可以返回有关给定访问令牌的用户的信息。</p>
<h3 id="刷新访问令牌"><a href="#刷新访问令牌" class="headerlink" title="刷新访问令牌"></a>刷新访问令牌</h3><p>当您最初收到访问令牌时，它可能包含刷新令牌以及到期时间，如下例所示。</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;AYjcyMzY3ZDhiNmJkNTY&quot;,
  &quot;refresh_token&quot;: &quot;RjY2NjM5NzA2OWJjuE7c&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;expires&quot;: 3600
}
</code></pre>
<p>刷新令牌的存在意味着访问令牌将过期，您将能够在没有用户交互的情况下获得新令牌。</p>
<p>“expires”值是访问令牌有效的秒数。这取决于令牌服务的提供商，并且可能取决于应用程序或组织自己的策略。您可以使用它来抢先刷新访问令牌，而不是等待带有过期令牌的请求失败。</p>
<p>如果您发出API请求并且令牌已经过期，您将收到一个指示响应。您可以检查此特定错误消息，然后刷新令牌并再次尝试请求。</p>
<p>如果您使用的是基于JSON的API，则可能会返回带有invalid_token错误的JSON错误响应。在一些情况下，WWW-Authenticate header也会出现invalid_token错误。</p>
<pre><code class="http">HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer error=&quot;invalid_token&quot;
  error_description=&quot;The access token expired&quot;
Content-type: application/json

{
  &quot;error&quot;: &quot;invalid_token&quot;,
  &quot;error_description&quot;: &quot;The access token expired&quot;
}
</code></pre>
<p>当您的代码识别出此特定错误时，它可以使用之前收到的刷新令牌向令牌endpoint发出请求，并返回可用于重试原始请求的新访问令牌。</p>
<p>要使用刷新令牌，请向服务的令牌endpoint发出POST请求grant_type=refresh_token，并包括刷新令牌和客户端凭据。</p>
<pre><code class="http">POST /oauth/token HTTP/1.1
Host: authorization-server.com

grant_type=refresh_token
&amp;amp;refresh_token=xxxxxxxxxxx
&amp;amp;client_id=xxxxxxxxxx
&amp;amp;client_secret=xxxxxxxxxx
</code></pre>
<p>响应将是新的访问令牌，也可能包含新的刷新令牌，就像您在交换访问令牌的授权代码时收到的那样。</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;BWjcyMzY3ZDhiNmJkNTY&quot;,
  &quot;refresh_token&quot;: &quot;Srq2NjM5NzA2OWJjuE7c&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;expires&quot;: 3600
}
</code></pre>
<p>如果您没有获得新的刷新令牌，那么这意味着当新的访问令牌到期时，您现有的刷新令牌将继续工作。</p>
<p>请记住，用户可以在任何时候撤销应用程序 ，因此，当刷新访问令牌也失败时，您的应用程序需要能够处理这种情况。此时，您需要再次提示用户进行授权。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--移动和原生应用]]></title>
      <url>/2018/07/13/oauth-guide-6/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>与单页应用程序一样，移动应用程序也无法保持客户机密的机密性。因此，移动应用还必须使用不需要客户端密钥的OAuth流程。当前的最佳做法是使用授权流程以及启动外部浏览器，以确保本机应用程序无法修改浏览器窗口或检查内容。</p>
<p>许多网站都提供移动SDK，为您处理授权过程。对于这些网站，你最好直接使用他们的SDK，因为他们可能用非标准的方式添加增加了他们的API。Google提供了一个名为AppAuth的开源库，它可以处理下面描述的流程的实现细节。它旨在能够与任何实现规范的OAuth 2.0服务器一起使用。如果服务不提供自己的抽象，并且您必须直接使用其OAuth 2.0的endpoint，你就可以参照本节介绍来了解如何使用授权与API进行交互。</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>创建一个“登录”按钮，该按钮将打开SFSafariViewController或启动本机浏览器。您将使用与服务器端应用程序中所述相同的授权请求参数。</p>
<p>对于本机应用程序的重定向URL，在iOS上，应用程序可以注册像<code>org.example.app://</code>这样的自定义URL scheme，只要访问具有该scheme的URL，就会启动应用程序。在Android上，应用程序可以注册URL匹配模式，如果访问了与模式匹配的URL，则会启动本机应用程序。</p>
<h3 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h3><p>在这个例子中，我们将创建一个简单的iPhone应用程序，获取访问虚构API的授权。</p>
<h4 id="应用程序启动授权请求"><a href="#应用程序启动授权请求" class="headerlink" title="应用程序启动授权请求"></a>应用程序启动授权请求</h4><p>要开始授权过程，应用程序应该有一个“登录”按钮。该链接应构建为服务授权endpoint的完整URL。</p>
<p>授权URL通常采用以下格式：</p>
<pre><code class="http">https://authorization-server.com/authorize
?client_id=eKNjzFFjH9A1ysYd
&amp;response_type=code
&amp;redirect_uri=exampleapp://auth
&amp;state=1234zyx
</code></pre>
<p>在这种情况下请注意重定向URL的自定义方案。iOS提供了应用程序注册自定义URL方案的功能。在Android上，应用可以改为匹配特定的网址模式，以便应用在访问特定网址时在应用列表中显示并进行处理。在iOS上，您应该在应用程序的.plist文件中注册您将使用的自定义方案。这将导致设备在访问以您的自定义方案开头的URL时启动您的应用，包括移动版Safari或其他iOS应用。</p>
<p>当用户点击“登录”按钮时，应用程序应用SFSafariViewController打开共享系统cookie的嵌入式浏览器来打开登录URL。WebView在应用程序中使用嵌入式窗口被认为是非常危险的，因为这使用户无法保证他们正在查看服务自己的网站，并且是网络钓鱼攻击的简单来源。通过使用SFSafariViewController共享Safari cookie的API，您可以知道用户是否已经登录该服务。</p>
<h4 id="用户批准该请求"><a href="#用户批准该请求" class="headerlink" title="用户批准该请求"></a>用户批准该请求</h4><p>在被定向到auth服务器时，用户看到如下所示的授权请求。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/sfsafariviewcontroller-example.png" alt="内置浏览器"></p>
<p>嵌入式SFSafariViewController。右上角的“完成”按钮折叠视图并将用户返回到应用程序。</p>
<h4 id="该服务将用户重定向回应用程序"><a href="#该服务将用户重定向回应用程序" class="headerlink" title="该服务将用户重定向回应用程序"></a>该服务将用户重定向回应用程序</h4><p>当用户完成登录后，该服务将重定向回您的应用程序的重定向URL，在这种情况下，该URL具有一个自定义方案，该方案将触发您的应用程序委托的application:openURL:options:方法。Location重定向的标题将类似于以下内容，它将作为url参数传递给您的方法。</p>
<pre><code class="html">org.example.app://auth?state=1234zyx
&amp;code=lS0KgilpRsT07qT_iMOg9bBSaWqODC1g061nSLsa8gV2GYtyynB6A
</code></pre>
<p>然后，您的应用应该从URL解析授权码，交换代码以获取访问令牌，并关闭SFSafariViewController。除了不使用客户端密钥之外，交换访问令牌的代码与授权代码流中的代码相同。</p>
<h3 id="安全考虑因素"><a href="#安全考虑因素" class="headerlink" title="安全考虑因素"></a>安全考虑因素</h3><h4 id="始终打开本机浏览器或使用-SFSafariViewController"><a href="#始终打开本机浏览器或使用-SFSafariViewController" class="headerlink" title="始终打开本机浏览器或使用 SFSafariViewController"></a>始终打开本机浏览器或使用 SFSafariViewController</h4><p>您永远不应该使用OAuth提示打开嵌入式Web视图，因为它无法让用户验证他们正在查看的网页的来源。攻击者会创建一个看起来就像授权网页并将其嵌入到自己的恶意应用程序中的网页，让他们能够窃取用户名和密码。</p>
<h4 id="PKCE"><a href="#PKCE" class="headerlink" title="PKCE"></a>PKCE</h4><p>如果您使用的服务支持PKCE扩展（<a href="https://tools.ietf.org/html/rfc7636" target="_blank" rel="noopener">RFC 7636</a>），那么您应该利用它提供的额外安全性。通常，例如在使用Google OAuth API的情况下，服务提供的本机SDK将透明地处理此问题，因此您无需担心详细信息，并且无需任何额外工作即可从额外的安全性中受益。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--单页应用]]></title>
      <url>/2018/07/13/oauth-guide-5/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>从网页加载Javascript和HTML源代码后，单页应用程序（或基于浏览器的应用程序）将会完全在浏览器中运行。由于浏览器可以使用所有源代码，因此无法保持客户端密钥的机密性，因此这些应用程序不会使用该密钥。该流程与授权代码流完全相同，但在最后一步，授权码在不使用客户端密钥的情况下交换访问令牌。</p>
<p>下图是用户与浏览器进行交互的示例，该浏览器直接向服务发出API请求。在首次从客户端下载Javascript和HTML源代码之后，浏览器会直接向服务发出API请求。在这种情况下，应用程序的服务器永远不会向服务发出API请求，因为所有事情都是直接在浏览器中处理的。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/okta_oauth-diagrams.png" alt="用户的浏览器直接与API服务器通信"></p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权码是客户端交换访问令牌的临时代码。代码本身从授权服务器获得，用户可以查看客户端请求的信息，并批准或拒绝该请求。</p>
<p>Web流程的第一步是请求用户授权。这是通过为用户创建单击的授权请求链接来完成的。</p>
<p>授权URL通常采用以下格式：</p>
<pre><code class="html">https://authorization-server.com/oauth/authorize
  ?client_id=a17c21ed
  &amp;response_type=code
  &amp;state=5ca75bd30
  &amp;redirect_uri=https%3A%2F%2Fexample-app.com%2Fauth
</code></pre>
<p>用户访问授权页面后，服务会向用户显示请求的解释，包括应用程序名称，范围等。如果用户单击“批准”，服务器将重定向回网站，并附带授权码和URL查询字符串中的state值。</p>
<h3 id="授权请求参数"><a href="#授权请求参数" class="headerlink" title="授权请求参数"></a>授权请求参数</h3><p>以下参数用于发出授权请求。</p>
<blockquote>
<p><strong>client_id</strong><br>这client_id是您的应用的标识符。首次向服务注册您的应用程序时，您将收到一个client_id。</p>
<p><strong>response_type</strong><br>response_type设置为code表示您希望以授权码作为响应。</p>
<p><strong>redirect_uri （可选的）</strong><br>该redirect_uri是在规范中可选的，但是有些服务需要它。这是您希望在授权完成后将用户重定向到的URL。这必须与您先前在服务中注册的重定向URL相匹配。</p>
<p><strong>scope （可选的）</strong><br>包括一个或多个范围值以请求其他访问级别。这些值将取决于特定的服务。</p>
<p><strong>state （推荐的）</strong><br>该state参数有两个功能。当用户被重定向回您的应用程序时，您在状态中包含的任何值都将包含在重定向中。这使您的应用程序有机会在被定向到授权服务器的用户和再次返回之间保留数据，例如使用state参数作为会话密钥。这可用于指示在授权完成后应用中要执行的操作，例如，指示在授权后要重定向到应用的哪个页面。这也可以作为CSRF保护机制。当用户重定向回您的应用程序时，请仔细检查状态值是否与您最初设置的值相匹配。这将确保攻击者无法拦截授权流程。</p>
<p>请注意，缺少使用客户端密钥意味着使用state参数对单页应用程序更为重要。</p>
</blockquote>
<h3 id="举个栗子🌰"><a href="#举个栗子🌰" class="headerlink" title="举个栗子🌰"></a>举个栗子🌰</h3><p>以下分步示例说明了对单页应用程序使用授权授予类型。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="应用程序启动授权请求"><a href="#应用程序启动授权请求" class="headerlink" title="应用程序启动授权请求"></a>应用程序启动授权请求</h5><p>应用程序通过制作包含ID的URL以及可选的scope和state来启动流程。该应用程序可以将其放入<code>&lt;a href=&quot;&quot;&gt;</code>标签中。</p>
<pre><code class="html">&lt;a href=&quot;https://authorization-server.com/authorize?response_type=code
     &amp;client_id=mRkZGFjM&amp;state=TY2OTZhZGFk&quot;&gt;Connect Your Account&lt;/a&gt;
</code></pre>
<h5 id="用户批准该请求"><a href="#用户批准该请求" class="headerlink" title="用户批准该请求"></a>用户批准该请求</h5><p>在被定向到auth服务器时，用户看到授权请求。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/oauth-guide/okta_oauth-diagrams-approve.png" alt="示例授权请求"></p>
<p>用户被带到服务并看到请求后，他们将允许或拒绝该请求。如果他们允许请求，他们将被重定向回重定向URL以及查询字符串中的授权码。然后，该应用程序需要交换授权码以获得访问令牌。</p>
<pre><code class="http">https://example-app.com/cb?code=Yzk5ZDczMzRlNDEwY&amp;state=TY2OTZhZGFk
</code></pre>
<p>如果您在初始授权网址中包含“state”参数，则该服务会在用户授权您的应用后将其返回给您。你的应用程序应该将state参数与它在初始请求中创建的state餐素进行比较。这有助于确保您只交换您请求的授权码，防止攻击者使用任意或被盗的授权码重定向到您的回调URL。</p>
<h5 id="交换访问令牌的授权码"><a href="#交换访问令牌的授权码" class="headerlink" title="交换访问令牌的授权码"></a>交换访问令牌的授权码</h5><p>要交换访问令牌的授权码，应用程序会向服务的令牌endpoint发出POST请求。请求将具有以下参数。</p>
<blockquote>
<p><strong>grant_type （需要）</strong><br>该grant_type参数必须设置为“authorization_code”。</p>
<p><strong>code （需要）</strong><br>此参数用于从授权服务器接收的授权代码，该授权代码将位于此请求中的查询字符串参数“code”中。</p>
<p><strong>redirect_uri （可能需要）</strong><br>如果重定向URL包含在初始授权请求中，则它也必须包含在令牌请求中，并且必须相同。某些服务支持注册多个重定向URL，有些服务需要在每个请求上指定重定向URL。请查看服务的文档以了解具体信息。</p>
<p><strong>客户端识别ID（必填）</strong><br>尽管客户端密钥未在此流程中使用，但该请求需要发送客户端ID以识别发出请求的应用程序。这意味着客户端必须将客户端ID包含为POST主体参数，而不是像包含客户端密钥时那样使用HTTP基本认证。</p>
</blockquote>
<pre><code class="http">POST /oauth/token HTTP/1.1
  Host: authorization-endpoint.com
  grant_type=code
  &amp;code=Yzk5ZDczMzRlNDEwY
  &amp;redirect_uri=https://example-app.com/cb
  &amp;client_id=mRkZGFjM
</code></pre>
<h3 id="隐式流程"><a href="#隐式流程" class="headerlink" title="隐式流程"></a>隐式流程</h3><p>有些服务使用隐式流程用于单页面应用程序，而不是允许应用程序毫无限制地使用授权码流程。</p>
<p>隐式流程绕过代码交换步骤，而是将查询字符串片段中的访问令牌立即返回给客户端。</p>
<p>在实践中，只有非常有限的情况需要这样做。几个主要的实现（Keycloak，Deutsche Telekom，Smart Health IT）选择完全避免隐式流程并使用授权码流程。</p>
<p>为了使单页应用程序使用授权码流程，它必须能够向授权服务器发出POST请求。这意味着如果授权服务器位于不同的域上，则服务器将需要支持相应的CORS头。如果不支持CORS头，则服务可以使用隐式流程。</p>
<p>在任何情况下，对于隐式流程以及授权码流程来说，都没有客户端秘钥，服务器必须要求注册重定向URL以保持流程的安全性。</p>
<h4 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h4><p>通过使用“state”参数并将重定向URL限制为可认证客户端，这是授权代码授予无客户端密钥的客户端的唯一安全方法。由于没有使用密钥，除了使用注册的重定向URL之外，没有办法验证客户的身份。这就是为什么您需要使用OAuth 2.0服务预先注册您的重定向网址。</p>
<p>尽管OAuth 2.0规范并不特别要求重定向URL使用TLS加密，但强烈建议您使用它。不需要的唯一原因是因为部署SSL网站对许多开发人员来说仍然是一个障碍，这将阻碍规范的广泛采用。有些API确实需要https作为重定向端点，但许多API仍然没有。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--服务器端应用程序]]></title>
      <url>/2018/07/13/oauth-guide-4/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>服务器端应用程序是处理OAuth 2服务器时遇到的最常见的应用程序类型。这些应用程序在Web服务器上运行，其中应用程序的源代码不可供公众使用，因此他们可以保持其客户端秘钥的机密性。</p>
<p>下图说明了用户与正在与客户端通信的浏览器进行交互的典型示例。客户端和API服务器之间具有单独的安全通信通道。用户的浏览器从不直接向API服务器发出请求，所有内容都先通过客户端。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftf3o8318wj30p006edfx.jpg" alt="应用程序的服务器与API通信"></p>
<p>服务器端应用程序使用<code>authorization_code</code>授权类型。在此流程中，在用户授权应用程序之后，应用程序接收“授权码”，然后它可以交换访问令牌。</p>
<h3 id="授权码授予"><a href="#授权码授予" class="headerlink" title="授权码授予"></a>授权码授予</h3><p>授权码是客户端将为访问令牌交换的临时代码。代码本身从授权服务器获得，其中用户有机会查看客户端请求的信息，并批准或拒绝该请求。</p>
<p>授权码流程与其他授权类型相比具有一些优势。当用户授权应用程序时，会带着URL中的临时代码返回应用程序。应用程序有这个代码来交换访问令牌。当应用程序发出访问令牌请求时，该请求将使用客户端密钥进行身份验证，从而降低攻击者拦截授权码并自行使用它的风险。这也意味着访问令牌永远不会被用户看到，因此这是将令牌传递回应用程序的最安全方式，从而降低令牌泄露给其他人的风险。</p>
<p>Web流程的第一步是请求用户授权。这是通过创建用户单击的授权请求链接来完成的。</p>
<p>授权URL通常采用以下格式：</p>
<pre><code class="http">https://authorization-server.com/oauth/authorize
?client_id=a17c21ed
&amp;response_type=code
&amp;state=5ca75bd30
&amp;redirect_uri=https%3A%2F%2Fexample-app.com%2Fauth
</code></pre>
<p>确切的URL endpoint将由您要连接的服务指定，但参数名称将始终相同。</p>
<p>请注意，在接受服务之前，您很可能首先需要在服务中注册重定向URL。这也意味着您无法根据请求更改重定向网址。相反，您可以使用该state参数来自定义请求。</p>
<p>用户访问授权页面后，该服务会向用户显示请求的说明，包括应用程序名称，范围等。如果用户单击“批准”，则服务器将使用您在查询字符串参数中提供的“code”和相同的“state”参数重定向回应用程序。请务必注意，这不是访问令牌。您可以使用授权码执行的唯一操作是发出获取访问令牌的请求。</p>
<h4 id="授权授予参数"><a href="#授权授予参数" class="headerlink" title="授权授予参数"></a>授权授予参数</h4><p>以下参数用于授予授权。您应该使用以下参数构建一个查询字符串，并将其附加到从其文档中获取的应用程序的授权endpoint后。</p>
<blockquote>
<p><strong>response_type=code</strong><br>response_type设置为code表示您希望将授权码作为响应。</p>
<p><strong>client_id</strong><br>client_id是您的应用的标识符。首次向服务注册您的应用时，您将收到client_id。</p>
<p><strong>redirect_uri （可选的）</strong><br>redirect_uri是可选的，但强烈建议你添加。这是您希望在授权完成后将用户重定向到的URL。这必须与您先前在服务中注册的重定向URL相匹配。</p>
<p><strong>scope （可选的）</strong><br>包括一个或多个范围值（以空格分隔）以请求其他访问级别。它的值取决于特定服务。</p>
<p><strong>state （推荐的）</strong><br>state参数有两个功能。当用户被重定向回您的应用程序时，您在state中包含的任何值都将包含在重定向中。这使您的应用程序有机会在用户被定向到授权服务器和再次返回之间保留数据，例如使用state参数作为会话密钥。也可用于指示在授权完成后应用中要执行的操作，例如，指示在授权后应该重定向到应用的哪个页面。也可以作为CSRF保护机制。当用户重定向回您的应用程序时，请仔细检查state值是否与您最初设置的值相匹配。这将确保攻击者无法拦截授权流程。</p>
</blockquote>
<p>将所有这些查询字符串参数组合到登录URL中，并将用户的浏览器定向到那里。通常，应用程序会将这些参数放入登录按钮，或者从应用程序自己的登录URL发送重定向到此URL。</p>
<h4 id="用户批准该请求"><a href="#用户批准该请求" class="headerlink" title="用户批准该请求"></a>用户批准该请求</h4><p>在用户进入服务并看到请求后，他们将允许或拒绝该请求。如果他们允许请求，他们将带着查询字符串中的授权码，并被重定向回指定的重定向URL。然后，应用程序需要使用此授权码交换访问令牌。</p>
<h4 id="交换访问令牌的授权码"><a href="#交换访问令牌的授权码" class="headerlink" title="交换访问令牌的授权码"></a>交换访问令牌的授权码</h4><p>要使用授权码交换访问令牌，应用程序会向服务的令牌endpoint发出POST请求。请求将具有以下参数。</p>
<blockquote>
<p><strong>grant_type （需要）</strong><br>grant_type参数必须设置为“authorization_code”。</p>
<p><strong>code （需要）</strong><br>查询字符串参数“code”中存放从授权服务器接收的授权码。</p>
<p><strong>redirect_uri （可能需要）</strong><br>如果重定向URL包含在初始授权请求中，则它也必须包含在令牌请求中，并且必须相同。某些服务支持注册多个重定向URL，有些服务需要在每个请求上指定重定向URL。请查看服务的文档以了解具体信息。</p>
</blockquote>
<h4 id="客户端验证（必填）"><a href="#客户端验证（必填）" class="headerlink" title="客户端验证（必填）"></a>客户端验证（必填）</h4><p>该服务将要求客户端在发出访问令牌请求时进行身份验证。通常，服务通过HTTP Basic Auth来进行客户端身份验证，并使用客户端的client_id和client_secret。但是，某些服务通过接受client_id和client_secret作为POST body参数来支持身份验证。检查服务的文档以找出服务所期望的内容，因为OAuth 2.0规范将此决定留给了服务。</p>
<h3 id="示例流程"><a href="#示例流程" class="headerlink" title="示例流程"></a>示例流程</h3><p>以下逐步说明示例使用授权代码授予类型。</p>
<p>步骤：</p>
<ul>
<li>使用应用程序的客户端ID，重定向URL和state参数创建登录链接</li>
<li>用户看到授权提示并批准该请求</li>
<li>用户带着授权码重定向回应用程序的服务器</li>
<li>应用程序使用授权码交换访问令牌</li>
</ul>
<h4 id="应用程序启动授权请求"><a href="#应用程序启动授权请求" class="headerlink" title="应用程序启动授权请求"></a>应用程序启动授权请求</h4><p>应用程序通过制作包含ID，scope和state的URL来启动流程。该应用程序可以将其放入<code>&lt;a href=&quot;&quot;&gt;</code>标签中。</p>
<pre><code class="html">&lt;a href=&quot;https://authorization-server.com/oauth/authorize
?response_type=code&amp;client_id=mRkZGFjM&amp;state=5ca75bd30&quot;&gt;
Connect Your Account&lt;/a&gt;
</code></pre>
<h4 id="用户批准该请求-1"><a href="#用户批准该请求-1" class="headerlink" title="用户批准该请求"></a>用户批准该请求</h4><p>在被定向到auth服务器后，用户会看到下图所示的授权请求。如果用户批准该请求，他们将带着授权码和state参数重定向回应用程序。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftf5fephk0j30kw0bw0t3.jpg" alt="示例授权请求"></p>
<h4 id="服务将用户重定向回应用程序"><a href="#服务将用户重定向回应用程序" class="headerlink" title="服务将用户重定向回应用程序"></a>服务将用户重定向回应用程序</h4><p>服务将用户重定向回发出请求的应用程序。重定向将在URL中包含“code”和原始的“state”参数。</p>
<pre><code class="http">https://example-app.com/cb?code=Yzk5ZDczMzRlNDEwY&amp;state=5ca75bd30
</code></pre>
<h4 id="应用程序使用授权吗交换访问令牌"><a href="#应用程序使用授权吗交换访问令牌" class="headerlink" title="应用程序使用授权吗交换访问令牌"></a>应用程序使用授权吗交换访问令牌</h4><p>该应用程序使用授权码，通过向授权服务器发出POST请求来获取访问令牌。</p>
<pre><code class="http">POST /oauth/token HTTP/1.1
Host: authorization-server.com

code=Yzk5ZDczMzRlNDEwY
&amp;grant_type=code
&amp;redirect_uri=https://example-app.com/cb
&amp;client_id=mRkZGFjM
&amp;client_secret=ZGVmMjMz
</code></pre>
<p>auth服务器验证请求，并返回访问令牌和访问令牌过期时使用的刷新令牌。</p>
<p>响应：</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;AYjcyMzY3ZDhiNmJkNTY&quot;,
  &quot;refresh_token&quot;: &quot;RjY2NjM5NzA2OWJjuE7c&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;expires&quot;: 3600
}
</code></pre>
<h3 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h3><p>有几种情况下，您可能会在授权期间收到错误响应。</p>
<p>错误会通过在返回的重定向URL的查询字符串提示。重定向URL总会有一个错误参数，也可能包含error_description和error_uri。</p>
<p>例如:<br><code>https://example-app.com/cb?error=invalid_scope</code></p>
<p>尽管服务器返回error_description密钥，但错误描述并不打算显示给用户。相反，您应该向用户显示您自己的错误消息。这允许您告诉用户采取适当的措施来纠正问题，并且如果您正在构建多语言网站，还可以让您有机会本地化错误消息。</p>
<h4 id="无效的重定向网址"><a href="#无效的重定向网址" class="headerlink" title="无效的重定向网址"></a>无效的重定向网址</h4><p>如果提供的重定向URL无效，则auth服务器不会重定向到它。相反，它可以向用户显示描述问题的信息。</p>
<h4 id="无法识别-client-id"><a href="#无法识别-client-id" class="headerlink" title="无法识别 client_id"></a>无法识别 client_id</h4><p>如果无法识别客户端ID，则auth服务器不会重定向用户。相反，它可能会显示一条描述问题的信息。</p>
<h4 id="用户拒绝该请求"><a href="#用户拒绝该请求" class="headerlink" title="用户拒绝该请求"></a>用户拒绝该请求</h4><p>如果用户拒绝授权请求，则服务器会将用户重定向包含error=access_denied查询字符串的重定向URL ，并且不会出现code字段。由应用程序决定此时向用户显示的内容。</p>
<h4 id="无效的参数"><a href="#无效的参数" class="headerlink" title="无效的参数"></a>无效的参数</h4><p>如果一个或多个参数无效，例如缺少必需值，或者response_type参数错误，服务器将重定向到重定向URL并包含描述问题的查询字符串参数。</p>
<p>error参数的其他可能值为：</p>
<ul>
<li>invalid_request：请求缺少必需参数，包含无效参数值，或者格式错误。</li>
<li>unauthorized_client：客户端无权使用此方法请求授权码。</li>
<li>unsupported_response_type：授权服务器不支持使用此方法获取授权码。</li>
<li>invalid_scope：请求的范围无效，未知或格式错误。</li>
<li>server_error：授权服务器遇到意外情况，导致无法完成请求。</li>
<li>temporarily_unavailable：由于服务器临时过载或维护，授权服务器当前无法处理请求。</li>
</ul>
<p>此外，服务器可以包括参数error_description和error_uri关于错误的附加信息。</p>
<h3 id="用户体验考虑事项"><a href="#用户体验考虑事项" class="headerlink" title="用户体验考虑事项"></a>用户体验考虑事项</h3><p>为了使授权代码授权生效，授权页面必须出现在用户熟悉的Web浏览器中，并且不得嵌入到iframe弹出窗口或移动到应用程序中的嵌入式浏览器中。因此，对于传统的“Web应用程序”来说，用户已经在Web浏览器中并且重定向到服务器的授权页面的这种操作，是最适用的。</p>
<h3 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h3><p>授权码授权是为可以保护其客户端ID和密钥的客户端设计的。因此，最适合不提供其源代码的在服务器上运行的网络应用程序。</p>
<p>如果应用程序想要使用授权代码授权但无法保护其密钥（即本机移动应用程序），则在请求交换访问令牌的授权代码时就不需要客户端密钥。但是，某些服务不接受没有客户端密钥的授权码交换，因此本机应用程序可能需要为这些服务使用备用方法。</p>
<p>尽管OAuth 2.0规范并不特别要求重定向URL使用TLS加密，但我强烈建议您使用它。不需要的唯一原因是因为部署SSL网站对许多开发人员来说仍然是一个障碍，这将阻碍规范的广泛采用。有些API确实需要https作为重定向端点，但许多API仍然没有这样要求。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--使用Google登录]]></title>
      <url>/2018/07/13/oauth-guide-3/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>尽管OAuth是<strong>授权协议</strong>而不是<strong>身份验证协议</strong>，但它通常用作身份验证工作流程的基础。许多常见OAuth API的典型用途是在登录第三方应用程序时识别当前用户。</p>
<p>身份验证和授权经常相互混淆，但如果从应用程序的角度考虑它们，则可以更容易理解。正在验证用户的应用只是验证用户是谁。授权用户的应用程序正在尝试访问或修改属于该用户的内容。</p>
<p>OAuth被设计为授权协议，因此每个OAuth流程的最终结果是应用程序获取访问令牌，以便能够访问或修改有关用户帐户的内容。访问令牌本身并未说明用户是谁。</p>
<p>有几种方法可以让不同的服务为应用程序提供一种查找用户身份的方法。一种简单的方法是API提供“用户信息”的endpoint，当使用访问令牌访问API时，该endpoint将返回经过身份验证的用户的名称和其他配置文件信息。虽然这不是OAuth标准的一部分，但它是许多服务采用的常见方法。更高级和标准化的方法是使用OAID 2.0扩展的OpenID Connect。OpenID Connect在后面有更详细的介绍。</p>
<p>本章将使用简化的OpenID Connect工作流程和Google API来识别用户并登录到您的应用程序。</p>
<h3 id="创建一个应用程序"><a href="#创建一个应用程序" class="headerlink" title="创建一个应用程序"></a>创建一个应用程序</h3><p>在我们开始之前，我们需要在Google API控制台中创建一个应用程序，以获取客户端ID和客户端秘钥，并注册重定向URL。</p>
<p>访问<code>https://console.developers.google.com/</code>并创建一个新项目。您还需要为项目创建OAuth 2.0凭据，因为Google不会自动执行此操作。在侧栏中，单击“Credentials”选项卡，然后单击“Create credentials”并从下拉列表中选择“OAuth client ID”。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftdy5lw1czj30sg0jwn09.jpg" alt="创建一个应用程序"></p>
<p>Google控制台会提示您提供有关您的应用程序的一些信息，例如产品名称，主页和logo。在下一页上，选择”Web application”类型，然后输入重定向URL。这样，您就会收到客户端ID和秘钥。</p>
<h3 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h3><p>本章节示例代码是用PHP编写的，不需要外部包，也不需要框架，这可以很容易地翻译成其他语言。要模仿此示例代码，您应该将它全部放在一个PHP文件中。</p>
<p>创建一个新文件夹并在该文件夹中创建一个空文件<code>index.php</code>。从该文件夹内部运行的命令行输入<code>php -S localhost:8000</code>，您将能够在浏览器中访问<code>http://localhost:8000</code>来运行您的代码。以下示例中的所有代码都应添加到此index.php文件中。</p>
<p>让我们为OAuth流程设置一些变量，添加我们在创建应用程序时从Google获得的客户端ID和秘钥。</p>
<pre><code class="php">// Fill these out with the values you got from Google
$googleClientID = &#39;&#39;;
$googleClientSecret = &#39;&#39;;

// This is the URL we&#39;ll send the user to first
// to get their authorization
$authorizeURL = &#39;https://accounts.google.com/o/oauth2/v2/auth&#39;;

// This is Google&#39;s OpenID Connect token endpoint
$tokenURL = &#39;https://www.googleapis.com/oauth2/v4/token&#39;;

// The URL for this script, used as the redirect URL
$baseURL = &#39;https://&#39; . $_SERVER[&#39;SERVER_NAME&#39;]
    . $_SERVER[&#39;PHP_SELF&#39;];

// Start a session so we have a place
// to store things between redirects
session_start();
</code></pre>
<p>定义了这些变量，并开始会话，让我们设置登录和注销的页面。我们将显示一个超级简单的页面，它只是指示用户是否已登录，并且具有登录或注销的链接。</p>
<pre><code class="php">// If there is a user ID in the session
// the user is already logged in
if(!isset($_GET[&#39;action&#39;])) {
  if(!empty($_SESSION[&#39;user_id&#39;])) {
    echo &#39;&lt;h3&gt;Logged In&lt;/h3&gt;&#39;;
    echo &#39;&lt;p&gt;User ID: &#39;.$_SESSION[&#39;user_id&#39;].&#39;&lt;/p&gt;&#39;;
    echo &#39;&lt;p&gt;Email: &#39;.$_SESSION[&#39;email&#39;].&#39;&lt;/p&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=logout&quot;&gt;Log Out&lt;/a&gt;&lt;/p&gt;&#39;;

    // Fetch user info from Google&#39;s userinfo endpoint
    echo &#39;&lt;h3&gt;User Info&lt;/h3&gt;&#39;;
    echo &#39;&lt;pre&gt;&#39;;
    $ch = curl_init(&#39;https://www.googleapis.com/oauth2/v3/userinfo&#39;);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
      &#39;Authorization: Bearer &#39;.$_SESSION[&#39;access_token&#39;]
    ]);
    curl_exec($ch);
    echo &#39;&lt;/pre&gt;&#39;;

  } else {
    echo &#39;&lt;h3&gt;Not logged in&lt;/h3&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=login&quot;&gt;Log In&lt;/a&gt;&lt;/p&gt;&#39;;
  }
  die();
}
</code></pre>
<p>已注销的页面包含指向我们的登录的URL链接，该URL用于启动OAuth流程。</p>
<h3 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h3><p>现在我们已经设置了必要的变量，让我们开始OAuth流程。</p>
<p>我们要让人们做的第一件事是,在查询字符串为<code>?action=login</code>时，访问此页面以启动该流程。</p>
<p>请注意，此请求中的scope现在是OpenID Connect的scope，“openid email”，表示我们不是要求访问用户的Google数据，只是想知道他们是谁。</p>
<p>另请注意，我们使用<code>response_type=code</code>参数来指示我们希望Google返回用来交换<code>id_token</code>的授权码。</p>
<pre><code class="php">// Start the login process by sending the user
// to Google&#39;s authorization page
if(isset($_GET[&#39;action&#39;]) &amp;&amp; $_GET[&#39;action&#39;] == &#39;login&#39;) {
  unset($_SESSION[&#39;user_id&#39;]);

  // Generate a random hash and store in the session
  $_SESSION[&#39;state&#39;] = bin2hex(random_bytes(16));

  $params = array(
    &#39;response_type&#39; =&gt; &#39;code&#39;,
    &#39;client_id&#39; =&gt; $googleClientID,
    &#39;redirect_uri&#39; =&gt; $baseURL,
    &#39;scope&#39; =&gt; &#39;openid email&#39;,
    &#39;state&#39; =&gt; $_SESSION[&#39;state&#39;]
  );

  // Redirect the user to Google&#39;s authorization page
  header(&#39;Location: &#39;.$authorizeURL.&#39;?&#39;.http_build_query($params));
  die();
}
</code></pre>
<p>生成用于保护客户端的“state”参数非常重要。这是客户端生成并存储在会话中的随机字符串。当Google将用户发送回应用时，该应用使用state参数来验证是否是它发出的请求。</p>
<p>我们建立一个授权URL，然后将用户发送到那里。该网址包含我们的公共客户ID，我们之前在Google注册的重定向网址，我们要求的scope以及state参数。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1ftdz43ass6j30se0x2wgz.jpg" alt="Google的授权请求"></p>
<p>如果用户已登录Google，他们会看到如上所示的帐户选择页面，要求他们选择现有帐户或使用其他帐户。请注意，此屏幕看起来不像典型的OAuth屏幕，因为用户没有授予应用程序任何权限，而只是尝试识别它们。</p>
<p>当用户选择一个帐户时，他们将被重定向回我们的页面，并在请求中返回code和state参数。下一步是使用Google API验证授权码。</p>
<h3 id="获取ID令牌"><a href="#获取ID令牌" class="headerlink" title="获取ID令牌"></a>获取ID令牌</h3><p>当用户被重定向回我们的应用程序时，查询字符串中将有一个code和state参数。该state参数将与我们在初始授权请求中设置的参数相同，并且在用于我们的应用程序之前，应该检查它是否匹配。这可确保我们的应用不会欺骗Google向攻击者发送授权码。</p>
<pre><code class="php">// When Google redirects the user back here, there will
// be a &quot;code&quot; and &quot;state&quot; parameter in the query string
if(isset($_GET[&#39;code&#39;])) {
  // Verify the state matches our stored state
  if(!isset($_GET[&#39;state&#39;]) || $_SESSION[&#39;state&#39;] != $_GET[&#39;state&#39;]) {
    header(&#39;Location: &#39; . $baseURL . &#39;?error=invalid_state&#39;);
    die();
  }

  // Verify the authorization code
  $ch = curl_init($tokenURL);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
  curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query([
    &#39;grant_type&#39; =&gt; &#39;authorization_code&#39;,
    &#39;client_id&#39; =&gt; $googleClientID,
    &#39;client_secret&#39; =&gt; $googleClientSecret,
    &#39;redirect_uri&#39; =&gt; $baseURL,
    &#39;code&#39; =&gt; $_GET[&#39;code&#39;]
  ]));
  $response = json_decode(curl_exec($ch), true);

  // ... fill in from the code in the next section
}
</code></pre>
<p>此代码首先检查从Google返回的“状态”是否与我们在会话中存储的状态匹配。</p>
<p>我们向Google的令牌endpoint建立了一个POST请求，其中包含我们应用的客户端ID和密码，以及Google在查询字符串中发回给我们的授权码。</p>
<p>Google将验证我们的请求，然后使用访问令牌和ID令牌进行回复。响应将如下所示。</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;ya29.Glins-oLtuljNVfthQU2bpJVJPTu&quot;,
  &quot;token_type&quot;: &quot;Bearer&quot;,
  &quot;expires_in&quot;: 3600,
  &quot;id_token&quot;: &quot;eyJhbGciOiJSUzI1NiIsImtpZCI6ImFmZmM2MjkwN
  2E0NDYxODJhZGMxZmE0ZTgxZmRiYTYzMTBkY2U2M2YifQ.eyJhenAi
  OiIyNzIxOTYwNjkxNzMtZm81ZWI0MXQzbmR1cTZ1ZXRkc2pkdWdzZX
  V0ZnBtc3QuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQi
  OiIyNzIxOTYwNjkxNzMtZm81ZWI0MXQzbmR1cTZ1ZXRkc2pkdWdzZX
  V0ZnBtc3QuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIi
  OiIxMTc4NDc5MTI4NzU5MTM5MDU0OTMiLCJlbWFpbCI6ImFhcm9uLn
  BhcmVja2lAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUs
  ImF0X2hhc2giOiJpRVljNDBUR0luUkhoVEJidWRncEpRIiwiZXhwIj
  oxNTI0NTk5MDU2LCJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2ds
  ZS5jb20iLCJpYXQiOjE1MjQ1OTU0NTZ9.ho2czp_1JWsglJ9jN8gCg
  WfxDi2gY4X5-QcT56RUGkgh5BJaaWdlrRhhN_eNuJyN3HRPhvVA_KJ
  Vy1tMltTVd2OQ6VkxgBNfBsThG_zLPZriw7a1lANblarwxLZID4fXD
  YG-O8U-gw4xb-NIsOzx6xsxRBdfKKniavuEg56Sd3eKYyqrMA0DWnI
  agqLiKE6kpZkaGImIpLcIxJPF0-yeJTMt_p1NoJF7uguHHLYr6752h
  qppnBpMjFL2YMDVeg3jl1y5DeSKNPh6cZ8H2p4Xb2UIrJguGbQHVIJ
  vtm_AspRjrmaTUQKrzXDRCfDROSUU-h7XKIWRrEd2-W9UkV5oCg&quot;
}
</code></pre>
<p>应将访问令牌视为不透明字符串。除了能够使用它来发出API请求之外，它对您的应用程序没有重要意义。</p>
<p>ID令牌具有您的应用可以解析的特定结构，以找出登录者的用户数据。ID令牌是JWT，在OpenID Connect中有更详细的解释。您可以将Google的JWT粘贴到jsonwebtoken.io等网站，以快速向您显示内容。</p>
<h3 id="验证用户信息"><a href="#验证用户信息" class="headerlink" title="验证用户信息"></a>验证用户信息</h3><p>通常，在信任ID令牌中的任何信息之前验证ID令牌至关重要。这是因为通常您的应用会通过不受信任的渠道（例如浏览器重定向）获取ID令牌。</p>
<p>在这种情况下，您使用客户端密钥通过HTTPS连接向Google获取ID令牌，以便向Google进行身份验证，因此您可以确信您获得的ID令牌实际上来自服务商而非攻击者。考虑到这一点，我们可以不加验证的解码ID令牌。谷歌就是这样做的：<code>https://developers.google.com/identity/protocols/OpenIDConnect#obtainuserinfo</code>。</p>
<p>看看上面的JWT。它由三个部分组成，每个部分用一个句点分隔。我们可以在点上分割字符串，然后取出中间部分。中间部分是base64编码的JSON字符串，包含ID令牌数据。以下是JWT中的数据示例。</p>
<pre><code class="json">{
  &quot;azp&quot;: &quot;272196069173.apps.googleusercontent.com&quot;,
  &quot;aud&quot;: &quot;272196069173.apps.googleusercontent.com&quot;,
  &quot;sub&quot;: &quot;110248495921238986420&quot;,
  &quot;hd&quot;: &quot;okta.com&quot;,
  &quot;email&quot;: &quot;aaron.parecki@okta.com&quot;,
  &quot;email_verified&quot;: true,
  &quot;at_hash&quot;: &quot;0bzSP5g7IfV3HXoLwYS3Lg&quot;,
  &quot;exp&quot;: 1524601669,
  &quot;iss&quot;: &quot;https://accounts.google.com&quot;,
  &quot;iat&quot;: 1524598069
}
</code></pre>
<p>我们真正关心的这个演示是两个属性sub和email。sub(subject)属性包含了登录用户的唯一用户标识符。我们会提取它，并将其存储在会话中，这将向我们的应用程序表明用户已经登录。</p>
<p>我们还会在会话中存储ID令牌和访问令牌，以便我们以后可以使用它们，这也是我们获取并显示用户信息的另一种方法。</p>
<pre><code class="php">  // ... continuing from the previous code sample, insert this

  // Split the JWT string into three parts
  $jwt = explode(&#39;.&#39;, $data[&#39;id_token&#39;]);

  // Extract the middle part, base64 decode, then json_decode it
  $userinfo = json_decode(base64_decode($jwt[1]), true);

  $_SESSION[&#39;user_id&#39;] = $userinfo[&#39;sub&#39;];
  $_SESSION[&#39;email&#39;] = $userinfo[&#39;email&#39;];

  // While we&#39;re at it, let&#39;s store the access token and id token
  // so we can use them later
  $_SESSION[&#39;access_token&#39;] = $data[&#39;access_token&#39;];
  $_SESSION[&#39;id_token&#39;] = $data[&#39;id_token&#39;];

  header(&#39;Location: &#39; . $baseURL);
  die();
}
</code></pre>
<p>现在，您将被重定向回应用程序的主页，我们将使用我们在先前创建的代码向您显示用户ID和电子邮件。</p>
<pre><code class="javascript">echo &#39;&lt;p&gt;User ID: &#39;.$_SESSION[&#39;user_id&#39;].&#39;&lt;/p&gt;&#39;;
echo &#39;&lt;p&gt;Email: &#39;.$_SESSION[&#39;email&#39;].&#39;&lt;/p&gt;&#39;;
</code></pre>
<h4 id="使用ID令牌检索用户信息"><a href="#使用ID令牌检索用户信息" class="headerlink" title="使用ID令牌检索用户信息"></a>使用ID令牌检索用户信息</h4><p>Google提供了一个额外的API endpoint，称为tokeninfo endpoint，您可以使用它来查找ID令牌详细信息，而不是自己解析它。这不建议用于生产应用程序，因为它需要额外的HTTP往返，但可用于测试和故障排除。</p>
<p>Google的tokeninfo endpoint<code>https://www.googleapis.com/oauth2/v3/tokeninfo</code>位于其OpenID Connect发现文档中:<code>https://accounts.google.com/.well-known/openid-configuration</code>。要查找我们收到的ID令牌的信息，请使用查询字符串中的ID令牌向tokeninfo endpoint发出GET请求。</p>
<p><code>https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=eyJ</code></p>
<p>响应将是一个JSON对象，其中包含JWT本身包含的类似属性列表。</p>
<pre><code class="json">{
 &quot;azp&quot;: &quot;272196069173.apps.googleusercontent.com&quot;,
 &quot;aud&quot;: &quot;272196069173.apps.googleusercontent.com&quot;,
 &quot;sub&quot;: &quot;110248495921238986420&quot;,
 &quot;hd&quot;: &quot;okta.com&quot;,
 &quot;email&quot;: &quot;aaron.parecki@okta.com&quot;,
 &quot;email_verified&quot;: &quot;true&quot;,
 &quot;at_hash&quot;: &quot;NUuq_yggZYi_2-13hJSOXw&quot;,
 &quot;exp&quot;: &quot;1524681857&quot;,
 &quot;iss&quot;: &quot;https://accounts.google.com&quot;,
 &quot;iat&quot;: &quot;1524678257&quot;,
 &quot;alg&quot;: &quot;RS256&quot;,
 &quot;kid&quot;: &quot;affc62907a446182adc1fa4e81fdba6310dce63f&quot;
}
</code></pre>
<h4 id="使用访问令牌来检索用户信息"><a href="#使用访问令牌来检索用户信息" class="headerlink" title="使用访问令牌来检索用户信息"></a>使用访问令牌来检索用户信息</h4><p>如前所述，许多OAuth 2.0服务还提供endpoint来检索登录用户的用户信息。这是OpenID Connect标准的一部分，endpoint将成为服务的OpenID Connect Discovery文档的一部分。</p>
<p>谷歌的userinfo endpoint是<code>https://www.googleapis.com/oauth2/v3/userinfo</code>。在这种情况下，您使用访问令牌而不是ID令牌来查找用户信息。向该 endpoint发出GET请求，并像执行OAuth 2.0 API请求时那样,在HTTP Header中添加Authorization传递访问令牌。</p>
<pre><code class="http">GET /oauth2/v3/userinfo
Host: www.googleapis.com
Authorization: Bearer ya29.Gl-oBRPLiI9IrSRA70...
</code></pre>
<p>响应将是一个JSON对象，其中包含有关用户的若干属性。响应将始终包含sub密钥，该密钥是用户的唯一标识符。Google还会返回用户的个人资料信息，例如姓名，个人资料照片网址，性别，区域设置，个人资料网址和电子邮件。服务器还可以添加自己的声明，例如Google hd在使用G Suite帐户时显示帐户的“托管域”。</p>
<pre><code class="json">{
 &quot;sub&quot;: &quot;110248495921238986420&quot;,
 &quot;name&quot;: &quot;Aaron Parecki&quot;,
 &quot;given_name&quot;: &quot;Aaron&quot;,
 &quot;family_name&quot;: &quot;Parecki&quot;,
 &quot;picture&quot;: &quot;https://lh4.googleusercontent.com/-kw-iMgD
   _j34/AAAAAAAAAAI/AAAAAAAAAAc/P1YY91tzesU/photo.jpg&quot;,
 &quot;email&quot;: &quot;aaron.parecki@okta.com&quot;,
 &quot;email_verified&quot;: true,
 &quot;locale&quot;: &quot;en&quot;,
 &quot;hd&quot;: &quot;okta.com&quot;
}
</code></pre>
<h4 id="下载示例代码"><a href="#下载示例代码" class="headerlink" title="下载示例代码"></a>下载示例代码</h4><p>您可以从GitHub下载此示例中使用的完整示例代码，网址为<code>https://github.com/aaronpk/sample-oauth2-client</code>。</p>
<p>在用户登录后，您已经看到了三种不同的方式来获取用户的个人资料信息。那么您应该使用哪个以及何时使用？</p>
<p>对于性能敏感的应用程序，您可能在每个请求上读取ID令牌或使用它们来维护会话，您绝对应该在本地验证ID令牌而不是发出网络请求。Google的API文档提供了有关离线验证ID令牌的详细信息的指南。</p>
<p>如果您所做的只是在登录后尝试查找用户的姓名和电子邮件，那么向userinfo endpoint发出API请求是最简单，最直接的选择。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--访问OAuth服务器中的数据]]></title>
      <url>/2018/07/13/oauth-guide-2/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>在本章中，我们将介绍如何在现有OAuth 2.0服务器上访问您的数据。对于此示例，我们将使用GitHub API，并构建一个简单的应用程序，该应用程序将展示出该GitHub登录用户创建的所有库。</p>
<h3 id="创建一个应用程序"><a href="#创建一个应用程序" class="headerlink" title="创建一个应用程序"></a>创建一个应用程序</h3><p>在我们开始之前，我们需要在GitHub上创建一个应用程序，以获取客户端ID和客户端密钥。</p>
<p>在GitHub.com上，从“设置”页面，单击侧栏中的“开发人员设置”链接。您最终将访问<code>https://github.com/settings/developers</code>。从那里，单击“新OAuth应用程序”，您将看到一个简短的表单，如下所示。</p>
<p>填写所需信息，包括回调URL。如果您在本地开发应用程序，则必须使用本地地址作为回调URL。由于GitHub每个应用程序只允许一个注册的回调URL，因此创建两个应用程序非常有用，一个用于开发，另一个用于生产。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1ft8d4v1w2oj318g0v40wo.jpg" alt="在GitHub上注册一个新的OAuth应用程序"></p>
<p>完成此表单后，您将进入一个页面，您可以在其中看到发布到您的应用程序的客户端ID和秘钥，如下所示。</p>
<p>客户端ID被视为公共信息，用于构建登录URL，或者可以包含在网页的Javascript源代码中。客户密钥必须保密。不要将它提交到您的git存储库！</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1ft8dayhs69j316k1vdqcv.jpg" alt="GitHub应用程序已创建"></p>
<h3 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h3><p>此示例代码是用PHP编写的，不需要外部包，也不需要框架。这可以很容易地翻译成其他语言。您可以将它全部放在一个PHP文件中。</p>
<p>创建一个新文件夹并在该文件夹中创建一个空文件<code>index.php</code>。从该文件夹内部运行命令行，<code>php -S localhost:8000</code>，您将能够在浏览器中访问<code>http://localhost:8000</code>来运行您的代码。以下示例中的所有代码都应添加到此index.php文件中。</p>
<p>为了让我们更轻松，让我们定义一个方法，<code>apiRequest()</code>它是一个简单的cURL包装器。此函数将包含GitHub API所需的<code>Accept</code>和<code>User-Agent Header</code>，并自动解码JSON响应。如果我们在会话中有访问令牌，它也会发送带有访问令牌的正确OAuth Header，以便进行经过身份验证的请求。</p>
<pre><code class="php">function apiRequest($url, $post=FALSE, $headers=array()) {
  $ch = curl_init($url);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);

  if($post)
    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($post));

  $headers = [
    &#39;Accept: application/vnd.github.v3+json, application/json&#39;,
    &#39;User-Agent: https://example-app.com/&#39;
  ];

  if(isset($_SESSION[&#39;access_token&#39;]))
    $headers[] = &#39;Authorization: Bearer &#39;.$_SESSION[&#39;access_token&#39;];

  curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);

  $response = curl_exec($ch);
  return json_decode($response, true);
}
</code></pre>
<p>现在让我们设置一些OAuth流程所需的变量。</p>
<pre><code class="php">// Fill these out with the values from Github
$githubClientID = &#39;&#39;;
$githubClientSecret = &#39;&#39;;

// This is the URL we&#39;ll send the user to first
// to get their authorization
$authorizeURL = &#39;https://github.com/login/oauth/authorize&#39;;

// This is the endpoint we&#39;ll request an access token from
$tokenURL = &#39;https://github.com/login/oauth/access_token&#39;;

// This is the Github base URL for API requests
$apiURLBase = &#39;https://api.github.com/&#39;;

// The URL for this script, used as the redirect URL
$baseURL = &#39;https://&#39; . $_SERVER[&#39;SERVER_NAME&#39;]
    . $_SERVER[&#39;PHP_SELF&#39;];

// Start a session so we have a place to
// store things between redirects
session_start();
</code></pre>
<p>首先，让我们设置“登录”和“注销”视图。这将显示一条简单的消息，指示用户是登录还是注销。</p>
<pre><code class="php">// If there is an access token in the session
// the user is already logged in
if(!isset($_GET[&#39;action&#39;])) {
  if(!empty($_SESSION[&#39;access_token&#39;])) {
    echo &#39;&lt;h3&gt;Logged In&lt;/h3&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=repos&quot;&gt;View Repos&lt;/a&gt;&lt;/p&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=logout&quot;&gt;Log Out&lt;/a&gt;&lt;/p&gt;&#39;;
  } else {
    echo &#39;&lt;h3&gt;Not logged in&lt;/h3&gt;&#39;;
    echo &#39;&lt;p&gt;&lt;a href=&quot;?action=login&quot;&gt;Log In&lt;/a&gt;&lt;/p&gt;&#39;;
  }
  die();
}
</code></pre>
<p>已注销的视图包含指向我们的登录URL的链接，该URL启动OAuth流程。</p>
<h3 id="授权请求"><a href="#授权请求" class="headerlink" title="授权请求"></a>授权请求</h3><p>现在我们已经设置了必要的变量，让我们开始OAuth流程。</p>
<p>我们要让人们做的第一件事是,在查询字符串<code>?action=login</code>中访问此页面以启动该过程。</p>
<p>请注意，我们在此请求中要求的范围包括<code>user</code>和<code>public_repo</code>。这意味着该应用程序将能够读取用户配置文件信息以及访问公共存储库。</p>
<pre><code class="php">// Start the login process by sending the user
// to Github&#39;s authorization page
if(isset($_GET[&#39;action&#39;]) &amp;&amp; $_GET[&#39;action&#39;] == &#39;login&#39;) {
  unset($_SESSION[&#39;access_token&#39;]);

  // Generate a random hash and store in the session
  $_SESSION[&#39;state&#39;] = bin2hex(random_bytes(16));

  $params = array(
    &#39;response_type&#39; =&gt; &#39;code&#39;,
    &#39;client_id&#39; =&gt; $githubClientID,
    &#39;redirect_uri&#39; =&gt; $baseURL,
    &#39;scope&#39; =&gt; &#39;user public_repo&#39;,
    &#39;state&#39; =&gt; $_SESSION[&#39;state&#39;]
  );

  // Redirect the user to Github&#39;s authorization page
  header(&#39;Location: &#39;.$authorizeURL.&#39;?&#39;.http_build_query($params));
  die();
}
</code></pre>
<p>生成用于保护客户端的“state”参数非常重要。这是客户端生成并存储在会话中的随机字符串。我们使用state参数作为额外的安全检查，以便当Github将用户发送回查询字符串中的状态时，我们可以验证我们确实发起了此请求，并且它不是发出该请求的攻击者。</p>
<p>我们建立授权URL，然后将用户发送到那里。URL包含我们的公共客户端ID，我们之前在Github上注册的重定向URL，我们要求的范围以及“state”参数。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1ft8difjyjmj30xg1dsjx4.jpg" alt="GitHub的授权请求"></p>
<p>此时，用户将看到Github的OAuth授权提示，如上所示。</p>
<p>当用户批准该请求时，他们将被重定向回我们的页面并在请求中包含code和state参数。下一步是用授权码交换访问令牌。</p>
<h3 id="获取访问令牌"><a href="#获取访问令牌" class="headerlink" title="获取访问令牌"></a>获取访问令牌</h3><p>当用户被重定向回我们的应用程序时，查询字符串中将有一个code和state参数。该state参数将与我们在初始授权请求中设置的参数相同，在我们继续使用应用程序之前应该检查它是否匹配。这可以确保我们的应用程序不会被欺骗向GitHub发送攻击者的授权代码。</p>
<pre><code class="php">// When Github redirects the user back here,
// there will be a &quot;code&quot; and &quot;state&quot; parameter in the query string
if(isset($_GET[&#39;code&#39;])) {
  // Verify the state matches our stored state
  if(!isset($_GET[&#39;state&#39;])
    || $_SESSION[&#39;state&#39;] != $_GET[&#39;state&#39;]) {

    header(&#39;Location: &#39; . $baseURL . &#39;?error=invalid_state&#39;);
    die();
  }

  // Exchange the auth code for an access token
  $token = apiRequest($tokenURL, array(
    &#39;grant_type&#39; =&gt; &#39;authorization_code&#39;,
    &#39;client_id&#39; =&gt; $githubClientID,
    &#39;client_secret&#39; =&gt; $githubClientSecret,
    &#39;redirect_uri&#39; =&gt; $baseURL,
    &#39;code&#39; =&gt; $_GET[&#39;code&#39;]
  ));
  $_SESSION[&#39;access_token&#39;] = $token[&#39;access_token&#39;];

  header(&#39;Location: &#39; . $baseURL);
  die();
}
</code></pre>
<p>在这里，我们向Github的令牌endpoint发送请求，用授权码来交换访问令牌。该请求包含我们的公共客户端ID以及私密客户端密钥。我们还发送与之前相同的重定向URL以及授权码。</p>
<p>如果一切都检出，Github会生成一个访问令牌并在响应中返回它。我们将访问令牌存储在会话中并重定向到主页，并且用户已登录。</p>
<p>GitHub的回复如下所示。</p>
<pre><code class="json">{
  &quot;access_token&quot;: &quot;e2f8c8e136c73b1e909bb1021b3b4c29&quot;,
  &quot;token_type&quot;: &quot;bearer&quot;,
  &quot;scope&quot;: &quot;public_repo,user&quot;
}
</code></pre>
<p>我们的代码已经提取了访问令牌并将其保存在会话中。下次访问该页面时，它会识别出已存在访问令牌并显示我们之前创建的登录页面。</p>
<p>注意：为简单起见，我们在此示例中未包含任何错误处理代码。实际上，您将检查从GitHub返回的错误并向用户显示相应的消息。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OAuth教程--准备工作]]></title>
      <url>/2018/07/13/oauth-guide-1/</url>
      <content type="html"><![CDATA[<p><strong>本文是oauth.com上的教程的翻译。（<a href="https://www.oauth.com" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<blockquote>
<p>前言：</p>
<p>最近在看SSO相关的内容，发现自己对OAuth2.0只是一知半解，阮一峰的文章不错，但是真正用在开发上就远远不够了，于是决定花点时间翻译一下<a href="https://www.oauth.com/" target="_blank" rel="noopener">www.oauth.com</a>上的教程，加深理解。</p>
<p>我真是无语了，文档翻译到一半的时候，oauth.com更新了，醉了醉了，白翻译了十八个章节。</p>
</blockquote>
<p>在本书的第一部分中，我们将介绍在构建与现有OAuth 2.0 API对话的应用程序时需要了解的内容。无论您是构建网络应用程序还是移动应用程序，在开始使用时都需要记住一些事项。</p>
<p>每个OAuth 2.0服务都要求您首先注册一个新应用程序，这通常还要求您首先注册为该服务的开发人员。</p>
<h3 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h3><p>注册过程通常涉及在服务的网站上创建一个帐户，然后输入有关应用程序的基本信息，如名称，网站，logo等。注册申请后，您将获得client_id（在某些情况下也有client_secret），当您的应用与服务互动时，您将使用它们。</p>
<p>创建应用程序时最重要的事情之一是注册应用程序将使用的一个或多个重定向URL。重定向URL是OAuth 2.0服务在应用程序授权之后，将用户返回的位置。注册这些是至关重要的，否则很容易创建可以窃取用户数据的恶意应用程序。本书稍后将对此进行更详细的介绍。</p>
<h3 id="重定向网址和状态"><a href="#重定向网址和状态" class="headerlink" title="重定向网址和状态"></a>重定向网址和状态</h3><p>OAuth 2.0 API仅将用户重定向到已注册的URL，以防止攻击者拦截授权码或访问令牌的重定向攻击。某些服务可能允许您注册多个重定向URL，这在Web应用程序和移动应用程序使用相同的客户端ID、或者在开发和生产服务中使用相同的客户端ID时，将为开发者提供帮助。</p>
<p>为了安全起见，重定向URL必须是https端点，以防止在授权过程中拦截代码。如果您的重定向URL不是https，则攻击者可能能够拦截授权代码并使用它来劫持会话。如果服务允许使用非https重定向，则必须采取额外的预防措施以确保无法进行此类攻击。</p>
<p>大多数服务将重定向URL验证视为完全匹配。这意味着重定向网址<code>https://example.com/auth</code>不匹配<code>https://example.com/auth?destination=account</code>。最佳做法是避免在重定向URL中使用查询字符串参数，并使其仅包含路径。</p>
<p>某些应用程序可能有多个他们想要启动OAuth进程的位置，例如主页上的登录链接以及查看某些公共项目时的登录链接。对于这些应用程序，尝试注册多个重定向URL可能很诱人，或者您可能认为需要能够根据请求更改重定向URL。但请不要这么做，因为OAuth 2.0为此提供了一种机制，即“state”参数。</p>
<p>“state”参数可以用于任何你想要的服务，它是一个对OAuth 2.0服务不透明的字符串。在用户授权应用程序后，将返回您在初始授权请求期间传递的state值。其中一个常见的应用场景是包括一个随机字符串来防止CSRF攻击。您还可以使用JWT之类的技术对重定向URL进行编码，并在用户重定向回应用程序后对其进行解析，以便您在登录后将用户带回适当的位置。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[什么是OAuth？]]></title>
      <url>/2018/06/19/what-is-oauth/</url>
      <content type="html"><![CDATA[<p><strong>本文是Matt Raible的What the Heck is OAuth?的翻译。（<a href="https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<blockquote>
<p>围绕OAuth的实际情况存在很多混淆。</p>
<p>有些人认为OAuth是一种登录流程（就像当您使用Google登录登录应用程序时一样），有些人不假思索的认为OAuth是一种“安全事物”。</p>
<p>我将向您展示OAuth是什么，解释它的工作原理，并希望让您了解OAuth是如何使您的应用受益的。</p>
</blockquote>
<h3 id="什么是OAuth？"><a href="#什么是OAuth？" class="headerlink" title="什么是OAuth？"></a>什么是OAuth？</h3><p>我们先从最顶层的描述说起，OAuth 不是 API或服务：它是授权的开放标准，任何人都可以实施。</p>
<p>更具体地说，OAuth是应用程序可以用来为客户端提供“安全授权访问”的标准。OAuth通过HTTPS工作，并使用access tokens为设备，API，服务器和应用程序授权，而非credentials。</p>
<p>有两种版本的OAuth：<a href="https://tools.ietf.org/html/rfc5849" target="_blank" rel="noopener">OAuth 1.0a</a>和<a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">OAuth 2.0</a>。这些规范是完全不同的，不能一起使用：它们之间没有向后兼容性。</p>
<p>哪一个更受欢迎？如今，OAuth 2.0是最广泛使用的OAuth形式。所以从现在开始，每当我说“OAuth”时，我都在谈论OAuth 2.0–因为它很可能是您将要使用的。</p>
<h3 id="为什么使用OAuth？"><a href="#为什么使用OAuth？" class="headerlink" title="为什么使用OAuth？"></a>为什么使用OAuth？</h3><p>OAuth是对直接身份验证模式的响应。这种模式因HTTP基本认证（Basic Authentication）而闻名，用户会被提示输入用户名和密码。基本身份验证仍然是服务器端应用程序的API身份验证的基本形式：用户发送API密钥ID和密钥，而不是通过每个请求向服务器发送用户名和密码。在OAuth之前，网站会提示您直接在表单中输入用户名和密码，他们会像您一样登录您的数据（例如您的Gmail帐户）。这通常被称为<a href="https://arstechnica.com/information-technology/2010/01/oauth-and-oauth-wrap-defeating-the-password-anti-pattern/" target="_blank" rel="noopener">反密码模式(the password anti-pattern)</a>。</p>
<p>为了为网络创建更好的系统，联合身份为单点登录（SSO）的场景所创建。在这种情况下，终端用户与他们的身份提供者交谈，并且身份提供者生成一个加密签名的token，交给应用程序对用户进行身份验证。应用程序信任身份提供者。只要这种信任关系与登录的断言一起工作，你就登陆成功了。下图显示了这是如何工作的。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/browser_spa_implicit_flow-9f0d10069f4363030e4283679bd4914f9aa47e192b32a166d1e186bdb929e1d2.png" alt="oauth工作流程"></p>
<h3 id="浏览器隐式流程"><a href="#浏览器隐式流程" class="headerlink" title="浏览器隐式流程"></a>浏览器隐式流程</h3><p>联合身份因为由2005年3月15日发布的OASIS标准SAML 2.0而变得知名。它是一个很大的规范，但主要的两个组件是它的身份验证请求协议（又名Web SSO）以及它打包身份属性和签名的方式，称为SAML断言。Okta用SSO chiclets做到这一点。我们发送一条消息，我们在断言中签名，在断言中记录着用户是谁，来自Okta。再加上一个数字签名，你就登录成功了。</p>
<h3 id="SAML"><a href="#SAML" class="headerlink" title="SAML"></a>SAML</h3><p>SAML基本上是浏览器中的会话cookie，可让您访问webapps。如果您想要在Web浏览器之外的各种设备和场景中使用，它将会受到限制。</p>
<p>当SAML 2.0于2005年推出时，它是有道理的。不过，自那以后发生了很多变化。现在我们拥有现代化的网页和原生应用程序开发平台，有单页面应用程序（SPA），如Gmail / Google收件箱，Facebook和Twitter。它们与传统的Web应用程序有不同的行为，因为它们会对API进行AJAX（后台HTTP调用）。移动电话也进行API调用，电视，游戏控制台和物联网设备也一样。SAML SSO在这方面并不是特别优秀。</p>
<h3 id="OAuth和API"><a href="#OAuth和API" class="headerlink" title="OAuth和API"></a>OAuth和API</h3><p>我们构建API的方式也发生了很大变化。在2005年，人们投资于WS- *来构建Web服务。现在，大多数开发人员已经转移到REST和无状态API。简而言之，REST是通过网络推送JSON包的HTTP命令。</p>
<p>开发人员构建了很多API。API经济是您今天可能在会议室听到的常见流行词。公司需要保护其REST API，以允许许多设备访问它们。在过去，您需要输入您的用户名/密码，该应用程序将直接以您的身份登录。这引起了委托授权问题。</p>
<p>“我怎样才能允许应用程序访问我的数据，而不必给我的密码？”</p>
<p>如果您见过以下对话框之一，那就是我们正在谈论的内容。这是一个应用程序，询问您是否可以代表您访问数据。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/biketoworkday-fb-login-f00e39aabbf3e44bc3570333643cbf5d966fc27367dbffd2623ff4a3694831c3.png" alt="Facebook OAuth"></p>
<p>这是OAuth。</p>
<p>OAuth是REST / API的委托授权框架。它使应用程序可以在不泄露用户密码的情况下获取用户数据的有限访问权限（范围）。它将认证(authentication)与授权(authorization)分离开来，并支持多种用例来满足不同的设备功能。它支持服务器到服务器应用程序，基于浏览器的应用程序，移动/本机应用程序和控制台/电视。</p>
<p>对于应用程序来说，你可以把它想成酒店钥匙卡。如果你有酒店钥匙卡，你可以进入你的房间。你如何获得酒店钥匙卡？您必须在前台进行身份验证才能获得。在认证并获得钥匙卡后，您可以访问整个酒店的资源。</p>
<p>简单地说，OAuth就是：</p>
<ul>
<li>应用程序向用户请求授权</li>
<li>用户授权应用程序并提供证据</li>
<li>应用程序向服务器提供授权证明以获取令牌（token）</li>
<li>令牌（token）仅限于访问用户为特定应用程序授权的内容</li>
</ul>
<h3 id="OAuth中央组件"><a href="#OAuth中央组件" class="headerlink" title="OAuth中央组件"></a>OAuth中央组件</h3><p>OAuth建立在以下中心组件之上：</p>
<ul>
<li>作用域和同意书（Scopes and Consent）</li>
<li>扮演者（Actors）</li>
<li>客户端（Clients）</li>
<li>令牌（Tokens）</li>
<li>授权服务器（Authorization Server）</li>
<li>流程（Flows）</li>
</ul>
<h3 id="OAuth作用域"><a href="#OAuth作用域" class="headerlink" title="OAuth作用域"></a>OAuth作用域</h3><p>作用域是您在应用程序请求权限时在授权屏幕上看到的内容。它们是客户在请求令牌时所需求的权限包。这些由应用程序开发人员在编写应用程序时进行编码。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/auth-scope.png" alt="OAuth作用域"></p>
<p>作用域将授权策略的决策与执行分离。这是OAuth的第一个关键方面。权限是中心。它们不会隐藏在应用程序层后面。它们经常在API文档中列出：以下是这个应用程序需要的范围。</p>
<p>你必须获得这一同意。这被称为首次使用的信任。这是网络上非常重要的用户体验变化。OAuth之前的大多数人只是用id和密码对话框。现在你有了这个新的屏幕，你必须训练用户使用。重新调整互联网人口是困难的。从熟悉技术的年轻人到祖父母都有各种各样的用户，他们不熟悉这种流程。这是网络上的一个新概念，现在是前沿和中心。现在你必须授权并征得同意。</p>
<p>同意书可以根据应用程序而有所不同。它可以是时间敏感的作用域范围（日，周，月），但并非所有平台都允许您选择持续时间。当您同意时，需要注意的一点是，该应用程序可以代表您执行某些操作 - 例如，LinkedIn会将您网络中的每个人都发送出去。</p>
<p>OAuth是互联网规模的解决方案，因为它应用于每个应用程序。您经常可以登录到仪表板，查看您授予访问权的应用程序并撤消同意。</p>
<h3 id="OAuth扮演者"><a href="#OAuth扮演者" class="headerlink" title="OAuth扮演者"></a>OAuth扮演者</h3><p>OAuth流程中的角色如下所示：</p>
<ul>
<li>资源所有者：拥有资源服务器中的数据。例如，我是我的Facebook个人资料的资源所有者。</li>
<li>资源服务器：存储应用程序想要访问的数据的API</li>
<li>客户端：想要访问您的数据的应用程序</li>
<li>授权服务器：OAuth的主要引擎<br><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-actor.png" alt="OAuth演员"></li>
</ul>
<p>资源所有者是一个可以使用不同凭据更改的角色。它可以是最终用户，也可以是公司。</p>
<p>客户端可以公开和保密。OAuth命名法中两者之间存在显着的区别。受信任的客户端可以信任存储秘钥。它们不是在桌面上运行，或通过应用商店分发。人们无法对其进行逆向工程并获得密钥。他们在最终用户无法访问的受保护区域运行。</p>
<p>公共客户端是浏览器，移动应用程序和物联网设备。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-client.png" alt="OAuth客户端"></p>
<p>客户端注册也是OAuth的关键组件。这就像OAuth的DMV（车辆管理局）。您需要获取应用程序的牌照。这是您的应用在授权对话框中显示的方式。</p>
<h3 id="OAuth令牌"><a href="#OAuth令牌" class="headerlink" title="OAuth令牌"></a>OAuth令牌</h3><p>访问令牌是客户用来访问资源服务器（API）的令牌。他们的目的是短暂的。想象他们在几个小时和几分钟内，而不是几个月和几个月。你不需要一个机密的客户端来获得访问令牌。您可以使用公共客户端来获取访问令牌。它们旨在优化互联网规模问题。因为这些令牌可以短暂存在并扩展出来，所以它们不能被撤销，你只能等待它们超时。</p>
<p>另一个令牌是刷新令牌。这种寿命要长得多。几天，几个月，几年。这可以用来获得新的令牌。要获得刷新令牌，应用程序通常需要受信任客户端进行身份验证。</p>
<p>刷新令牌可以被撤消。当在仪表板中撤销应用程序的访问时，您正在刷新它的刷新令牌。这使您能够强制客户更新秘钥。您使用刷新令牌获取新的访问令牌，访问令牌通过线路打所有的API资源。当你每次刷新访问令牌时，都会得到一个新的加密签名令牌。更新的开关内置于系统中。</p>
<p>OAuth规范并未定义令牌的含义。它可以以任何你想要的格式。通常情况下，您希望这些令牌是JSON Web Token（一种标准）。简而言之，JWT（发音为“jot”）是令牌认证的安全可靠标准。JWT允许您使用签名对信息进行数字签名(claims)，并可以在稍后使用一个秘密的签名密钥进行验证。要了解关于JWT的更多信息，请参阅<a href="https://stormpath.com/blog/beginners-guide-jwts-in-java" target="_blank" rel="noopener">Java中的JWT初学者指南</a>。</p>
<p>令牌从授权服务器上的endpoint上取回。两个主要endpoint是授权endpoint和令牌endpoint。它们分开用于不同的用例。授权endpoint是您去哪里获得用户同意和授权的地方。这将返回一个授权，表示用户已同意。然后授权被传递给令牌端点。令牌端点处理授权并说“很好，这是您的刷新令牌和您的访问令牌”。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-server.png" alt="授权服务器"></p>
<p>您可以使用访问令牌访问API。一旦到期，您将必须返回带有刷新令牌的令牌端点以获取新的访问令牌。</p>
<p>缺点是这导致了很多开发者的反对。开发人员对OAuth最大的难点之一就是你必须管理刷新令牌。你将状态管理推给每个客户端开发者。你获得了关键轮换的好处，但是你为开发者创造了很多痛苦。这就是开发人员喜欢API密钥的原因。他们可以复制/粘贴它们，将它们放在文本文件中，然后用它们完成。API密钥对开发人员非常方便，但对安全性非常不利。</p>
<p>这是一个代价问题。让开发人员执行OAuth流程可提高安全性，但存在更多的摩擦。工具包和平台有机会简化事情并帮助进行令牌管理。幸运的是，现在OAuth已经非常成熟了，您最喜欢的语言或框架都可能用用于简化OAuth的工具。</p>
<p>我们已经谈了一些关于客户端类型，令牌类型和授权服务器的endpoint以及我们如何将其传递给资源服务器的内容。我提到了两种不同的流程：获得授权和获取令牌。这些不必在同一个通道上发生。前向通道是浏览器的内容。浏览器将用户重定向到授权服务器，用户表示同意。这发生在用户的浏览器上。一旦用户获得授权许可并将其交给应用程序，客户端应用程序就不再需要使用浏览器来完成OAuth流程以获取令牌。</p>
<p>令牌旨在被客户端应用程序使用，以便它可以代表您访问资源。我们称之为后向通道。后向的通道是直接从客户端应用程序到资源服务器的HTTP调用，用于交换令牌的授权许可。这些通道用于不同的流程，具体取决于您拥有的设备功能。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-channel.png" alt="流动通道"></p>
<p>例如，您通过用户代理进行授权的前向通道可能如下所示：</p>
<ul>
<li>资源所有者启动流程来委派对受保护资源的访问</li>
<li>客户端通过浏览器重定向到授权服务器上的授权端点，向所需范围发送授权请求</li>
<li>授权服务器返回一个同意对话框，指出“您是否允许此应用程序访问这些范围？”当然，您需要向应用程序进行身份验证，所以如果您未通过资源服务器的身份验证，它会询问你登录。如果您已经有了一个缓存的会话cookie，您只会看到同意对话框。查看同意对话框，并同意。</li>
<li>授权许可通过浏览器重定向传递回应用程序。这一切都发生在前向通道。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/front-channel.png" alt="前向通道"></p>
<p>这种流程中也存在一种称为隐式流程的变化。我们稍后再讨论。</p>
<p>这就是它在请求中的样子。</p>
<p><strong>Request</strong></p>
<blockquote>
<p>GET <a href="https://accounts.google.com/o/oauth2/auth?scope=gmail.insert" target="_blank" rel="noopener">https://accounts.google.com/o/oauth2/auth?scope=gmail.insert</a> gmail.send<br>&amp;redirect_uri=<a href="https://app.example.com/oauth2/callback" target="_blank" rel="noopener">https://app.example.com/oauth2/callback</a><br>&amp;response_type=code&amp;client_id=812741506391<br>&amp;state=af0ifjsldkj</p>
</blockquote>
<p>这是一个带有一堆查询参数的GET请求（不是出于示例目的的URL编码）。范围来自Gmail的API。redirect_uri是当授权完成时，所返回的客户端应用程序的URL。这应该与客户注册过程（在DMV处）的值相匹配。您不希望授权被退回到外部应用程序。响应类型会改变OAuth流向。客户端ID也来自注册过程。国家是一个安全标志，类似于XRSF。要了解有关XRSF的更多信息，请参阅<a href="https://dzone.com/articles/cross-site-request-forgery" target="_blank" rel="noopener">DZone的“跨站请求伪造解释”</a>。</p>
<p><strong>Response</strong></p>
<blockquote>
<p>HTTP/1.1 302 Found<br>Location: <a href="https://app.example.com/oauth2/callback?" target="_blank" rel="noopener">https://app.example.com/oauth2/callback?</a><br>code=MsCeLvIaQm6bTrgtp7&amp;state=af0ifjsldkj</p>
<p><em>code</em>返回授权认证，<em>state</em>确保它不是伪造的，即它是由同一个请求发出。</p>
</blockquote>
<p>前向通道完成后，会进行前向通道，并将授权码交换为访问令牌。</p>
<p>客户端应用程序使用受信任的客户端凭证和客户端ID访问授权服务器上的令牌endpoint，并发送访问令牌请求。该过程交换访问令牌和（可选）刷新令牌的授权代码授权。客户端使用访问令牌访问受保护的资源。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/back-channel.png" alt="后向通道流"></p>
<p>下面是其在HTTP中的样子。</p>
<p><strong>Request</strong></p>
<blockquote>
<p>POST /oauth2/v3/token HTTP/1.1<br>Host: www.googleapis.com<br>Content-Type: application/x-www-form-urlencoded</p>
<p>code=MsCeLvIaQm6bTrgtp7&amp;client_id=812741506391&amp;client_secret={client_secret}&amp;redirect_uri=<a href="https://app.example.com/oauth2/callback&amp;grant_type=authorization_code" target="_blank" rel="noopener">https://app.example.com/oauth2/callback&amp;grant_type=authorization_code</a></p>
</blockquote>
<p>grant_type是OAuth的可扩展性部分。这是来自预先获得的授权代码。它开辟了用不同方式来描述这些授权的灵活性。这是最常见的OAuth流程类型。</p>
<p><strong>Response</strong></p>
<blockquote>
<p>{<br>  “access_token”: “2YotnFZFEjr1zCsicMWpAA”,<br>  “token_type”: “Bearer”,<br>  “expires_in”: 3600,<br>  “refresh_token”: “tGzv3JOkF0XG5Qx2TlKWIA”<br>}</p>
</blockquote>
<p>响应是JSON。您可以在使用令牌时具有反应性或主动性。主动性是在你的客户端有一个计时器。反应性是捕捉一个错误，然后尝试获取新的令牌。</p>
<p>一旦获得访问令牌，就可以在验证头中使用访问令牌（使用token_type前缀）来提出受保护的资源请求。</p>
<blockquote>
<p>curl -H “Authorization: Bearer 2YotnFZFEjr1zCsicMWpAA” \<br>  <a href="https://www.googleapis.com/gmail/v1/users/1444587525/messages" target="_blank" rel="noopener">https://www.googleapis.com/gmail/v1/users/1444587525/messages</a></p>
</blockquote>
<p>所以现在你有一个前向通道，一个后向通道，不同的终端和不同的客户端。你必须为不同的用例进行混合和匹配。这增加了OAuth的复杂性，并且可能会引起混淆。</p>
<h3 id="OAuth流程"><a href="#OAuth流程" class="headerlink" title="OAuth流程"></a>OAuth流程</h3><p>第一个流程就是我们所说的<strong>隐式流程（Implicit Flow）</strong>。它被称为隐式流的原因是因为所有的通信都是通过浏览器进行的。没有后端服务器为访问令牌兑换授权许可。SPA是这个流程用例的一个很好的例子。该流程也称为2 Legged OAuth。</p>
<p>隐式流程针对仅限于浏览器的公共客户端进行了优化。访问令牌直接从授权请求中返回（仅限于前向通道）。它通常不支持刷新标记。它假定资源所有者和公共客户端位于同一设备上。由于所有事情都发生在浏览器上，它最容易受到安全威胁的影响。</p>
<p>黄金标准是<strong>授权代码流程（Authorization Code Flow）</strong>，又名3 Legged，它同时使用前向通道和后向通道。这就是我们在本文中讨论最多的内容。客户端应用程序使用前向通道流获取授权码授权。客户端应用程序使用后向通道交换访问令牌（以及可选的刷新令牌）的授权代码授权。它假定资源所有者和客户端应用程序位于不同的设备上。这是最安全的流程，因为您可以验证客户端以兑换授权授权，令牌永远不会通过用户代理。不仅有隐式流程和授权码流程，您还可以使用OAuth执行额外的流程。因此，OAuth更像是一个框架。</p>
<p>对于服务器到服务器方案，您可能需要使用<strong>客户端凭证流程（Client Credential Flow）</strong>。在这种情况下，客户端应用程序是一个受信任的客户端，它自己独立运行，而不是代表用户。它更像是一种服务帐户类型的场景。您所需要的只是客户的凭证来完成整个流程。这是一个仅使用客户凭证获取访问令牌的后向通道。它支持共享秘钥或断言，作为使用对称或非对称密钥签名的客户端凭证。</p>
<p>对称密钥算法是加密算法，只要您有密码，就可以解密任何内容。这通常在保护PDF或.zip文件时发现。</p>
<p>公钥加密或非对称加密是使用密钥对的任何加密系统：公钥和私钥。公钥可以被任何人读取，私钥对于所有者来说是神圣的。这使得数据安全无需分享密码。</p>
<p>还有一种传统模式称为<strong>资源所有者密码流程（Resource Owner Password Flow）</strong>。这与使用用户名和密码方案的直接身份验证非常相似，不推荐使用。它是原生用户名/密码应用程序（如桌面应用程序）的传统授权类型。在此流程中，您向客户端应用程序发送用户名和密码，并从授权服务器返回访问令牌。它通常不支持刷新令牌，并且假定资源所有者和公共客户端位于同一设备上。</p>
<p>对OAuth的最新补充是<strong>断言流程（Assertion Flow）</strong>，它与客户端证书流程类似。这是为了打开联合认证的想法。该流程允许授权服务器信任来自第三方的授权许可，如SAML IdP。授权服务器信任身份提供商。该断言用于从令牌endpoint获取访问令牌。这对于那些投资SAML或SAML相关技术并允许他们与OAuth集成的公司来说非常有用。由于SAML断言是短暂的，因此此流程中不存在刷新标记，并且每次断言到期时都必须继续检索访问标记。</p>
<p>不在OAuth规范中的，是<strong>设备流程（Device Flow）</strong>。没有网络浏览器，只有一个像电视一样的控制器。用户code是从授权请求返回的，必须通过浏览器上的URL访问授权请求才能进行授权。客户端应用程序使用后向通道流程来轮询访问令牌和可选刷新令牌的授权许可。这种方式也在CLI客户端中很受欢迎。</p>
<p>我们已经使用不同的角色和标记类型介绍了六种不同的流程。由于客户端的能力，我们需要获得客户端的同意书，以及了解谁正在征求同意，这些都是必要的，并且为OAuth增加了很多复杂性。</p>
<p>当人们问你是否支持OAuth时，你必须澄清他们要求的东西。他们问你是支持全部六个流程，还是只支持主流程？在所有不同的流程之间有很多可用的粒度。</p>
<h3 id="安全和企业"><a href="#安全和企业" class="headerlink" title="安全和企业"></a>安全和企业</h3><p>OAuth有很大的覆盖面。有了隐式流程，就有很多重定向和很多错误空间。有很多人试图在应用程序之间利用OAuth，如果你不遵循推荐的网络安全101准则，就很容易做到。例如：</p>
<ul>
<li>始终使用带state参数的CSRF令牌来确保流程完整性</li>
<li>始终将重定向URI列入白名单，以确保正确的URI验证</li>
<li>将同一客户端绑定到具有客户端ID的授权许可和令牌请求</li>
<li>对于受信任的客户，确保客户机密不泄露。不要把你的应用程序中的客户端秘密通过App Store分发！</li>
</ul>
<p>关于OAuth的最大抱怨一般来自安全人员。这是关于Bearer tokens，并且他们可以像会话cookie一样传递。您可以将它传递出去，而且您可以很好地进行操作，而不是以加密方式绑定到用户。使用JWT有助于避免被篡改。但是，最终，JWT只是一串字符，因此它们可以轻松复制并用于Authorization标题中。</p>
<h3 id="企业OAuth-2-0使用案例"><a href="#企业OAuth-2-0使用案例" class="headerlink" title="企业OAuth 2.0使用案例"></a>企业OAuth 2.0使用案例</h3><p>OAuth将授权策略决策与身份验证分离开来。它可以正确地混合细粒度和粗粒度的授权。它可以取代传统的Web访问管理（WAM）策略。在构建可访问特定API的应用程序时，限制和撤销权限也很好。它确保只有托管或兼容的设备才能访问特定的API。它与身份取消配置工作流程深度集成，以撤消用户或设备的所有令牌。最后，它支持与身份提供者的联合。</p>
<h3 id="OAuth不是身份验证协议"><a href="#OAuth不是身份验证协议" class="headerlink" title="OAuth不是身份验证协议"></a>OAuth不是身份验证协议</h3><p>总结一下OAuth 2.0的一些误解：它不与OAuth 1.0向后兼容。它用HTTPS替代所有通信的签名。今天人们谈论OAuth时，他们正在谈论OAuth 2.0。</p>
<p>由于OAuth是授权框架而不是协议，因此您可能会遇到互操作性问题。团队如何实施OAuth有很多差异，您可能需要自定义代码才能与供应商进行集成。</p>
<p>OAuth 2.0不是身份验证协议。它甚至在<a href="https://oauth.net/articles/authentication/" target="_blank" rel="noopener">文档</a>中都这么说。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oauth-not-authentication.png" alt="OAuth 2.0不是身份验证协议"></p>
<p>我们一直在谈论授权。这不是关于验证用户，这是关键。仅对于OAuth 2.0来说，用户是不存在的。您只需拥有一个令牌即可访问资源。</p>
<p>在过去的几年中，OAuth发生了大量的增加。这些增加了OAuth之上的复杂性，以完成各种企业方案。例如，JWT可以用作可签名和加密的互操作令牌。</p>
<h3 id="使用OAuth-2-0进行伪身份验证"><a href="#使用OAuth-2-0进行伪身份验证" class="headerlink" title="使用OAuth 2.0进行伪身份验证"></a>使用OAuth 2.0进行伪身份验证</h3><p>Facebook Connect和Twitter让着名的OAuth登录成为了热门话题。在此流程中，客户端使用/me的endpoint访问获取令牌。它所说的是，客户端可以使用令牌访问资源。人们发明了这个假端点，作为用访问令牌取回用户配置文件的一种方式。这是获取用户信息的非标准方式。标准中没有任何人说每个人都必须实现这个端点。访问令牌意味着不透明。它们是为了API而设计的，它们不是为了包含用户信息而设计的。</p>
<p>你真正尝试验证与回答的问题应该是：这是谁的用户，有没有对用户进行认证，以及如何做的用户进行身份验证。您通常可以通过SAML断言来回答这些问题，而不是使用访问令牌和授权许可。这就是我们称之为伪认证的原因。</p>
<h3 id="输入OpenID-Connect"><a href="#输入OpenID-Connect" class="headerlink" title="输入OpenID Connect"></a>输入OpenID Connect</h3><p>为解决伪身份验证问题，将OAuth 2.0，Facebook Connect和SAML 2.0的最佳部分组合在一起，创建OpenID Connect。OpenID Connect（OIDC）扩展了OAuth 2.0，id_token为客户端和UserInfo endpoint提供了新的用户属性签名。与SAML不同，OIDC为身份提供了一套标准范围和声明。例子包括：profile，email，address，和phone。</p>
<p>OIDC的创建是为了使网络具有完全动态的可扩展性。不再需要像SAML那样下载元数据和联合认证。内置的动态联合认证可以注册，发现元数据。您可以输入您的电子邮件地址，然后它动态地发现您的OIDC提供商，动态下载元数据，动态地知道它将使用的证书，并允许BYOI(Bring Your Own Identity)。它支持企业的高保证级别和关键SAML使用案例。</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/openid-connect-protocol.png" alt="OpenID连接协议套件"></p>
<p>OIDC因谷歌和微软两大早期使用者而闻名。Okta也在OIDC上投入了大量资金。</p>
<p>初始请求中的变化就是它包含标准作用域（如openid和email）：</p>
<p><strong>Request</strong></p>
<blockquote>
<p>GET <a href="https://accounts.google.com/o/oauth2/auth?" target="_blank" rel="noopener">https://accounts.google.com/o/oauth2/auth?</a><br>scope=openid email&amp;<br>redirect_uri=<a href="https://app.example.com/oauth2/callback&amp;" target="_blank" rel="noopener">https://app.example.com/oauth2/callback&amp;</a><br>response_type=code&amp;<br>client_id=812741506391&amp;<br>state=af0ifjsldkj</p>
</blockquote>
<p><strong>Response</strong></p>
<blockquote>
<p>HTTP/1.1 302 Found<br>Location: <a href="https://app.example.com/oauth2/callback?" target="_blank" rel="noopener">https://app.example.com/oauth2/callback?</a><br>code=MsCeLvIaQm6bTrgtp7&amp;state=af0ifjsldkj</p>
<p><em>code</em>返回授权认证，<em>state</em>确保它不是伪造的，即它是由同一个请求发出。</p>
</blockquote>
<p>而授权获取令牌的响应包含一个ID令牌。</p>
<p><strong>Request</strong>    </p>
<blockquote>
<p>POST /oauth2/v3/token HTTP/1.1<br>Host: www.googleapis.com<br>Content-Type: application/x-www-form-urlencoded</p>
<p>code=MsCeLvIaQm6bTrgtp7&amp;client_id=812741506391&amp;<br>  client_secret={client_secret}&amp;<br>  redirect_uri=<a href="https://app.example.com/oauth2/callback&amp;" target="_blank" rel="noopener">https://app.example.com/oauth2/callback&amp;</a><br>  grant_type=authorization_code</p>
</blockquote>
<p><strong>Response</strong></p>
<blockquote>
<p>{<br>  “access_token”: “2YotnFZFEjr1zCsicMWpAA”,<br>  “token_type”: “Bearer”,<br>  “expires_in”: 3600,<br>  “refresh_token”: “tGzv3JOkF0XG5Qx2TlKWIA”,<br>  “id_token”: “eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ…”<br>}</p>
</blockquote>
<p>您可以看到，在OAuth之上很好地分层，将ID令牌作为结构化令牌返回。一个ID令牌是一个JSON Web令牌（JWT）。JWT（aka“jot”）比基于XML的巨大SAML断言小得多，可以在不同设备之间高效传递。JWT有三部分：标题(header)，正文(body)和签名(signature)。标题说明使用什么算法对它进行签名，声明(claims)在正文中，并且在签名中签名。</p>
<p>Open ID Connect流程涉及以下步骤：</p>
<ul>
<li>发现OIDC元数据</li>
<li>执行OAuth流程以获取id令牌和访问令牌</li>
<li>获取JWT签名密钥并可选择动态注册客户端应用程序</li>
<li>根据内置日期和签名在本地验证JWT ID令牌</li>
<li>根据需要使用访问令牌获取其他用户属性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/what-is-oauth/oidc-flow.png" alt="OIDC流程"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OAuth 2.0是委托访问API的授权框架。它涉及请求资源所有者授权/同意的范围的客户端。授权授予交换访问令牌和刷新令牌（取决于流程）。有多种流程来解决不同的客户端和授权方案。JWT可用于授权服务器和资源服务器之间的结构化令牌。</p>
<p>OAuth具有非常大的安全覆盖面。确保使用安全工具包并验证所有输入！</p>
<p>OAuth不是身份验证协议。OpenID Connect针对身份验证方案扩展了OAuth 2.0，通常称为“带花括号的SAML”。如果您希望进一步深入了解OAuth 2.0，我建议您查看<a href="https://www.oauth.com/" target="_blank" rel="noopener">OAuth.com</a>，使用Okta的Auth SDK进行测试，然后尝试自己的OAuth流程。</p>
]]></content>
      
        <categories>
            
            <category> OAuth </category>
            
            <category> OIDC </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OAuth </tag>
            
            <tag> OIDC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用gradle构建Java 9模块化系统快速指南]]></title>
      <url>/2018/04/11/gradle-guide-java9/</url>
      <content type="html"><![CDATA[<p><strong>本文是gradle官方的构建Java 9模块化系统的入门指南的翻译。（<a href="https://guides.gradle.org/building-java-9-modules/?_ga=2.174270880.30455902.1522735364-1287880600.1513842256" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<p>Java 9最令人兴奋的特性之一是它支持开发和部署Java模块化系统。在本指南中，您将了解到如何用gradle实现模块化功能，你所要做的事情：</p>
<ol>
<li>为您的Java库生成Java 9模块。</li>
<li>使用Java 9模块作为您的依赖。</li>
<li>在Java 9模块中使用Java的ServiceLoader模式。</li>
<li>使用Java 9模块运行应用程序。</li>
<li>使用一个插件来更简单地完成以上功能。</li>
</ol>
<p>虽然Gradle 4.6版尚未对Java 9模块提供一流的支持，本指南仍将向您介绍如何在支持完成之前对Java 9进行试验性的工作。</p>
<h3 id="你需要什么"><a href="#你需要什么" class="headerlink" title="你需要什么"></a>你需要什么</h3><ol>
<li>大约41分钟</li>
<li>一个文本编辑器</li>
<li>一个命令提示符</li>
<li>Java开发工具包（JDK），版本1.9（版本174）+</li>
</ol>
<h3 id="了解示例项目"><a href="#了解示例项目" class="headerlink" title="了解示例项目"></a>了解示例项目</h3><p>本指南逐步说明，如何将不使用任何Java 9功能的Java应用程序，转换为完全模块化的Java 9应用程序。原始版本的应用程序的源代码位于src/0-original目录中。它是由六个子项目组成的gradle多项目程序：</p>
<ol>
<li>fairy - java应用程序storyteller的入口点。</li>
<li>tale - 公共Tale接口的库。</li>
<li>formula - 帮助改造Tale接口的库。</li>
<li>actors - fairy tale中所有characters的库。</li>
<li>pigs - 代表三个小猪的Tale实例的库。</li>
<li>bears - 代表金发姑娘和三只熊的Tale实例的库。</li>
</ol>
<p>六个项目之间依赖关系的项目层次结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/gradle_guide_java9/project-graph.png" alt="gradle-java9-1"></p>
<p>如果你对api和implementation不熟悉，请参阅在Gradle 3.5中加入的<a href="https://docs.gradle.org/current/userguide/java_library_plugin.html?_ga=2.204456536.934686470.1523424544-1287880600.1513842256" target="_blank" rel="noopener">Java Library Plugin</a></p>
<p>你可以克隆源代码来查看原始项目的输出：</p>
<pre><code class="bash">$ git clone https://github.com/gradle-guides/building-java-9-modules.git
$ cd building-java-9-modules/src/0-original
$ ./gradlew run

&gt; Task :fairy:run
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

&lt;... elided ...&gt;

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.


BUILD SUCCESSFUL
</code></pre>
<p>在开始修改此项目以使其使用Java 9模块之前，您需要了解项目结构的两个重要细节，就是，它使用 ServiceLoader API来在运行时加载fairy tale，并且它包含一个测试类来显示在使用Java 9之前，软件的模块封装是多么的脆弱。</p>
<h4 id="ServiceLoader的用法"><a href="#ServiceLoader的用法" class="headerlink" title="ServiceLoader的用法"></a>ServiceLoader的用法</h4><p>Java 1.6引入了一种简单的机制，用于在运行时将一些接口（“Service”）的一组实现绑定到一个消费类。有关该特性的<a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html" target="_blank" rel="noopener">Oracle教程</a>有点冗长，下面是它在示例应用程序中的使用方式：</p>
<pre><code class="java">public static void main(String[] args) {
        ServiceLoader&lt;Tale&gt; loader = ServiceLoader.load(Tale.class);
        if (!loader.iterator().hasNext()) {
            System.out.println(&quot;Alas, I have no tales to tell!&quot;);
        }
        for (Tale tale : loader) {
            tale.tell();
        }
    }
</code></pre>
<p>JVM中的类加载器用ServiceLoader来找出，类路径上META-INF/services文件夹中的，名为org.gradle.fairy.tale.Tale的指定Tale类。</p>
<p>ears/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale:</p>
<pre><code class="java">org.gradle.fairy.tale.bears.GoldilocksAndTheThreeBears
</code></pre>
<p>pigs/src/main/resources/META-INF/services/org.gradle.fairy.tale.Tale:</p>
<pre><code class="java">org.gradle.fairy.tale.pigs.ThreeLittlePigs
</code></pre>
<p>在运行时加载这些实例,会使StoryTeller类以松耦合的方式连接到实现该Tale接口的两个库。你可以在应用程序的build.gradle文件的dependencies块中看到它。</p>
<p>fairy/build.gradle:</p>
<pre><code class="gradle">dependencies {
    implementation project(&#39;:tale&#39;)

    runtimeOnly project(&#39;:pigs&#39;)
    runtimeOnly project(&#39;:bears&#39;)
}
</code></pre>
<p>注释掉以runtimeOnly开头的两行，并注意Gradle run任务的输出是如何改变的：</p>
<pre><code class="bash">$ ./gradlew run

&gt; Task :fairy:run
Alas, I have no tales to tell!


BUILD SUCCESSFUL
</code></pre>
<h4 id="模块化测试讨论"><a href="#模块化测试讨论" class="headerlink" title="模块化测试讨论"></a>模块化测试讨论</h4><p>在最初的项目中，有一个测试类，展现了在Java 9之前的Java版本中，未实施模块化的一些问题。<br>formula/src/test/java/org/gradle/fairy/tale/formula/ModularityTest.java：</p>
<pre><code class="java">    @Test
    public void canReachActor() {
        Actor actor = Imagination.createActor(&quot;Sean Connery&quot;);
        assertEquals(&quot;Sean Connery&quot;, actor.toString());
    }

    @Test
    public void canDynamicallyReachDefaultActor() throws Exception {
        Class clazz = ModularityTest
            .class.getClassLoader()
            .loadClass(&quot;org.gradle.actors.impl.DefaultActor&quot;);
        Actor actor = (Actor) clazz.getConstructor(String.class)
            .newInstance(&quot;Kevin Costner&quot;);
        assertEquals(&quot;Kevin Costner&quot;, actor.toString());
    }

    @Test
    public void canReachDefaultActor() {
        Actor actor = new org.gradle.actors.impl.DefaultActor(&quot;Kevin Costner&quot;);
        assertEquals(&quot;Kevin Costner&quot;, actor.toString());
    }

    /*
    @Test
    public void canReachGuavaClasses() {
        // This line would throw a compiler error because gradle has kept the implementation dependency &quot;guava&quot;
        // from leaking into the formula project.
        Set&lt;String&gt; strings = com.google.common.collect.ImmutableSet.of(&quot;Hello&quot;, &quot;Goodbye&quot;);
        assertTrue(strings.contains(&quot;Hello&quot;));
        assertTrue(strings.contains(&quot;Goodbye&quot;));
    }
    */
</code></pre>
<p>这个类的四个测试有不同的目的：</p>
<ol>
<li>canReachActor - 通过调用actors项目的公共api来表明formula项目的访问权限。</li>
<li>canDynamicallyReachDefaultActor - 尝试在运行时使用反射来加载actors子项目的私有类。这在Java 9之前是可能的，因为类路径会将应用程序的所有的实现细节暴露给其他所有的应用。</li>
<li>canReachDefaultActor - 尝试直接使用actors子项目的私有类。这只在Java 9之前可行，因为actors子项目的私有实现细节与该子项目的公共API构建在相同的位置。所以，它们在编译时和运行时都可用。</li>
<li>canReachGuavaClasses - 尝试使用actors子项目所依赖的类。需要注意的是，从Gradle 3.4开始，使用implementation关键字的依赖关系不包含在Java项目的消费者的编译类路径（compileClasspath）中。因此，这个测试被注释掉了，因为它不能用Gradle 3.4或更新的版本编译。</li>
</ol>
<p>遵循本指南，你会看到Java 9将对于模块细节的访问权限变得更加紧密，并导致测试，canDynamicallyReachDefaultActor和canReachDefaultActor在运行时或编译时失败。</p>
<p>你可以运行Gradle的check任务，来认证这三个测试是否通过了0-original项目（尽管其中两个测试 打破了良好的模块化设计。）</p>
<pre><code class="bash">$ ./gradlew check

BUILD SUCCESSFUL
</code></pre>
<p>您可以在<a href="https://scans.gradle.com/s/l76lgbuizu4pm/tests/byProject?toggled=W1sxXSxbMSwwXSxbMSwwLDBdLFsxLDAsMCwwXV0" target="_blank" rel="noopener">建构扫描</a>中查看此次调用gradle task任务的结果。</p>
<h3 id="第1步-为单个子项目生成Java-9模块"><a href="#第1步-为单个子项目生成Java-9模块" class="headerlink" title="第1步 - 为单个子项目生成Java 9模块"></a>第1步 - 为单个子项目生成Java 9模块</h3><p>如果您还不熟悉Java 9模块系统，请阅读：</p>
<ol>
<li><a href="http://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener">模块系统快速入门指南</a> / <a href="http://seanthefish.com/2018/03/29/java9-quick-guide/">(原文翻译)</a></li>
<li><a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">模块系统综述</a> / <a href="http://seanthefish.com/2018/03/29/module-system/">(原文翻译)</a></li>
</ol>
<p>本指南假定您已经熟悉以下概念：</p>
<ol>
<li>模块路径</li>
<li>自动模块</li>
<li>module-info.java文件的基本语法</li>
</ol>
<p>Java 9中模块系统的一个很好的功能就是可以以自下而上的方式将项目的所有代码库转换为Java 9模块。无论是从类路径还是模块路径中，我们都可以获取Java 9模块化jar包，所以我们可以在多项目构建中，转换单个叶节点以生成Java 9模块，但是在编译时使用该模块化的jar包或在类路径上使用该模块化jar包来运行该节点的输出。</p>
<p>将java-library项目转换为Java 9模块时，应该对项目进行五项更改:</p>
<ol>
<li>添加一个module-info.java文件来描述模块。</li>
<li>修改compileJava任务以生成模块。</li>
<li>修改compileTestJava任务以在本地修改模块。</li>
<li>修改test任务以使用本地更改的模块。</li>
<li>（可选）在所有其他项目的清单条目（MANIFEST.MF）中添加Automatic-Module-Name属性。</li>
</ol>
<p>我们建议为组成应用程序的所有项在META-INF/MANIFEST.MF文件中主动添加目Automatic-Module-Name清单条目 。提供Automatic-Module-Name允许库作者为未来预留模块名称，而不必将库转换为模块。这确保了库的消费者现在就可以知道模块名称将来会是什么。</p>
<p>在下面的小节中将介绍这些变化，并讨论为什么要进行变更。您还可以通过浏览src/1-single-module库中的示例项目来查看这些更改的结果。</p>
<p>我们做出以下五项改变的目标是让actors项目生成一个Java 9模块。前四项变更需要一起完成，第五项（可选）变更可以独立完成。</p>
<blockquote>
<p>提醒一下，从这一点开始，所有的构建都需要在Java 9上运行</p>
</blockquote>
<h4 id="添加一个module-info-java文件来描述模块。"><a href="#添加一个module-info-java文件来描述模块。" class="headerlink" title="添加一个module-info.java文件来描述模块。"></a>添加一个module-info.java文件来描述模块。</h4><p>将module-info.java文件添加到项目的actors/src/main/java目录。</p>
<p>actors/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.actors {
    exports org.gradle.actors;
    requires guava;
}
</code></pre>
<p>该文件声明org.gradle.actors模块导出org.gradle.actors包（但不org.gradle.actors.impl包），并需要guava模块。Guava jar文件还不是Java 9模块，所以当你需要它们时，你必须使用JVM通过jar文件的文件名来推断生成的自动模块的名称。对于guava来说，jar文件的名称是<a href="http://central.maven.org/maven2/com/google/guava/guava/22.0/" target="_blank" rel="noopener">guava-22.0.jar</a>，因此根据<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/#automatic-modules" target="_blank" rel="noopener">自动模块名称的规则</a>，您需要的模块叫guava。</p>
<h4 id="修改compileJava任务以生成模块。"><a href="#修改compileJava任务以生成模块。" class="headerlink" title="修改compileJava任务以生成模块。"></a>修改compileJava任务以生成模块。</h4><p>在actors子项目的build.gradle文件中添加以下内容。</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">ext.moduleName = &#39;org.gradle.actors&#39; //(1)

compileJava {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        options.compilerArgs = [
            &#39;--module-path&#39;, classpath.asPath,
        ]
        classpath = files()  //(2)
    }
}
</code></pre>
<ol>
<li>为模块名称定义一个变量，该变量允许您稍后为其他模块重复使用相同的代码，而无需对其进行更改。</li>
<li>通过创建一个空文件集合来清除classpath属性。</li>
</ol>
<p>编译Java 9模块时，您想使用–module-path而不是 –classpath读取您的依赖关系。因此，在该doFirst块中，您将清除该任务的classpath属性并添加一个编译器参数。</p>
<blockquote>
<p>–module-path被设置为原来的值classpath。这样做是因为，classpath已经有你所依赖的库的所有jar包和类输出目录。</p>
<p>在doFirst代码块内而不是在compileJava任务中修改options.compilerArgs参数的原因是，在执行这个任务时，你只需要重构compileClasspath（编译时的类路径）的配置。</p>
</blockquote>
<h4 id="修改compileJava任务以生成模块。-1"><a href="#修改compileJava任务以生成模块。-1" class="headerlink" title="修改compileJava任务以生成模块。"></a>修改compileJava任务以生成模块。</h4><p>Java 9模块系统的一个稍微混淆的方面是如何对Java 9模块内的代码运行单元测试。推荐的方法是在测试过程中“修补”模块。修补模块意味着向组成模块的包添加额外的类。在运行测试所需要的修补模块步骤中，您将使用相同的包来把测试类添加到模块中，以便测试类可以访问被测模块中的所有其他模块。</p>
<p>将以下内容添加到您build.gradle文件中，来实现在编译时对org.gradle.actors模块的修补。</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">compileTestJava {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        options.compilerArgs = [
            &#39;--module-path&#39;, classpath.asPath, \\(1)
            &#39;--add-modules&#39;, &#39;junit&#39;,  \\(2)
            &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;, \\(3)
            &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.srcDirs).asPath, \\(4)
        ]
        classpath = files()
    }
}
</code></pre>
<ol>
<li>用–module-path参数来作为classpath属性的默认值。</li>
<li>显式地将junit自动模块添加为可观察模块。</li>
<li>声明junit模块读取org.gradle.actors模块。</li>
<li>将测试源文件添加到org.gradle.actors模块。</li>
</ol>
<p>这些选项的添加将会导致测试源的输出目录中的生成类文件包含合适的元数据来修补org.gradle.actors模块，这些类文件会在接下来的更改中被使用。</p>
<h4 id="修改test任务以使用本地更改的模块。"><a href="#修改test任务以使用本地更改的模块。" class="headerlink" title="修改test任务以使用本地更改的模块。"></a>修改test任务以使用本地更改的模块。</h4><p>运行测试时，我们必须配置运行测试的JVM使其发现我们的模块，并修补org.gradle.actors模块来引入测试类。</p>
<p>将以下内容添加到actors项目中的build.gradle文件中。</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">test {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        jvmArgs = [
            &#39;--module-path&#39;, classpath.asPath, \\(1)
            &#39;--add-modules&#39;, &#39;ALL-MODULE-PATH&#39;, \\(2)
            &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;, \\(3)
            &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.outputDir).asPath, \\(4)
        ]
        classpath = files()
    }
}
</code></pre>
<ol>
<li>这是测试运行时的classpath属性的默认值。</li>
<li>使用特殊的ALL-MODULE-PATH，因为运行测试的JVM的main class不是Java 9模块的一部分。它是Gradle的测试运行器，因此它没有声明它需要使用的模块。该参数使模块路径中的所有模块都可以被测试类访问。</li>
<li>声明junit读取org.gradle.actors模块。</li>
<li>将测试类添加到org.gradle.actors模块。</li>
</ol>
<h4 id="（可选）在所有其他项目的清单条目（MANIFEST-MF）中添加Automatic-Module-Name属性。"><a href="#（可选）在所有其他项目的清单条目（MANIFEST-MF）中添加Automatic-Module-Name属性。" class="headerlink" title="（可选）在所有其他项目的清单条目（MANIFEST.MF）中添加Automatic-Module-Name属性。"></a>（可选）在所有其他项目的清单条目（MANIFEST.MF）中添加Automatic-Module-Name属性。</h4><p>为了向后兼容，Java 9的模块系统允许非模块化的jar文件出现在模块路径中。默认情况下，这些jar文件将被转换为自动模块，其名称基于jar文件的文件名。但是这会导致一些冗杂。许多jar文件名已经创建，但没有任何规则能保证这个jar的名字是唯一的。所以当负责维护一些常用jar的开发人员在将该jar转换为Java 9模块时，他们更希望会选择一个新的模块名称，而非由自动模块转换所自动生成的名称。</p>
<p>例如，你现在可以在module-info.java文件中通过requires guava子句指定模块，但稍后负责该项目的开发人员决定为其模块命名com.google.guava。现在，任何指定requires guava或任何依赖此模块的用户，都必须改变它们依赖的模块为requires com.google.guava，如此才能使用这些新模块，因为Java 9只允许模块路径上的模块包含特定的包。</p>
<p>因此，整个情况可能会变得非常混乱。这就是为什么<a href="http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html" target="_blank" rel="noopener">Stephen Colebourne认为</a>我们应该立即开始更新我们发布到公共存储库的所有jar,（至少要在jar的清单中指定Automatic-Module-Name属性），而且也不要发布任何未指定Automatic-Module-Name属性并且包含需要自动模块的模块的工件。</p>
<p>因此，在每个子项目的build.gradle文件中指定一个moduleName变量。例如：</p>
<p>fairy/build.gradle:</p>
<pre><code class="gradle">ext.moduleName = &#39;org.gradle.fairy.app&#39;
</code></pre>
<p>另外，在顶层build.gradle文件中的afterEvaluate代码块中的jar任务中添加manifest属性。</p>
<pre><code class="gradle">jar {
        inputs.property(&quot;moduleName&quot;, moduleName)
        manifest {
            attributes(&#39;Automatic-Module-Name&#39;: moduleName)
        }
    }
</code></pre>
<p>现在，当您将jar文件发布到像Maven Central这样的工件存储库时，你发布的jar包的文件名就不再重要了; 你一定会（通过Automatic-Module-Name）得到你想要的Java 9模块名称。</p>
<blockquote>
<p>在下一步中，您将摆脱这些清单属性，因为您已将每个子项目都转换为适当的Java 9模块。</p>
</blockquote>
<h4 id="第1步-总结"><a href="#第1步-总结" class="headerlink" title="第1步 - 总结"></a>第1步 - 总结</h4><p>这第一步是最复杂的，但现在您已经将第一个java-library项目转换为Java 9模块。所有其他子项目都在类路径上使用该模块。我们并没有真正解决在<a href="#模块化测试讨论">模块化测试讨论</a>中演示的任何模块化违规问题 ，但是我们不必中断项目，将其逻辑体系结构转换为适当的Java 9模块。接下来，我们将根目录的build.gradle项目中来集中gradle更改，并将其应用于所有子项目中。</p>
<h3 id="第2步-为所有子项目生成Java-9模块"><a href="#第2步-为所有子项目生成Java-9模块" class="headerlink" title="第2步 - 为所有子项目生成Java 9模块"></a>第2步 - 为所有子项目生成Java 9模块</h3><p>这一步的目标是让我们的Gradle构建中的所有子项目都生成Java 9模块，并将它们的依赖作为Java 9模块使用。由于您已将actors子项目中的build.gradle文件中的moduleName变量声明与其他改变分离，因此只需将该文件中的moduleName声明以后的所有内容剪切并粘贴到根目录build.gradle文件中的afterEvaluate代码块中即可。</p>
<p>build.gradle：</p>
<pre><code class="gradle">subprojects {
    afterEvaluate {
        repositories {
            jcenter()
        }

        compileJava {
            inputs.property(&quot;moduleName&quot;, moduleName)
            doFirst {
                options.compilerArgs = [
                    &#39;--module-path&#39;, classpath.asPath,
                ]
                classpath = files()
            }
        }

        compileTestJava {
            inputs.property(&quot;moduleName&quot;, moduleName)
            doFirst {
                options.compilerArgs = [
                    &#39;--module-path&#39;, classpath.asPath,
                    &#39;--add-modules&#39;, &#39;junit&#39;,
                    &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;,
                    &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.srcDirs).asPath,
                ]
                classpath = files()
            }
        }

        test {
            inputs.property(&quot;moduleName&quot;, moduleName)
            doFirst {
                jvmArgs = [
                    &#39;--module-path&#39;, classpath.asPath,
                    &#39;--add-modules&#39;, &#39;ALL-MODULE-PATH&#39;,
                    &#39;--add-reads&#39;, &quot;$moduleName=junit&quot;,
                    &#39;--patch-module&#39;, &quot;$moduleName=&quot; + files(sourceSets.test.java.outputDir).asPath,
                ]
                classpath = files()
            }
        }
    }
}
</code></pre>
<blockquote>
<p>如果你做了步骤1的最后一步，则应在粘贴之前删除jar代码块。</p>
</blockquote>
<p>如果您还没有为每个子项目添加moduleName变量声明，那么现在应该这样做。例如：</p>
<p>pigs/build.gradle：</p>
<pre><code class="gradle">ext.moduleName = &#39;org.gradle.fairy.tale.pigs&#39;
</code></pre>
<p>您还需要为每个子项目添加一个module-info.java文件。例如：</p>
<p>bears/src/main/java/module-info.java:</p>
<pre><code class="gradle">module org.gradle.fairy.tale.bears {
    requires org.gradle.actors;
    requires transitive org.gradle.fairy.tale;
    requires org.gradle.fairy.tale.formula;

    exports org.gradle.fairy.tale.bears;
}
</code></pre>
<blockquote>
<p>您还需要为pigs， formula，fairy，和tale子项目添加这些module-info.java文件。最终结果应该看起来像src/2-all-modules中的代码。</p>
</blockquote>
<p>现在，Gradle的test任务将无法编译，除非您已将canReachDefaultActor测试注释掉。另外，canDynamicallyReachDefaultActor测试将在测试运行时失败，除非你添加@Ignore注释。</p>
<pre><code class="bash">$ ./gradlew test

&gt; Task :formula:test

org.gradle.fairy.tale.formula.ModularityTest &gt; canDynamicallyReachDefaultActor FAILED
    java.lang.IllegalAccessException at ModularityTest.java:28

2 tests completed, 1 failed


FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task &#39;:formula:test&#39;.
&gt; There were failing tests. See the report at: &lt;link-to-report&gt;

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
</code></pre>
<p>如果你注释掉canReachDefaultActor测试并为canDynamicallyReachDefaultActor添加@Ignore注解，剩下的测试应该通过，你可以在src/2-all-modules中得到完整的代码。</p>
<h4 id="第2步-总结"><a href="#第2步-总结" class="headerlink" title="第2步 - 总结"></a>第2步 - 总结</h4><p>到目前为止，你已经在使用Java 9模块来编译和运行所有六个子项目和测试。这些子项目被适当地封装，并且没有一个包下的测试可以看到这个包所依赖的任何实现细节。但是，<a href="https://docs.gradle.org/4.6/userguide/application_plugin.html?_ga=2.21328251.1136812865.1523857970-1287880600.1513842256" target="_blank" rel="noopener">Gradle的应用程序插件</a>的一些特性依赖于类路径来加载和编译类，而不是模块路径。</p>
<p>此外，Java 9增加了一种更方便的方式来使用ServiceLoader功能。您将在第3步中了解如何处理这些问题。</p>
<h3 id="第3步-在run和assemble任务中使用Java-9模块"><a href="#第3步-在run和assemble任务中使用Java-9模块" class="headerlink" title="第3步 - 在run和assemble任务中使用Java 9模块"></a>第3步 - 在run和assemble任务中使用Java 9模块</h3><p>现在所有子项目都已经转化为为Java 9模块，现在该学习fairy项目中的main class（org.gradle.fairy.app.StoryTeller）在运行时是如何使用这些模块的 。</p>
<p>运行本指南中介绍的应用程序有两种方式。首先是使用由<a href="https://docs.gradle.org/4.6/userguide/application_plugin.html?_ga=2.28841596.1136812865.1523857970-1287880600.1513842256" target="_blank" rel="noopener">应用程序插件</a>添加的Gradle run任务 。</p>
<pre><code class="bash">$ ./gradlew run

&gt; Task :fairy:run
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

&lt;... elided ...&gt;

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.


BUILD SUCCESSFUL
</code></pre>
<p>另一种方法是使用Gradle的assemble任务来分别打包各个应用程序，然后提取到某个目录并在那里运行。</p>
<pre><code class="bash">$ ./gradlew assemble

BUILD SUCCESSFUL
$ cp fairy/build/distributions/fair.tar /tmp
$ cd /tmp
$ tar xvf fairy.tar
x fairy/
x fairy/lib/
x fairy/lib/fairy.jar
x fairy/lib/pigs.jar
x fairy/lib/bears.jar
x fairy/lib/formula.jar
x fairy/lib/tale.jar
x fairy/lib/actors.jar
x fairy/lib/guava-22.0.jar
x fairy/lib/jsr305-1.3.9.jar
x fairy/lib/error_prone_annotations-2.0.18.jar
x fairy/lib/j2objc-annotations-1.1.jar
x fairy/lib/animal-sniffer-annotations-1.14.jar
x fairy/bin/
x fairy/bin/fairy
x fairy/bin/fairy.bat
$ ./bin/fairy
Once upon a time, there lived the big bad wolf, and the 3 little pigs.

&lt;... elided ...&gt;

Goldilocks ran out of the house at top speed to escape the 3 bears.
And they all lived happily ever after.
</code></pre>
<p>在步骤2之后，这两种机制都依赖于出现在类路径上的模块。这样也就会跳过了Java 9模块系统的模块化特性。在这一步中，您将：</p>
<ol>
<li>修改run任务以使用模块。</li>
<li>修改startScript任务来使*nix和Windows系统使用模块。</li>
<li>将ServiceLoader机制更新为Java 9语法。</li>
</ol>
<p>一旦进行了更改1和2，运行该程序的两种机制都应该能直接运行，因此请随时再次运行这些命令以确认您已正确实施每项更改。</p>
<p>您依旧可以在资源代码库中的src/3-application目录中看到所有更改 。</p>
<h3 id="修改run任务以使用模块"><a href="#修改run任务以使用模块" class="headerlink" title="修改run任务以使用模块"></a>修改run任务以使用模块</h3><p>要在run任务中使用Java 9模块，你需要将以下内容添加到fairy项目中的build.gradle文件中。</p>
<p>fairy/build.gradle</p>
<pre><code class="gradle">mainClassName = &quot;$moduleName/org.gradle.fairy.app.StoryTeller&quot; //(1)

run {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        jvmArgs = [
            &#39;--module-path&#39;, classpath.asPath,
            &#39;--module&#39;, mainClassName //(2)
        ]
        classpath = files()
    }
}
</code></pre>
<ol>
<li>设置mainClassName属性包含moduleName。</li>
<li>明确告诉Java 9使用该模块。</li>
</ol>
<h4 id="修改startScript任务来使-nix和Windows系统使用模块。"><a href="#修改startScript任务来使-nix和Windows系统使用模块。" class="headerlink" title="修改startScript任务来使*nix和Windows系统使用模块。"></a>修改startScript任务来使*nix和Windows系统使用模块。</h4><p>在fairy/build/distributions目录中创建的tar和zip文件会包含启动脚本 ，这些脚本允许在所有支持的操作系统上，以可预测的方式启动JVM。</p>
<p>要修改已生成的startScripts，请将以下内容添加到您的fairy/build.gradle文件中：</p>
<p>fairy/build.gradle：</p>
<pre><code class="gradle">startScripts {
    inputs.property(&quot;moduleName&quot;, moduleName)
    doFirst {
        classpath = files()
        defaultJvmOpts = [
            &#39;--module-path&#39;, &#39;APP_HOME_LIBS&#39;,  \\(1)
            &#39;--module&#39;, mainClassName
        ]
    }
    doLast{
        def bashFile = new File(outputDir, applicationName)
        String bashContent = bashFile.text
        bashFile.text = bashContent.replaceFirst(&#39;APP_HOME_LIBS&#39;, Matcher.quoteReplacement(&#39;$APP_HOME/lib&#39;))

        def batFile = new File(outputDir, applicationName + &quot;.bat&quot;)
        String batContent = batFile.text
        batFile.text = batContent.replaceFirst(&#39;APP_HOME_LIBS&#39;, Matcher.quoteReplacement(&#39;%APP_HOME%\\lib&#39;))
    }
}
</code></pre>
<ol>
<li>将模块路径设置为独立于平台的占位符值，稍后将以特定于平台的方式替换*nix shell脚本和Windows .bat文件。</li>
</ol>
<h3 id="将ServiceLoader机制更新为Java-9语法。"><a href="#将ServiceLoader机制更新为Java-9语法。" class="headerlink" title="将ServiceLoader机制更新为Java 9语法。"></a>将ServiceLoader机制更新为Java 9语法。</h3><p>Java 9模块系统引入了一种更好的方式来指定哪些模块为ServiceLoader机制提供服务的实现。首先，从两个目录bears/src/main和pigs/src/main中，删除resources文件夹，因为新机制不需要META-INF/services文件。</p>
<p>然后，调整每个项目的module-info.java文件。</p>
<p>fairy/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.fairy.app {
    requires org.gradle.fairy.tale;
    uses org.gradle.fairy.tale.Tale;
}
</code></pre>
<p>bears/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.fairy.tale.bears {
    requires org.gradle.actors;
    requires transitive org.gradle.fairy.tale;
    requires org.gradle.fairy.tale.formula;

    provides org.gradle.fairy.tale.Tale
        with org.gradle.fairy.tale.bears.GoldilocksAndTheThreeBears;
}
</code></pre>
<p>pigs/src/main/java/module-info.java:</p>
<pre><code class="java">module org.gradle.fairy.tale.pigs {
    requires org.gradle.actors;
    requires transitive org.gradle.fairy.tale;
    requires org.gradle.fairy.tale.formula;

    provides org.gradle.fairy.tale.Tale
            with org.gradle.fairy.tale.pigs.ThreeLittlePigs;
}
</code></pre>
<p>由于fairy项目中的module-info.java声明它使用org.gradle.fairy.tale.Tale服务，所以该模块中的ServiceLoader实例将有权访问，所有由Java 9模块声明的在运行时提供的org.gradle.fairy.tale.Tale服务实现。</p>
<h3 id="第4步-使用experimental-jigsaw插件来做与我们之间所做的同样的事情"><a href="#第4步-使用experimental-jigsaw插件来做与我们之间所做的同样的事情" class="headerlink" title="第4步 - 使用experimental-jigsaw插件来做与我们之间所做的同样的事情"></a>第4步 - 使用experimental-jigsaw插件来做与我们之间所做的同样的事情</h3><p>虽然Gradle尚未将Java 9模块构建作为Java插件的一级特性加以支持，实验性插件也可让您在项目中尝试使用Java 9模块。</p>
<p>org.gradle.java.experimental-jigsaw插件只是一个简便的机制，可以在一个步骤中，提供本指南步骤1至3中的所有更改。它可能适用于您的项目，但您应该考虑到它是实验性的，不适合生产版本。</p>
<p>以下是如何使用插件：</p>
<p>actors/build.gradle：</p>
<pre><code class="gradle">plugins {
    id &#39;java-library&#39;
    id &#39;org.gradle.java.experimental-jigsaw&#39; version &#39;0.1.1&#39;  \\(1)
}
</code></pre>
<ol>
<li>使用插件</li>
</ol>
<p>actors/build.gradle：</p>
<pre><code class="gradle">javaModule.name = &#39;org.gradle.actors&#39;  \\(1)
</code></pre>
<ol>
<li>使用新javaModule.name设置来指定模块名称。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时，您的应用程序正在利用Java 9模块系统的大部分功能。本指南向您展示了如何修改常规插件java-library和application所添加的任务，来方便你使用Java 9模块进行工作。未来，Gradle团队将为模块系统添加一流的支持，但您现在就已经可以开始尝试！</p>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
            <category> gradle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
            <tag> gradle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java模块系统综述]]></title>
      <url>/2018/03/29/module-system/</url>
      <content type="html"><![CDATA[<p><strong>本文是Mark Reinhold的The State of the Module System最新版的翻译。（<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">原文地址</a>）</strong></p>
<blockquote>
<p>这份文档略有过时。其基本概念没有任何改变，但requires public关键字已被重新命名为requires transitive，并增加了几项附加功能。更新正在准备中，准备就绪后会在这里发布。</p>
</blockquote>
<p>本文是对<a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Jigsaw项目</a>中对Java SE平台所做的增强的一个非正式的概述，并针对<a href="http://openjdk.java.net/projects/jigsaw/spec/" target="_blank" rel="noopener">JSR 376：Java平台模块系统</a>所提出。有<a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">相关的文档</a>描述了对特定于JDK工具和API的增强，这些超出了JSR的范围。</p>
<p>正如JSR所述，模块系统是为了提供可靠的配置，使程序组件相互显式的声明依赖，配合其强大的封装能力，使组件允许声明其中哪些公共类型可供其他组件访问，哪些不可以，并以此来替换脆弱，容易出错的类路径机制。</p>
<p>这些功能将直接对Java SE平台本身、Java应用程序开发人员，Java类库开发人员有利，而且也会间接地实现可伸缩平台、更高的平台完整性和更高的性能。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#定义模块">定义模块</a><ul>
<li><a href="#模块声明">模块声明</a></li>
<li><a href="#模块打包">模块打包</a></li>
<li><a href="#模块描述符">模块描述符</a></li>
<li><a href="#平台模块">平台模块</a></li>
</ul>
</li>
<li><a href="#使用模块">使用模块</a><ul>
<li><a href="#模块路径">模块路径</a></li>
<li><a href="#解决依赖">解决依赖</a></li>
<li><a href="#可读性">可读性</a></li>
<li><a href="#可访问性">可访问性</a></li>
<li><a href="#隐含的可读性">隐含的可读性</a></li>
</ul>
</li>
<li><a href="#兼容性和迁移">兼容性和迁移</a><ul>
<li><a href="#未命名模块">未命名模块</a></li>
<li><a href="#自下而上的迁移">自下而上的迁移</a></li>
<li><a href="#自动模块">自动模块</a></li>
<li><a href="#与类路径建立联系">与类路径建立联系</a></li>
</ul>
</li>
<li><a href="#服务">服务</a></li>
<li><a href="#高级特性">高级特性</a><ul>
<li><a href="#反射">反射</a></li>
<li><a href="#反射的可读性">反射的可读性</a></li>
<li><a href="#类加载器">类加载器</a></li>
<li><a href="#未命名模块与类加载器">未命名模块与类加载器</a></li>
<li><a href="#层">层</a></li>
<li><a href="#限制性导出">限制性导出</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
<p>这是本文档的第二版。相对于<a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/2015-09-08" target="_blank" rel="noopener">最初版本</a>，本版引入了兼容性和迁移的解释，修改了反射可读性的描述，进行了重新排序以改善叙述的流程，并且组织了更容易定位的目录。</p>
<p>文中仍然存在许多未解决的问题，其解决方案将反映在本文档的未来版本中。</p>
<h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>为了提供可靠的配置和强大的封装，使其既能接近开发人员，又能被现有工具链支持，我们将模块视为一种基本的新型Java程序组件。一个模块是一个命名的，能自我描述的代码和数据的集合。其代码被组织为一组包（package），包中包含Java类和接口。</p>
<h4 id="模块声明"><a href="#模块声明" class="headerlink" title="模块声明"></a>模块声明</h4><p>模块的自我描述体现在它的声明中，这是一种Java编程语言的新构造。最简单的模块声明只是指定其模块的名称：</p>
<pre><code class="java">module com.foo.bar { }
</code></pre>
<p>可以添加一个或多个require子句来声明该模块在编译时和运行时依赖于其他名称的某些模块：</p>
<pre><code class="java">module com.foo.bar {
    requires org.baz.qux;
}
</code></pre>
<p>最后，可以添加exports子句来声明该模块中仅有特定包中的公共类型可供其他模块使用：</p>
<pre><code class="java">module com.foo.bar {
    requires org.baz.qux;
    exports com.foo.bar.alpha;
    exports com.foo.bar.beta;
}
</code></pre>
<p>如果一个模块的声明不包含任何exports子句，那么它将不会导出任何类型到其他模块。</p>
<p>按照惯例，模块声明的源代码放置在名为module-info.java的文件中，该文件位于模块的源文件层次结构的根目录下。 com.foo.bar模块的源文件可能包括：</p>
<pre><code class="java">module-info.java
com/foo/bar/alpha/AlphaFactory.java
com/foo/bar/alpha/Alpha.java
...
</code></pre>
<p>按照惯例，模块声明被编译成名为module-info.class的文件，并放置在.class文件输出目录中。</p>
<p>模块名称跟包名称一样，不得相互冲突。命名模块的推荐方法是使用长期用于命名软件包的反向域名模式。因此，模块的名称通常就是其导出包名称的前缀，但这种关系不是强制性的。</p>
<p>模块的声明不包括其版本号，也不包括它所依赖的子模块的版本号。这样做是<a href="http://openjdk.java.net/projects/jigsaw/spec/reqs/02#version-selection" target="_blank" rel="noopener">故意为之</a>的：模块系统的目标不是解决版本选择问题，这最好留给构建工具和容器应用程序来做。</p>
<p>模块声明是Java编程语言的一部分，这其中的原因有几个。其中最重要的一点是，模块必须在编译时和运行时都可用，以实现各个阶段的确定性，即确保模块系统在编译时和运行时都以相同的方式工作。这反过来又能防止多种错误的发生，或者至少在编译时更早地报告错误使其更容易诊断和修复。</p>
<p>源文件中的模块声明文件和模块中的其他源文件，将会一起编译为.class文件供Java虚拟机使用，这是建立确定性的自然方式。这种方法将立即为开发人员所熟悉，并且IDE和构建工具也会很容易支持。尤其是IDE，可以依照依赖需要为现有组件提供模块声明的提示。</p>
<h4 id="模块打包"><a href="#模块打包" class="headerlink" title="模块打包"></a>模块打包</h4><p>现有工具已经可以创建，操作和使用JAR文件，因此为了便于使用和迁移，我们定义了模块化JAR文件。除了根目录中还包含了一个module-info.class文件之外，模块化的JAR文件就像普通的JAR文件一样。上述com.foo.bar模块的模块化JAR文件可能具有以下内容：</p>
<pre><code>META-INF/
META-INF/MANIFEST.MF
module-info.class
com/foo/bar/alpha/AlphaFactory.class
com/foo/bar/alpha/Alpha.class
...
</code></pre><p>模块化的JAR文件可以被当作模块，在这种情况下，它的module-info.class文件被用来作为模块的声明。它也可以被放在普通的类路径上，在这种情况下，它的module-info.class文件将被忽略。模块化JAR文件允许库的维护者在所有版本上发布工件（artifacts），该工件既可作为Java SE 9及更高版本的模块，也可作为类路径上的常规JAR文件。我们期望包含jar工具的Java SE 9的实现将增强该工具，以便轻松创建模块化JAR文件。</p>
<p>为了模块化Java SE平台的JDK，我们将引入一种新的打包机制（artifact format），它将超越JAR文件来容纳原生代码、配置文件和其他类型的数据（如果这种数据真的存在）。这种机制利用了在源文件中的模块声明并将它们编译成.class文件，此.class文件与其他的打包方式都不同。这种被临时命名为“JMOD”的新格式是否应该成为标准化仍旧是一个悬而未决的问题。（已成为Java9的标准格式之一，请查看<a href="https://docs.oracle.com/javase/9/tools/jmod.htm" target="_blank" rel="noopener">oracle官方文档</a>）</p>
<h4 id="模块描述符"><a href="#模块描述符" class="headerlink" title="模块描述符"></a>模块描述符</h4><p>将模块声明编译到.class文件中的最后一个优点是.class文件已经具有精确定义和可扩展的格式。因此，我们可以将module-info.class文件视为更通用的模块描述符，其中包括源代码级模块声明的编译形式，还包括在声明最初编译之后插入的.class文件中的附加信息。</p>
<p>例如，IDE、或者记录打包时间的工具，可以插入包含文档信息的属性，例如模块的版本、标题、说明和许可证。这些信息可以在编译时和运行时通过模块系统的反射来读取，以用于写文档，程序诊断和调试。它也可以被下游工具用于构建跨操作系统的程序包。特定的属性将被标准化，但由于Java类文件格式是可扩展的，所以其他工具和框架将能够根据需要来定义附加属性。非标准的属性不会影响模块系统本身的行为。</p>
<h3 id="平台模块"><a href="#平台模块" class="headerlink" title="平台模块"></a>平台模块</h3><p>Java SE 9的平台规范，使用模块系统将平台划分为一组模块。Java SE 9平台的实现可能包含所有的平台模块，或者可能仅包含其中的一部分。</p>
<p>在任何情况下，模块系统专用的唯一模块是已命名的基础模块java.base。基本模块定义并导出所有平台的核心软件包，包括模块系统本身：</p>
<pre><code class="java">module java.base {
    exports java.io;
    exports java.lang;
    exports java.lang.annotation;
    exports java.lang.invoke;
    exports java.lang.module;
    exports java.lang.ref;
    exports java.lang.reflect;
    exports java.math;
    exports java.net;
    ...
}
</code></pre>
<p>基本模块始终存在。每个其他模块都隐式的建立在基本模块之上，而基本模块则不依赖于其他模块。</p>
<p>其余的平台模块将共享“ java.”名称前缀，并有可能包括，例如，模块java.sql用于数据库连接， 模块java.xml用于XML处理，模块java.logging进行记录日志。按照惯例，尽管没有在Java SE 9平台规范中定义，但是专用于JDK的模块将共享“ jdk.”名称前缀。</p>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>单个模块可以在模块工件（artifacts）中定义，或者内嵌于编译时或运行时环境。要在任一阶段使用它们，模块系统必须定位它们，然后确定它们如何相互关联的，并以此提供可靠的配置和强大的封装。</p>
<h4 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h4><p>为了定位包中定义的模块，模块系统搜索由系统定义的模块路径（module path）。模块路径是一个序列，其中的每个元素都是模块工件或包含模块工件的目录。系统会按顺序搜索模块路径的元素，以找到定义合适的第一个模块工件。</p>
<p>模块路径（module path）与类路径（class path）有着很大的不同，它更加健壮。类路径的固有脆弱性是基于这样一个事实：即它是一种在所有包中通过路径来定位各个类型的工作方式，它不会在不同的包文件本身之间进行区分。这使得它无法预先知道程序什么时候缺少了某个包。它还允许不同的程序包（artifacts）在相同的包（package）中定义类型，即使这些程序包是只是版本不同，或者就是完全不同的组件（jar hell）。</p>
<p>相反，模块路径是定位整个模块、而不是某个类型的一种手段。如果模块系统无法满足来自模块路径的模块工件的特定依赖性，或者如果在同一目录中遇到定义相同名称模块的两个模块工件，则编译器或虚拟机将报告错误并退出。</p>
<p>内置于编译时或运行时环境的模块以及模块路径中的模块工件定义的模块统称为可观察模块的范围。</p>
<h4 id="解决依赖"><a href="#解决依赖" class="headerlink" title="解决依赖"></a>解决依赖</h4><p>假设我们有一个使用上述com.foo.bar模块和平台java.sql模块的应用程序。包含应用程序核心的模块声明如下：</p>
<pre><code class="java">module com.foo.app {
    requires com.foo.bar;
    requires java.sql;
}
</code></pre>
<p>鉴于这种初始应用程序模块，该模块系统可通过表达依赖性的requires来定位额外观察到的模块，以满足这些依赖关系，然后解决这些模块的依赖关系，并依此类推，直到每个模块的每一个的依赖都被满足。这个传递闭包计算的结果是一个模块图，对于每个依赖其他模块的模块，它包含从第一个模块到第二个模块的有向边。</p>
<p>要为模块com.foo.app构建模块图，模块系统将检查模块的声明java.sql，即：</p>
<pre><code class="java">module java.sql {
    requires java.logging;
    requires java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
</code></pre>
<p>它还会循环检查其声明的com.foo.bar模块（上面的模块定义中已经示出），包括org.baz.qux模块，java.logging模块和 java.xml模块; 为简洁起见，最后三个这里没有显示，因为它们没有声明对任何其他模块的依赖。</p>
<p>根据所有这些模块声明，为com.foo.app模块画出的模块图，包含以下节点和边：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-1.png" alt="module-pic-1"></p>
<p>在该图中，深蓝色线条表示显式依赖关系，如requires，而浅蓝色线条表示每个模块对基本模块的隐式依赖关系。</p>
<h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p>当一个模块直接依赖于模块图中的另一个模块时，则第一个模块中的代码将能够引用第二个模块中的类型。因此，我们说第一个模块读取第二个模块，或者等同地，第二个模块可以被第一个模块读取。因此，在上述的曲线图中，com.foo.app模块读取com.foo.bar和 java.sql模块，但并不读取org.baz.qux模块，java.xml模块或 java.logging模块。java.logging模块可由java.sql模块读取，但不能被其他模块读取。（根据定义，每个模块都会自行读取自己本身。）</p>
<p>在模块图中定义的可读性关系是可靠配置的基础 ：模块系统能确保每个依赖是由另一个模块完成的，模块图是非循环的，每个模块最多只能读取一个包含制定包的模块，这样定义相同名称包的模块就不会相互干扰。</p>
<p>这样的配置不仅更可靠，也可以更快。当模块中的代码引用包中的某个类型时，那么该包将保证在该模块中定义，或者只在该模块读取的模块中定义一个。因此，在寻找特定类型的定义时，不需要在多个模块中搜索它，或者更糟糕的，沿着整个路径搜索它。</p>
<h4 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h4><p>在模块图中定义的可读性关系与exports模块声明中的子句相结合，是强封装的基础：只有当某个模块被另一个模块读取时，Java编译器和虚拟机才会将这个模块中的包中的公共类型视为只能被另一个模块所访问，同时还需要这个模块导出该包。即，如果两种类型的S和T在不同的模块中定义的，并且T是 public，则如果代码S 可以存取 T，必须满足以下条件：</p>
<ol>
<li>S的模块读取T的模块，</li>
<li>T的模块导出T包。</li>
</ol>
<p>跨越模块边界的类型引用以及私有的方法和字段在这种情况下都是不可用的：任何尝试使用它的操作都将导致编译器报告错误，或者由Java虚拟机报出的IllegalAccessError，或者由反射运行时API引发的IllegalAccessException。因此，即使声明了一个类型public，如果它的包没有在其模块的声明中导出，那么它将只能被该模块中的代码访问。</p>
<p>如果模块中的封闭类型是可访问的，并且其成员本身也被声明成允许访问，那么跨模块也可以访问并引用到其方法或字段。</p>
<p>要了解上述模块图的封装是如何工作的，我们标记出每个模块导出的包：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-2.png" alt="module-pic-2"></p>
<p>模块com.foo.app中的代码可以访问com.foo.bar.alpha包中声明的公共类型， 因为模块com.foo.app依赖于模块com.foo.bar，并且因为模块com.foo.bar导出com.foo.bar.alpha包。如果com.foo.bar包含内部程序包（internal package），即com.foo.bar.internal包，则模块com.foo.app不能访问该com.foo.bar.internal包中的任何类型，因为com.foo.bar并没有导出这个内部包。模块com.foo.app中的代码也不能引用org.baz.qux包中的类型，因为模块com.foo.app不依赖于模块org.baz.qux，因此不会读取它（在这个例子中，模块的依赖并不能传递）。</p>
<h4 id="隐含的可读性"><a href="#隐含的可读性" class="headerlink" title="隐含的可读性"></a>隐含的可读性</h4><p>如果一个模块读取另一个模块，则在某些情况下，它也能符合逻辑地读取其他一些模块。</p>
<p>例如，平台的java.sql模块依赖于java.logging模块和java.xml模块，不仅因为它包含了这些模块中的类型的代码实现，还因为它直接声明使用了这些模块中的类型。java.sql.Driver接口声明了一个公共的方法：</p>
<pre><code class="java">public Logger getParentLogger();
</code></pre>
<p>其中Logger是在java.logging模块所导出的包java.util.logging中声明的类型。</p>
<p>假设，例如，com.foo.app模块中的代码调用此方法来获取日志，然后记录一条消息：</p>
<pre><code class="java">String url = ...;
Properties props = ...;
Driver d = DriverManager.getDriver(url);
Connection c = d.connect(url, props);
d.getParentLogger().info(&quot;Connection acquired&quot;);
</code></pre>
<p>如果com.foo.app模块像为如上所述声明，那么这样的代码将不起作用：该getParentLogger方法返回另一个模块java.logging中所声明的Logger类型，而模块com.foo.app并没有读取模块java.logging ，因此调用java.logging模块中Logger类的info方法将会失败，因为该类以及该方法无法访问。</p>
<p>解决这个问题的一个方法寄希望于每一位开发者在依赖java.sql模块并使用getParentLogger方法Logger类的同时，还必须记得声明对java.logging模块的依赖。当然，这样的方式是不可靠的，因为它违反了最小意外原则（principle of least surprise）：如果一个模块依赖于第二个模块，那么很自然的我们会期望去使用第一个模块中的所有属性，包括在第二的模块中声明的属性，也会在我们依赖第一个模块是变得立即可见（即模块依赖的传递性）。</p>
<p>因此，我们扩展了模块声明，以便一个模块可以将附加模块的可读性授予依赖它的任何模块。这种隐含的可读性通过requires public子句来表达（在正式版的jdk中已经被更新为requires transitive）。java.sql模块的声明实际上是这样的：</p>
<pre><code class="java">module java.sql {
    requires public java.logging;
    requires public java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
</code></pre>
<p>该public关键字是指，任何依赖于模块java.sql的模块，不仅仅会读取java.sql模块，也会读取java.logging模块和java.xml模块。因此，上述com.foo.app模块的模块图，包含两个额外的深蓝色边缘，通过绿色边缘链接到java.sql模块，因为java.logging模块和java.xml模块被该模块隐性的依赖：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-moudle-3.png" alt="module-pic-3"></p>
<p>com.foo.app模块现在可以包含访问java.logging模块和java.xml模块的导出包中的所有公共类型的代码，即使其声明中没有提及这些模块。</p>
<p>一般而言，如果一个模块的导出包引用了了另一个模块中的包的类型，则第一个模块应该使用requires public子句来声明对第二个模块的依赖。这将确保依赖于第一个模块的其他模块将自动读取第二个模块，从而访问该模块的导出包中的所有类型。</p>
<h3 id="兼容性和迁移"><a href="#兼容性和迁移" class="headerlink" title="兼容性和迁移"></a>兼容性和迁移</h3><p>到目前为止，我们已经看到如何从头开始定义模块，将它们打包到模块工件中，并将它们与其他模块一起使用，这些模块既可以嵌入到平台中，也可以直接在包中定义。</p>
<p>当然，大多数Java代码是在引入模块系统之前编写的，并且必须继续像现在一样继续工作，而不用更改（向下兼容）。因此，即使平台本身由模块组成，模块系统也应该可以在类路径上编译和运行由JAR文件组成的应用程序。它还允许将现有应用程序以灵活和渐进的方式迁移到模块化形式。</p>
<h4 id="未命名模块"><a href="#未命名模块" class="headerlink" title="未命名模块"></a>未命名模块</h4><p>如果我们的需求时在加载一个其所在的包未再任何已知的模块中声明的类型，则模块系统将尝试从类路径加载它。如果成功，那么该类型会被认为成为一个，被称为未命名模块的特殊模块中的成员，以确保每个类型都与某个模块相关联。未命名模块在高层次上类似于现有概念中的未命名包。当然，所有其他模块都有名称，所以我们今后将把它们称为命名模块。</p>
<p>未命名模块读取所有的其他模块。因此，从类路径加载的任何类型的代码，都将能够访问所有其他可读模块的导出类型，默认情况下，该模块将包含所有内置的已命名平台模块。因此，编译并在Java SE 8上运行的现有类路径应用程序将在Java SE 9上以完全相同的方式进行编译和运行，只要它使用的是标准的，未弃用的Java SE API即可。</p>
<p>未命名的模块默认导出其所有软件包。这可以实现灵活的迁移。但是，它并不意味着命名模块中的代码可以访问未命名模块中的类型。实际上，命名模块甚至不能声明对未命名模块的依赖。这种限制是故意的，因为如果允许命名模块依赖于类路径的任意内容，就不可能实现可靠的配置。</p>
<p>如果在命名模块和未命名模块中都定义了同样名字的包，那么未命名模块中的包将被忽略。即使类路径十分混乱，这种可靠的配置，仍能确保每个模块最多只能读取一个模块来提供你所需要的包。如果在上面的示例中，类路径上的JAR文件，包含一个名为，com/foo/bar/alpha/AlphaFactory.class的.class文件，那么该文件将永远不会被加载，因为包com.foo.bar.alpha 是由模块com.foo.bar导出的。</p>
<h4 id="自下而上的迁移"><a href="#自下而上的迁移" class="headerlink" title="自下而上的迁移"></a>自下而上的迁移</h4><p>从类路径加载的类型作为未命名模块中的成员，这种处理将允许我们自下而上的，将现有的应用程序从JAR文件形式迁移到模块化的形式。</p>
<p>例如，上面显示的应用程序最初是为Java SE 8构建的，因为它是放置在类路径上的一组JAR文件。如果我们在Java SE 9上按原样运行它，那么JAR文件中的类型将在未命名的模块中定义。该模块将读取所有其他模块，包括所有内置平台模块; 为简单起见，假设那些被读取的模块被限制为java.sql模块，java.xml模块， java.logging模块和java.base模块。因此我们获得如下的模块图：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-4.png" alt="module-pic-4"></p>
<p>我们可以立即将org-baz-qux.jar转换为命名模块，因为我们知道它不会引用其他两个JAR文件中的任何类型，因此作为命名模块，它也不会引用未命名模块中的任何类型。（这是因为我们刚刚从最初的例子中知道了这一点。如果我们不知道它时候引用未命名模块的话，我们可以借助诸如类似jdeps的工具来发现它。）</p>
<p>我们编写一个模块声明为org.baz.qux，将其添加到模块的源代码中，编译并将结果打包为模块化JAR包。如果我们将该JAR文件放在模块路径上，并将其他类放在类路径上，我们将获得改进的模块图：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-5.png" alt="module-pic-5"></p>
<p>com-foo-bar.jar和com-foo-app.jar中的代码会继续工作，因为未命名的模块会读取每个已命名的模块，这个未命名模块现在包含新模块org.baz.qux。</p>
<p>我们可以类似地进行模块化com-foo-bar.jar，然后接着模块化com-foo-app.jar最终结束预期的模块图，如前所示：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-6.png" alt="module-pic-6"></p>
<p>如果我们了解原始JAR文件中的类型所做的工作，我们当然可以在一个步骤中将它们全部三个模块化。然而，如果 org-baz-qux.jar是独立维护的，或许由完全不同的团队或组织来维护，那么它可以在其他两个组件之前模块化，并且在com-foo-app.jar模块化之前也可以模块化com-foo-bar.jar。</p>
<h4 id="自动模块"><a href="#自动模块" class="headerlink" title="自动模块"></a>自动模块</h4><p>自下而上的迁移很简单，但并非总是可行的。即使org-baz-qux.jar的维护者尚未将其转换为适当的模块，或者可能永远不会，我们仍然可能想要将模块化com-foo-app.jar和com-foo-bar.jar。</p>
<p>我们已经知道代码是com-foo-bar.jar依赖org-baz-qux.jar。但是，如果我们转换com-foo-bar.jar为命名模块com.foo.bar，但留org-baz-qux.jar在类路径中，那么该代码将不再起作用：org-baz-qux.jar将继续在未命名模块中定义，但com.foo.bar是一个命名模块，它不能声明依赖于未命名模块。</p>
<p>那么，我们必须以某种方式安排org-baz-qux.jar作为一个命名模块出现，以便com.foo.bar可以依赖它。我们可以fork org.baz.qux的源代码并将其模块化，但是如果维护人员不愿意将该更改合并到上游存储库中，那么只要我们需要它，我们就必须维护这个分支。</p>
<p>因此，我们将把org-baz-qux.jar作为一个自动模块，不加修改地放在模块路径上，而不是类路径上。这将定义一个可观察模块，其模块名称，org.baz.qux来源于JAR文件的名称，以便其他非自动模块可以通常的方式依赖它：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-7.png" alt="module-pic-7"></p>
<p>自动模块是一个隐式定义的命名模块，因为它没有模块声明。相比之下，普通的命名模块是通过模块声明明确定义的; 我们今后将把它们称为显式模块。</p>
<p>没有方法可以预先告诉自动模块可能依赖哪些其他模块。因此，在模块图解析完成后，自动模块将读取每个其他命名模块，无论是自动模块还是显式模块：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-8.png" alt="module-pic-8"></p>
<p>（这些新的可读性边在模块图中创建了循环，这使得推理起来有些困难，但我们认为这些是可以容忍的，而且通常是为了实现更灵活迁移所导致的临时结果。）</p>
<p>类似地，没有方法可以告诉自动模块中的哪些包打算供其他模块使用，或者仍旧是通过类路径上的类继续使用。因此，即使自动模块中的每个软件包只用于内部使用，也会被视为导出：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-9.png" alt="module-pic-9"></p>
<p>现在com.foo.app中的代码可以访问org.baz.qux中的类型，尽管我们知道它实际上并没有这样做。</p>
<p>自动模块提供了混乱的类路径和显式模块规则之间的中间地带。它们允许将由JAR文件组成的现有应用程序从上到下迁移到模块，如上所示，或者以自上而下和自下而上的方法组合来迁移。通常，我们可以从类路径上的任意一组JAR文件开始，使用一个工具jdeps来分析它们之间的依赖关系，将我们控制的源代码组件转换为显式模块，然后将剩余的JAR文件按原样放在模块路径中。我们不控制源代码的JAR文件将被视为自动模块，直到它们也转换为显式模块为止。</p>
<h4 id="与类路径建立联系"><a href="#与类路径建立联系" class="headerlink" title="与类路径建立联系"></a>与类路径建立联系</h4><p>许多现有的JAR文件可以用作自动模块，但有些不能。如果类路径上的两个或多个JAR文件包含同一个包中的类型，那么最多可以有其中的一个来用作自动模块，因为模块系统仍然保证每个命名模块至多读取一个包含了需要的包的命名模块，以保证定义了相同名称包的命名模块不会相互干扰。在这种情况下，我们经常会发现实际上，我们只需要其中一个JAR文件。如果其他的JAR文件重复或接近重复，并以某种方式错误地放在类路径上，则可以将其中一个用作自动模块，其他的JAR文件就会被舍弃。但是，如果类路径上的多个JAR文件有意包含在同一个包中的类型，那么它们必须都保留在类路径中（即作为一个在类路径上的未命名模块而非在模块路径上的自动模块）。</p>
<p>因为这些JAR文件不能用作自动模块，为了启用迁移，我们会将自动模块，视为建立在显式模块和仍然处于类路径上的代码（未命名模块）之间的桥梁：自动模块除了读取其他所有命名模块之外，还将读取未命名的模块。如果我们的应用程序的原始类路径中，包含了JAR文件org-baz-fiz.jar和org-baz-fuz.jar，那么我们将有图：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-10.png" alt="module-pic-10"></p>
<p>如前所述，未命名模块导出其所有软件包，因此自动模块中的代码将能够访问所有从类路径加载的公用类型（即未命名模块中的所用公共类型）。</p>
<p>使用类路径中的类型的自动模块，不能将这些类型暴露给其他依赖于它的显式模块，因为显式模块无法声明对未命名模块的依赖关系。如果显式模块com.foo.app中的代码引用了一个自动模块com.foo.bar中的公共类型，并且自动模块com.foo.bar明确声明使用了仍在类路径上的一个JAR文件中的类型，则com.foo.app中的代码将无法访问该类路径上的类型，因为命名模块com.foo.bar不能依赖于未命名的模块。这可以通过将模块com.foo.app暂时视为自动模块来解决，以便其代码可以访问类路径中的类型，直到类路径上的相关JAR文件（未命名模块）可以被视为自动模块或转换为显式模块为止。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>利用服务接口和服务提供者的松散耦合是构建大型软件系统的强大工具。Java通过<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_blank" rel="noopener">java.util.ServiceLoader</a>类来支持服务，该类在运行时通过搜索类路径来定位服务提供者。对于在模块中定义的服务提供者，我们必须考虑如何在一组可观察模块中找到这些模块，解决它们的依赖性，并使提供者可以使用使用相应服务的代码。</p>
<p>假设，例如，我们的com.foo.app模块使用MySQL数据库，并且在具有声明的可观察模块中提供MySQL JDBC驱动程序</p>
<pre><code class="java">module com.mysql.jdbc {
    requires java.sql;
    requires org.slf4j;
    exports com.mysql.jdbc;
}
</code></pre>
<p>其中org.slf4j是驱动程序（jdbc driver）使用的日志记录库，并且com.mysql.jdbc是包含java.sql.Driver这一服务接口的具体实现的包。（实际上并不需要导出驱动程序包，我们这样做是为了使代码清晰可见。）</p>
<p>为了让java.sql模块使用这个驱动程序， ServiceLoader类必须能够通过反射来实例化驱动程序类; 为了实现这一点，模块系统必须将驱动模块添加到模块图中并解决其依赖性，因此：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-11.png" alt="module-pic-11"></p>
<p>为了实现这一点，模块系统必须能够识别所有使用服务的模块，然后从一组可观察模块中找到服务的提供者。</p>
<p>模块系统可以通过，扫描模包中的类文件并调用ServiceLoader::load方法，来识别对服务的使用，但是这样做不仅会很慢，而且并不可靠。模块使用特定服务应该是是模块的一个基本定义，所以为了效率和清晰度，我们在模块的声明中用一个uses子句来表示对服务的使用：</p>
<pre><code class="java">module java.sql {
    requires public java.logging;
    requires public java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
    uses java.sql.Driver;
}
</code></pre>
<p>模块系统可以通过扫描META-INF/services资源条目来识别服务提供者，就像现在ServiceLoader类所做的那样。但是，模块提供特定服务借口的具体实现同样很重要，所以我们在模块的声明中用一个provides子句表示模块的提供者：</p>
<pre><code class="java">module com.mysql.jdbc {
    requires java.sql;
    requires org.slf4j;
    exports com.mysql.jdbc;
    provides java.sql.Driver with com.mysql.jdbc.Driver;
}
</code></pre>
<p>现在，只要阅读这些模块的声明，就很容易看出来，其中一个m模块使用另一个提供的服务。</p>
<p>在模块声明中声明服务提供者和服务使用者的关系具有提高效率和代码清晰度的优势。这两种服务声明都可以在编译时进行解释，以确保服务提供者和服务使用者都可以访问服务接口（例如，java.sql.Driver）。服务提供者声明可以进一步解释，以确保提供者（例如，com.mysql.jdbc.Driver）确定实现其宣称的服务接口。服务使用的声明可以通过工具来提前编译，以确保在运行之前服务提供者能恰当的被编译。</p>
<p>出于迁移目的，如果定义自动模块的JAR文件包含META-INF/services资源条目，则将每个这样的条目视为该模块中的provides关键字的对应子句。自动模块被认为可以使用每一种可用的服务。</p>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p>本文档的其余部分讨论了高级特性，这些特性虽然很重要，但大多数开发人员可能并不感兴趣。</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>为了使模块图在运行时反射也可用，我们在java.lang.reflect包中定义了一个叫Module类，并在一个新的包java.lang.module中定义一些相关类型。Module类的一个实例在运行时代表一个单独的模块。每个类型都在一个模块中，因此每个Class对象都有一个关联的Module对象，该对象由新Class::getModule方法返回。</p>
<p>Module对象的基本操作是：</p>
<pre><code class="java">package java.lang.reflect;

public final class Module {
    public String getName();
    public ModuleDescriptor getDescriptor();
    public ClassLoader getClassLoader();
    public boolean canRead(Module target);
    public boolean isExported(String packageName);
}
</code></pre>
<p>其中ModuleDescriptor是java.lang.module包中的类，它的实例表示模块描述符; getClassLoader方法返回模块的类加载器; canRead方法告诉模块是否可以读取目标模块; isExported方法告诉模块是否导出给定的包。</p>
<p>java.lang.reflect包并不是平台上唯一的反射工具。相似的工具也被添加到javax.lang.model模块，为了支持编译时的注释处理和文档生成工具。</p>
<h4 id="反射的可读性"><a href="#反射的可读性" class="headerlink" title="反射的可读性"></a>反射的可读性</h4><p>框架是使用反射来加载，检查，并在运行时实例化的其他类的工具。Java SE平台本身的框架示例是服务加载器，资源包，动态代理和序列化，当然还有许多流行的外部框架库，用于数据库持久性，依赖注入和测试等多种用途。</p>
<p>鉴于需要在运行时发现类，框架必须能够访问其构造函数之一以实例化它。但事实表明，情况通常不会如此。</p>
<p>Java平台的<a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/package-summary.html" target="_blank" rel="noopener">XML解析器</a>，如果<a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/XMLInputFactory.html#newFactory--" target="_blank" rel="noopener">加载和实例化</a>由系统配置命名为javax.xml.stream.XMLInputFactory的<a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/XMLInputFactory.html" target="_blank" rel="noopener">XMLInputFactory</a>的服务实现，它就将通过ServiceLoader类，优先于所有服务提供者发现被发现。忽略异常处理和安全检查的代码大致如下所示：</p>
<pre><code class="java">String providerName
    = System.getProperty(&quot;javax.xml.stream.XMLInputFactory&quot;);
if (providerName != null) {
    Class providerClass = Class.forName(providerName, false,
                                        Thread.getContextClassLoader());
    Object ob = providerClass.newInstance();
    return (XMLInputFactory)ob;
}
// Otherwise use ServiceLoader
...
</code></pre>
<p>在模块化设置中，只要包含的服务提供者的类为上下文类加载器所知，Class::forName就仍将继续工作。但是，通过反射的方式调用服务提供者的newInstance方法将不起作用：服务提供者可能会从类路径加载，在这种情况下，它将位于未命名的模块中，或者它可能位于某个已命名的模块中，无论是哪种情况，我们的框架本身都在java.xml模块中。该模块仅依赖于基本模块，因此也只读取基本模块，此框架将无法访问任何其他模块中的服务提供者类。</p>
<p>为了使框架可以访问服务提供者类，我们需要使框架的模块可以读取服务提供者的模块。我们可以要求每个框架在运行时都明确地，将必要的可读性边缘添加到模块图中，就像本文档的早期版本一样，但是经验表明这种方法很麻烦并且会导致迁移的障碍。</p>
<p>因此，我们需要修改反射API，我们假设任何反射其他类型的代码，都位于一个可以访问到被反射类型所在模块的模块中。这使得上面的例子和其他类似的代码可以毫无改变地工作。这种方法不会削弱强封装：公开类型仍然必须位于导出的包中，以便从其所在模块外部进行访问，无论是通过编译代码还是通过反射。</p>
<blockquote>
<p>事实上，在这种需要发射其他模块的情况下，如果我们只想要反射共有类型，那只要在模块中导出相应的包就可以；但如果我们想要通过setAccessible(true)方法来反射私有类型是，必须在模块声明时添加open关键字或者opens子句，来使模块成为一个开放模块或者开放模块中的软件包，使反射对私有类型可见，否则就会在运行报出Accessing Error。这一点原作者并未提及，我个人认为这种设计很好的保证了模块的强封装的特性</p>
</blockquote>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>每个类型都在一个模块中，并且在运行时每个模块都有一个类加载器，但是类加载器是否只加载一个模块呢？事实上，模块系统对模块和类加载器之间的关系几乎没有限制。一个类加载器可以从一个模块或多个模块加载类型，只要这些模块不相互干扰，并且只有一个加载器加载了特定模块中的所有类型。</p>
<p>这种灵活性对于兼容性至关重要，因为它允许我们保留平台现有的内置类加载器的层次结构。引导类加载器（bootstrap classloader）和扩展类加载器（extension classloader）仍然存在，并用于从平台模块加载类型。应用程序类加载器（application classloader）仍然存在，用于从工件的模块路径中找到加载类型。</p>
<p>这种灵活性还会使模块化现有应用程序变得更加容易，这些应用程序已经构建了复杂的层次结构甚至自定义类加载器，因次我们可以将这些加载器升级到模块中的加载类型，而无需更改其委托模式。</p>
<blockquote>
<p>事实上，Java9的classloader是有改变的，这一部分我以后会单独写一篇文章来总结。如现在想了解请参考<a href="http://www.cnblogs.com/IcanFixIt/p/7131676.html" target="_blank" rel="noopener">此链接</a>中的扩展机制部分</p>
</blockquote>
<h4 id="未命名模块与类加载器"><a href="#未命名模块与类加载器" class="headerlink" title="未命名模块与类加载器"></a>未命名模块与类加载器</h4><p>我们之前了解到，如果某个类型未在命名模块中定义，那么它将被视为未命名模块的成员，但与未命名模块相关的是哪个类加载器呢？</p>
<p>事实证明，每个类加载器都有自己独特的未命名模块，它是由新ClassLoader::getUnnamedModule方法返回的。如果一个类加载器加载了一个没有在命名模块中定义的类型，那么该类型就被认为是在该加载器的未命名模块中。例如，Class类中的getModule方法将返回其加载器的未命名模块。应用加载器（application classloader）的未命名模块，会从类路径中加载不在任何模块下定义的包中的类型。</p>
<h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>模块系统并不指定模块和类加载器之间的关系，但为了加载特定的类型，它必须以某种方式能够找到合适的加载器。因此，在运行时，模块图的实例化会生成一个层（layer），这个层将图中的每个模块映射到负责加载该模块中的类型的唯一类加载器上。与可被发现的模块相反，引导层（boot layer）是由Java虚拟机在启动时通过解析应用程序的初始模块所创建的。</p>
<p>大多数应用程序以及几乎当前所有的应用程序都不会使用引导层以外的层。然而，多个层可用于带有插件的复杂应用程序或容器体系结构（如应用程序服务器，IDE和测试框架）。这样的应用程序可以使用动态的类加载和模块系统的反射API，来加载和运行由一个或多个模块组成的应用程序。然而，这通常需要添加两种额外的灵活性：</p>
<ol>
<li><p>使用模块的应用程序可能需要不同版本的已存在的模块。例如，Java EE Web应用程序可能需要java.xml.ws模块中的不同版本的JAX-WS，而不是内置于运行时环境的版本。</p>
</li>
<li><p>使用模块的应用程序可能需要已经被发现的服务提供者以外的服务提供者。应用程序甚至可能嵌入自己的首选服务提供者。Web应用程序，可能包含一个它所期望的<a href="https://github.com/FasterXML/woodstox" target="_blank" rel="noopener">Woodstox XML解析器</a>版本，在这种情况下，ServiceLoader类应优先返回它需要的服务提供者而不是任何其他的服务提供者。</p>
</li>
</ol>
<p>与可被发现的模块的环境相反，一个容器应用程序可以为一个使用模块的应用程序的初始模块，在其已有的层上创建一个新的层。这样的环境可以包含可升级平台模块的替代版本以及其他已存在于较低层的非平台模块，解析器优先解析这些备用模块。这种环境也可以在那些已经在较低层被发现的服务提供者之外发现不同的服务提供者; ServiceLoader类将在较低层返回服务提供者之前去加载这些服务提供者。</p>
<p>层可以堆叠：我们可以在引导层之上构建新层，然后再在其上创建另一个层。作为正常解析过程的结果，所指定的层中的模块可以读取该层中或下层中的模块。因此，层的模块图可以通过引用包括其下的每个层的模块图来表示。</p>
<blockquote>
<p>上面这一节翻译的不太好，事实上我也不太理解这一节的内容。以后会仔细研究一下，目前只知道现在JDK中已经有了ModuleLayer类，可以通过Module.getLayer()获得。</p>
</blockquote>
<h4 id="限制性导出"><a href="#限制性导出" class="headerlink" title="限制性导出"></a>限制性导出</h4><p>偶尔有必要安排某些类型在一组模块中可访问，但其他模块无法访问。</p>
<p>在标准JDK的java.sql模块和 java.xml模块的代码实现中，使用了java.base模块中的sun.reflect包下定义的类型 。为了让代码访问sun.reflect包中的类型，我们可以简单地从java.base模块中导出该包：</p>
<pre><code class="java">module java.base {
    ...
    exports sun.reflect;
}
</code></pre>
<p>然而，这将使得每个sun.reflect包中的类型对所有模块都可见（因为每个模块都读取java.base），而这是不合理的，因为该包中的一些类定义了有特权的，安全敏感的方法。</p>
<p>因此，我们扩展了模块声明以允许将包导出到一个或多个特定命名的模块，而不被其他模块可见。java.base模块的声明实际上只将sun.reflect包导出到特定的一组JDK模块：</p>
<pre><code class="java">module java.base {
    ...
    exports sun.reflect to
        java.corba,
        java.logging,
        java.sql,
        java.sql.rowset,
        jdk.scripting.nashorn;
}
</code></pre>
<p>通过在模块图中添加另一种类型的边缘（此处为彩色金色），可以将这些限制性的导出显示在模块图中：</p>
<p><img src="https://raw.githubusercontent.com/ShanyouYu-Sean/blog-images/master/java%20module%20system/example-module-12.png" alt="module-pic-12"></p>
<p>前面提到的可访问性规则如下所述：如果两种类型S并且T在不同模块中定义，并且T是public，则代码S可以在以下情况下访问T：</p>
<ol>
<li>S的模块读取T的模块，和</li>
<li>T的模块直接导出T的包到S的模块，亦或是导出到所有模块。</li>
</ol>
<p>我们为用于反射的Module类提供了一种方法，来确定是否将包导出到特定模块，而非所有模块：</p>
<pre><code class="java">public final class Module {
    ...
    public boolean isExported(String packageName, Module target);
}
</code></pre>
<p>限制性的导出可能会意外地将内部的类型到处到预期之外的模块，因此我们必须小心使用它们。例如命名一个名为java.corba的模块以访问sun.reflect包中的类型。为了防止这种情况，我们可以在构建时分析相关模块，并在每个模块的描述符中记录允许依赖它的模块内容的哈希值，并使用限制性导出。在分析期间，我们需要验证，那些使用限制性导出到其他命名模块的模块，其模块内容的哈希值，与引用该模块的模块中记录的该模块的哈希值匹配。只要声明和使用限制性的导出的模块以这种方式绑定在一起，限制性的导出就可以安全地在不受信任的环境中使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里描述了模块系统的很多方面，但大多数开发人员只需要使用其中的一部分。我们期望在未来几年内，大多数Java开发人员都会熟悉模块声明，模块化JAR文件，模块路径，可读性，可访问性，未命名模块，自动模块和模块化服务等基本概念。相比之下，反射可读性，层和限制性的导出等更高级功能可能被使用的可能性比较小。</p>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Project Jigsaw:Java模块系统快速入门指南]]></title>
      <url>/2018/03/29/java9-quick-guide/</url>
      <content type="html"><![CDATA[<p><strong>本文为openjdk官方java模块入门指南的翻译。(<a href="http://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener">原文地址</a>)</strong></p>
<p>本文档提供了一些让开发者快速上手Java模块系统的简单例子。<br>例子中的文件路径用/划分，文件分隔符是：，windows开发者请用\和；替换以上分隔符。</p>
<h3 id="Greetings"><a href="#Greetings" class="headerlink" title="Greetings"></a>Greetings</h3><p>第一个例子展示了一个打印”Greetings!”字符串的简单模块。这个模块由两个源文件组成（module-info.java和Main.java）。按照惯例，模块的源文件应该在一个以模块名字为命名的目录中。</p>
<pre><code class="java">src/com.greetings/com/greetings/Main.java
src/com.greetings/module-info.java

$ cat src/com.greetings/module-info.java
module com.greetings { }

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;
public class Main {
    public static void main(String[] args) {
        System.out.println(&quot;Greetings!&quot;);
    }
}
</code></pre>
<p>以下命令会将源文件编译到mods/com.greetings目录中：</p>
<pre><code class="bash">$ mkdir -p mods/com.greetings

$ javac -d mods/com.greetings \
    src/com.greetings/module-info.java \
    src/com.greetings/com/greetings/Main.java
</code></pre>
<p>现在我们用以下命令来运行这个例子：</p>
<pre><code class="bash">$ java --module-path mods -m com.greetings/com.greetings.Main
</code></pre>
<p>–module-path 是模块的路径，他的值是包含模块的一个或多个目录。<br>-m 指定了主模块，/后面的值是模块里包含main方法的全类名。</p>
<h3 id="Greetings-world"><a href="#Greetings-world" class="headerlink" title="Greetings world"></a>Greetings world</h3><p>第二个例子更新了第一个例子中的模块声明，它声明了需要一个名为org.astro的模块的依赖。<br>模块org.astro导出了名为org.astro的api包。</p>
<pre><code class="java">src/org.astro/module-info.java
src/org.astro/org/astro/World.java
src/com.greetings/com/greetings/Main.java
src/com.greetings/module-info.java

$ cat src/org.astro/module-info.java
module org.astro {
    exports org.astro;
}

$ cat src/org.astro/org/astro/World.java
package org.astro;
public class World {
    public static String name() {
        return &quot;world&quot;;
    }
}

$ cat src/com.greetings/module-info.java
module com.greetings {
    requires org.astro;
}

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;
import org.astro.World;
public class Main {
    public static void main(String[] args) {
        System.out.format(&quot;Greetings %s!%n&quot;, World.name());
    }
}
</code></pre>
<p>依次编译这两个模块，用javac命令在编译com.greetings模块时指定模块的路径，使得org.astro模块中的引用和其导出包中的类型可以被引用。</p>
<pre><code class="bash">$ mkdir -p mods/org.astro mods/com.greetings

$ javac -d mods/org.astro \
    src/org.astro/module-info.java src/org.astro/org/astro/World.java

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
</code></pre>
<p>使用与第一个例子相同的方式来运行这个例子：</p>
<pre><code class="bash">$ java --module-path mods -m com.greetings/com.greetings.Main
Greetings world!
</code></pre>
<h3 id="多模块编译"><a href="#多模块编译" class="headerlink" title="多模块编译"></a>多模块编译</h3><p>在上面的例子中，模块com.greetings和模块org.astro是分开编译的，我们也可以用一条javac命令来编译多个模块</p>
<pre><code class="bash">$ mkdir mods

$ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)

$ find mods -type f
mods/com.greetings/com/greetings/Main.class
mods/com.greetings/module-info.class
mods/org.astro/module-info.class
mods/org.astro/org/astro/World.class
</code></pre>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在目前的实例中，编译好的模块都分散在文件系统中，为了调度和部署，我们通常会把模块打包成模块化jar包，模块化jar包就是在jar包最顶层目录包含module-info.class的普通jar包。</p>
<p>以下命令将会在mlib目录中创建org.astro@1.0.jar和com.greetings.jar</p>
<pre><code class="bash">$ mkdir mlib

$ jar --create --file=mlib/org.astro@1.0.jar \
    --module-version=1.0 -C mods/org.astro .

$ jar --create --file=mlib/com.greetings.jar \
    --main-class=com.greetings.Main -C mods/com.greetings .

$ ls mlib
com.greetings.jar   org.astro@1.0.jar
</code></pre>
<p>在这个例子中，模块org.astro在打包时被指定了其版本号1.0，模块com.greetings在打包时被制定了其main方法主类com.greetings.Main。</p>
<p>现在，我们可以直接运行模块com.greetings而无需制定其main class</p>
<pre><code class="bash">$ java -p mlib -m com.greetings
Greetings world!
</code></pre>
<p>命令可以用-p来替代–module-path。</p>
<p>jar命令拥有许多新选项，其中一个就是打印模块化jar包中声明的模块。</p>
<pre><code class="bash">$ jar --describe-module --file=mlib/org.astro@1.0.jar
org.astro@1.0 jar:file:///d/mlib/org.astro@1.0.jar/!module-info.class
exports org.astro
requires java.base mandated
</code></pre>
<h3 id="缺少requires或者exports关键字"><a href="#缺少requires或者exports关键字" class="headerlink" title="缺少requires或者exports关键字"></a>缺少requires或者exports关键字</h3><p>如果我们在com.greetings模块中遗漏了requires关键字：</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    // requires org.astro;
}

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
    import org.astro.World;
                ^
    (package org.astro is declared in module org.astro, but module com.greetings does not read it)
1 error
</code></pre>
<p>如果我们在org.astro模块中遗漏了exports关键字：</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    requires org.astro;
}
$ cat src/org.astro/module-info.java
module org.astro {
    // exports org.astro;
}

$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
$ javac --module-path mods -d mods/com.greetings \
    src/com.greetings/module-info.java src/com.greetings/com/greetings/Main.java
src/com.greetings/com/greetings/Main.java:2: error: package org.astro is not visible
    import org.astro.World;
                ^
    (package org.astro is declared in module org.astro, which does not export it)
1 error
</code></pre>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务允许服务提供者和服务消费者中建立松散的耦合结构。在这个例子中，存在这一个服务提供者和一个服务消费者：模块com.socket提供了API用来做network socket；模块org.fastsocket是一个服务提供模块，它提供了com.socket.spi.NetworkSocketProvider的实现，并且不导出任何包。</p>
<p>下面是模块com.socket的代码：</p>
<pre><code class="java">$ cat src/com.socket/module-info.java
module com.socket {
    exports com.socket;
    exports com.socket.spi;
    uses com.socket.spi.NetworkSocketProvider;
}

$ cat src/com.socket/com/socket/NetworkSocket.java
package com.socket;

import java.io.Closeable;
import java.util.Iterator;
import java.util.ServiceLoader;

import com.socket.spi.NetworkSocketProvider;

public abstract class NetworkSocket implements Closeable {
    protected NetworkSocket() { }

    public static NetworkSocket open() {
        ServiceLoader&lt;NetworkSocketProvider&gt; sl
            = ServiceLoader.load(NetworkSocketProvider.class);
        Iterator&lt;NetworkSocketProvider&gt; iter = sl.iterator();
        if (!iter.hasNext())
            throw new RuntimeException(&quot;No service providers found!&quot;);
        NetworkSocketProvider provider = iter.next();
        return provider.openNetworkSocket();
    }
}


$ cat src/com.socket/com/socket/spi/NetworkSocketProvider.java
package com.socket.spi;

import com.socket.NetworkSocket;

public abstract class NetworkSocketProvider {
    protected NetworkSocketProvider() { }

    public abstract NetworkSocket openNetworkSocket();
}
</code></pre>
<p>以下是模块org.fastsocket的代码</p>
<pre><code class="java">$ cat src/org.fastsocket/module-info.java
module org.fastsocket {
    requires com.socket;
    provides com.socket.spi.NetworkSocketProvider
        with org.fastsocket.FastNetworkSocketProvider;
}

$ cat src/org.fastsocket/org/fastsocket/FastNetworkSocketProvider.java
package org.fastsocket;

import com.socket.NetworkSocket;
import com.socket.spi.NetworkSocketProvider;

public class FastNetworkSocketProvider extends NetworkSocketProvider {
    public FastNetworkSocketProvider() { }

    @Override
    public NetworkSocket openNetworkSocket() {
        return new FastNetworkSocket();
    }
}

$ cat src/org.fastsocket/org/fastsocket/FastNetworkSocket.java
package org.fastsocket;

import com.socket.NetworkSocket;

class FastNetworkSocket extends NetworkSocket {
    FastNetworkSocket() { }
    public void close() { }
}
</code></pre>
<p>为了简单化，我们同时编译两个模块，但事实上，服务提供者和服务消费者几乎总是分开编译的</p>
<pre><code class="bash">$ mkdir mods
$ javac -d mods --module-source-path src $(find src -name &quot;*.java&quot;)
</code></pre>
<p>最后我们对模块com.greetings用新的模块的api做更改</p>
<pre><code class="java">$ cat src/com.greetings/module-info.java
module com.greetings {
    requires com.socket;
}

$ cat src/com.greetings/com/greetings/Main.java
package com.greetings;

import com.socket.NetworkSocket;

public class Main {
    public static void main(String[] args) {
        NetworkSocket s = NetworkSocket.open();
        System.out.println(s.getClass());
    }
}


$ javac -d mods/com.greetings/ -p mods $(find src/com.greetings/ -name &quot;*.java&quot;)
</code></pre>
<p>最后，我们运行com.greetings模块</p>
<pre><code class="bash">$ java -p mods -m com.greetings/com.greetings.Main
class org.fastsocket.FastNetworkSocket
</code></pre>
<p>输出结果确认服务提供者已经被定位成功。</p>
<h3 id="The-linker"><a href="#The-linker" class="headerlink" title="The linker"></a>The linker</h3><p>jlink是一个用来在一组拥有传递性依赖的模块之中，建立一个自定义的模块化可运行镜像的工具。</p>
<p>此工具目前需要制定模块路径的模块化jar包或者jmod格式。jdk会将标准的或jdk指定的模块以jmod格式打包。</p>
<p>以下命令会创建一个包含模块com.greetings和其传递性依赖的可运行镜像。</p>
<pre><code class="bash">jlink --module-path $JAVA_HOME/jmods:mlib --add-modules com.greetings --output greetingsapp
</code></pre>
<p>–module-path的值是包含打包后的模块的路径。在windows下需要将’:’替换成’;’。<br>$JAVA_HOME/jmods是包含java.base.jmod和其他标准化jdk模块的路径。mlib路径包含模块com.greetings的artifact。</p>
<p>jlink工具也包含许多高级的选项来自定义镜像，详见jlink –help</p>
<h3 id="–patch-module"><a href="#–patch-module" class="headerlink" title="–patch-module"></a>–patch-module</h3><p>开发者常会从Doug Lea的CVS中checkout出java.util.concurrent下的类并用-Xbootclasspath/p来替换源文件编译。(我都不知道Doug Lea还在更新juc的代码，膜拜大神)</p>
<p>现在-Xbootclasspath/p已经被舍弃，它在模块化系统中替代是–patch-module，用来替换模块中的类，它也可以被用来增大模块的内容。</p>
<p>javac命令同样也支持–patch-module选项用来编译模块中的as if部分。</p>
<p>以下是用新版本的java.util.concurrent.ConcurrentHashMap来编译并用其运行的例子</p>
<pre><code class="bash">javac --patch-module java.base=src -d mypatches/java.base \
    src/java.base/java/util/concurrent/ConcurrentHashMap.java

java --patch-module java.base=mypatches/java.base ...
</code></pre>
<h3 id="更多链接"><a href="#更多链接" class="headerlink" title="更多链接"></a>更多链接</h3><ul>
<li><a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener">The State of the Module System</a></li>
<li><a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">JEP 261: Module System</a></li>
<li><a href="http://openjdk.java.net/projects/jigsaw/" target="_blank" rel="noopener">Project Jigsaw</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java 9 </category>
            
            <category> Java module </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java 9 </tag>
            
            <tag> Java module </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>不是所有的树</p>
<p>都能在自己的家乡终老</p>
<p>不是所有的轨道</p>
<p>都通往春暖花开的地方</p>
<p>不是所有的花都会盛开</p>
<p>不是所有的约定的人都会到来</p>
<p>我知道，是流星赞美了黑夜</p>
<p>鲸鱼安慰了大海</p>
<hr>
<p><strong>Sean the Fish</strong></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=4882391&auto=0&height=66"></iframe>

<p>Java码农，目前供职于IBM。</p>
<p>博客刚刚建立，希望自己能坚持写下去。</p>
<p>Email：a728976009@hotmail.com</p>
<hr>
<p>想在天井里盛一只玻璃杯</p>
<p>明朝看天下雨今夜落几寸</p>
]]></content>
    </entry>
    
  
</search>
