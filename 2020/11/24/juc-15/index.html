<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.6 -->
    <script>
        window.materialVersion = "1.5.6"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0',
            '1.5.2',
            '1.5.5'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">





    <link rel="dns-prefetch" href="https://seanthefish.disqus.com"/>



    <link rel="dns-prefetch" href="https://hm.baidu.com"/>

    <link rel="dns-prefetch" href="https://www.google-analytics.com"/>



    <link rel="dns-prefetch" href="https://fonts.googleapis.com"/>





    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            juc之ConcurrentHashMap | 
        
        小鱼肖恩
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="我知道，是流星赞美了黑夜，鲸鱼安慰了大海">
    <meta name="keywords" content="小鱼肖恩,并发">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?NKhlKQkXw/c66TR5p4wO+w==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/tomorrow-night-eighties.min.css?2LJQzURO+Kr8r/fl/T8oMA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.png);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="小鱼肖恩">
    <meta name="msapplication-starturl" content="http://seanthefish.com/2020/11/24/juc-15/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="小鱼肖恩">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    <meta name="google-site-verification" content="yPRDDgFzGqTTSzJHMSTM_p8iRbLSu4ZEXY4qP5402-A" />
    <meta name="baidu-site-verification" content="PnMjc2amR8" />

    <!-- RSS -->
    
        
            <link rel=alternate type="application/atom+xml" href="#">
        
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://seanthefish.com/2020/11/24/juc-15/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="juc之ConcurrentHashMap | 小鱼肖恩">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="我知道，是流星赞美了黑夜，鲸鱼安慰了大海">
    <meta property="og:article:tag" content="并发"> 

    
        <meta property="article:published_time" content="Tue Nov 24 2020 15:00:00 GMT+0800">
        <meta property="article:modified_time" content="Sun Dec 06 2020 21:20:09 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://seanthefish.com/2020/11/24/juc-15/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://seanthefish.com/2020/11/24/juc-15/index.html",
    "headline": "juc之ConcurrentHashMap",
    "datePublished": "Tue Nov 24 2020 15:00:00 GMT+0800",
    "dateModified": "Sun Dec 06 2020 21:20:09 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "Sean Yu",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "我知道，是流星赞美了黑夜，鲸鱼安慰了大海"
    },
    "publisher": {
        "@type": "Organization",
        "name": "小鱼肖恩",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",并发小鱼肖恩",
    "description": "我知道，是流星赞美了黑夜，鲸鱼安慰了大海",
}
</script>


    

    <!-- Analytics -->
    
        <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-111600306-1', 'auto');ga('send', 'pageview');
</script>
    
    
        <script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?c6e0a40db670e2f36cb44d2882dfd3c5';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(hm, s);
    })();
</script>
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span id="MD-burger-id" class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#jdk-1-7"><span class="post-toc-number">1.</span> <span class="post-toc-text">jdk 1.7</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Segment-类"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Segment 类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashEntry-类"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">HashEntry 类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#构造函数"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#put-方法"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">put() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#hash-方法"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">hash() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Segment-put-方法"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">Segment.put() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Segment-scanAndLockForPut-方法"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">Segment.scanAndLockForPut() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Segment-rehash-扩容方法"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">Segment.rehash() 扩容方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get-方法"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">get() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#size-方法"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">size() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#isEmpty-方法"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">isEmpty() 方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#jdk1-8"><span class="post-toc-number">2.</span> <span class="post-toc-text">jdk1.8</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#核心属性"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">核心属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Node-类"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Node 类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TreeNode类"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">TreeNode类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TreeBin类"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">TreeBin类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ForwardingNode-类"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">ForwardingNode 类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#构造函数-1"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#put-方法-1"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">put() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#spread-方法"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">spread() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#putVal-方法"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">putVal() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#initTable-初始化方法"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">initTable() 初始化方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#helpTransfer-帮助扩容"><span class="post-toc-number">2.11.</span> <span class="post-toc-text">helpTransfer()帮助扩容</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#transfer-扩容方法"><span class="post-toc-number">2.12.</span> <span class="post-toc-text">transfer() 扩容方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#addCount-方法"><span class="post-toc-number">2.13.</span> <span class="post-toc-text">addCount() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sumCount-方法"><span class="post-toc-number">2.14.</span> <span class="post-toc-text">sumCount() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get-方法-1"><span class="post-toc-number">2.15.</span> <span class="post-toc-text">get() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#size-方法-1"><span class="post-toc-number">2.16.</span> <span class="post-toc-text">size()方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#弱一致性"><span class="post-toc-number">2.17.</span> <span class="post-toc-text">弱一致性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JDK1-8与JDK1-7的不同点"><span class="post-toc-number">2.18.</span> <span class="post-toc-text">JDK1.8与JDK1.7的不同点</span></a></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 23 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/title-pic-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                juc之ConcurrentHashMap
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Sean Yu</strong>
        <span>11月 24, 2020</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    
        <button id="article-functions-qrcode-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">devices other</i>
    <span class="visuallyhidden">devices other</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-qrcode-button">
    <li class="mdl-menu__item">在其它设备中阅读本文章</li>
    
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACZUlEQVR42u3aQW7DMAwEwPz/0+21QJt0l5IVIxidgkKwND6YLMnH10evBx4eHh4eHh4e3s14j3j93v/zL7+f+cfBwZNX7oaHh4d3kvfPp/bJJZ4eEOx5xli5Gx4eHt55XvvJTjDJ7/y1RnfDw8PDuxkvOSBJkV+nznh4eHifxFtBtnvw8PDw7s8r/uGPL9qm0W+uteDh4eHFvLYBdvL3G/p7eHh4eC957SqOWdi5dEM8PDy8i3lJEpyHh5UyRJvK10NXeHh4eJt4SYNqV5EiCQ95qywqRuDh4eFdxktCwrA0EJdx86S8KOPi4eHhHeG9TqOLY0awdjQ2qrXg4eHhbeXNSgm7gkFenijGvPDw8PCO8FbaVLPhqpzR7sHDw8M7w2sLr0mBNX81SVjKxwvw8PDwruYN09ZyvKA9qy2F4OHh4Z3krXz02wJrHnLw8PDw7s/LCwG7Cq/tIMJwdAAPDw/vYl6ezubp76zZtjSIgIeHh3eEN7virMg7S7jzcIWHh4d3NS85vsWvD6q2jTQ8PDy8k7zZ0FV+3VlReHYiHh4e3hneLADkSXlbDp4tPDw8vPO8PLVt21rJS2zxdWDAw8PD28rLm1KzgYM2WW/DQN3fw8PDw1vmtWvWEmsZebqPh4eHd563PjY6I7XljGKECw8PD+8ILw8GSRliVkpInhC9UDw8PLyDvLyVlQSP9bZWHpzw8PDw7sxrB7OSD/0sRNUNMDw8PLy38vKD2zGsvPBR9/fw8PDwLuCtNL1WPvp5qTe6Gx4eHt4R3q4G2HoheEbCw8PDO8n7vIWHh4eHh4eHh3eD9Q0YFysm8MO5iQAAAABJRU5ErkJggg==">
    
</ul>

    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/并发/">并发</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=juc之ConcurrentHashMap&url=http://seanthefish.com/2020/11/24/juc-15/index.html&pic=http://seanthefish.com/img/favicon.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    

    <!-- Share Facebook -->
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://seanthefish.com/2020/11/24/juc-15/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=小鱼肖恩&title=juc之ConcurrentHashMap&summary=我知道，是流星赞美了黑夜，鲸鱼安慰了大海&pics=http://seanthefish.com/img/favicon.png&url=http://seanthefish.com/2020/11/24/juc-15/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <p>搬运自 <a href="https://my.oschina.net/xiaolyuh/blog/3080609" target="_blank" rel="noopener">https://my.oschina.net/xiaolyuh/blog/3080609</a>  略有修改</p>
<h2 id="jdk-1-7"><a href="#jdk-1-7" class="headerlink" title="jdk 1.7"></a>jdk 1.7</h2><p>在jdk1.7中，用的是锁分段技术：</p>
<p>底层存储结构<br>在 JDK1.7中，本质上还是采用链表+数组的形式存储键值对的。但是，为了提高并发，把原来的整个 table 划分为 n 个 Segment 。所以，从整体来看，它是一个由 Segment 组成的数组。然后，每个 Segment 里边是由 HashEntry 组成的数组，每个 HashEntry之间又可以形成链表。我们可以把每个 Segment 看成是一个小的 HashMap，其内部结构和 HashMap 是一模一样的。</p>
<p><img src="https://i.loli.net/2020/11/24/KTmC3ynGUb69ZQO.png" alt="image.png"></p>
<p>当对某个 Segment 加锁时，如图中 Segment2，并不会影响到其他 Segment 的读写。每个 Segment 内部自己操作自己的数据。这样一来，我们要做的就是尽可能的让元素均匀的分布在不同的 Segment中。最理想的状态是，所有执行的线程操作的元素都是不同的 Segment，这样就可以降低锁的竞争。</p>
<p>采用Segment数组结构和HashEntry数组结构组成，Segment数组的大小就是ConcurrentHashMap的并发度。Segment继承自ReentrantLock，所以他本身就是一个锁。Segment数组一旦初始化后就不会再进行扩容，这也是jdk1.8去掉他的原因。Segment里面又包含了一个table数组，这个数组是可以扩容的。</p>
<p>如图我们在定位数据的时候需要对key的hash值进行两次寻址操作，第一次找到在Segment数组的位置，第二次找到在table数组中的位置。</p>
<h3 id="Segment-类"><a href="#Segment-类" class="headerlink" title="Segment 类"></a>Segment 类</h3><pre><code class="java">// 直接继承自ReentrantLock，所以一个Segment本身就是一个锁
static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable { 
    ...
   // table数组  
   transient volatile HashEntry&lt;K,V&gt;[] table;

    // 一个Segment内的元素个数
    transient int count;

    // 扩容阈值
    transient int threshold;

    // 扩容因子
    final float loadFactor;

    Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) {
        this.loadFactor = lf;
        this.threshold = threshold;
        this.table = tab;
    }
...
</code></pre>
<p>我们发现Segment直接继承自ReentrantLock，所以一个Segment本身就是一个锁。所以Segment数组的长度大小直接影响了ConcurrentHashMap的并发度。还有每个Segment单独维护了扩容阈值，扩容因子，所以每个Segment的扩容操作时完全独立互不干扰的。</p>
<h3 id="HashEntry-类"><a href="#HashEntry-类" class="headerlink" title="HashEntry 类"></a>HashEntry 类</h3><pre><code class="java">static final class HashEntry&lt;K,V&gt; {
    // 不可变
    final int hash;
    final K key;
    // volatile保证可见性，这样我们在get操作时就不用加锁了
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;

    HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
...
}
</code></pre>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="java">public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    //  参数校验
    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
        throw new IllegalArgumentException();
    // 并发度控制，最大是65536
    if (concurrencyLevel &gt; MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    // 等于ssize从1向左移位的 次数
    int sshift = 0;
    int ssize = 1;
    // 找出最接近concurrencyLevel的2的n次幂的数值
    while (ssize &lt; concurrencyLevel) {
        ++sshift;
        ssize &lt;&lt;= 1;
    }
    // 这里之所 以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的
    this.segmentShift = 32 - sshift;
    // 散列运算的掩码，等于ssize减1
    this.segmentMask = ssize - 1;
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize &lt; initialCapacity)
        ++c;
    // 里HashEntry数组的长度度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    // 保证HashEntry数组大小一定是2的n次幂
    while (cap &lt; c)
        cap &lt;&lt;= 1;
    // create segments and segments[0]
    // 初始化Segment数组，并实际只填充Segment数组的第0个元素。
    Segment&lt;K,V&gt; s0 =
        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}`
</code></pre>
<p>通过代码我们可以看出，在构造ConcurrentHashMap的时候我们就会完成以下件事情：</p>
<ul>
<li>确认ConcurrentHashMap的并发度，也就是Segment数组长度，并保证它是2的n次幂</li>
<li>确认HashEntry数组的初始化长度，并保证它是2的n次幂</li>
<li>将Segment数组初始化好并且只填充第0个元素</li>
</ul>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h3><pre><code class="java">public V put(K key, V value) {
    Segment&lt;K,V&gt; s;
    if (value == null)
        throw new NullPointerException();
    // 1. 先获取key的hash值
    int hash = hash(key);
    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        // 2. 定位到Segment
        s = ensureSegment(j);
    // 3.调用Segment的put方法
    return s.put(key, hash, value, false);
}
</code></pre>
<p>主要流程是：</p>
<ul>
<li>先获取key的hash值</li>
<li>定位到Segment</li>
<li>调用Segment的put方法</li>
</ul>
<h3 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash() 方法"></a>hash() 方法</h3><pre><code class="java">private int hash(Object k) {
        int h = hashSeed;

        if ((0 != h) &amp;&amp; (k instanceof String)) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        // Spread bits to regularize both segment and index locations,
        // using variant of single-word Wang/Jenkins hash.
        h += (h &lt;&lt;  15) ^ 0xffffcd7d;
        h ^= (h &gt;&gt;&gt; 10);
        h += (h &lt;&lt;   3);
        h ^= (h &gt;&gt;&gt;  6);
        h += (h &lt;&lt;   2) + (h &lt;&lt; 14);
        return h ^ (h &gt;&gt;&gt; 16);
    }
</code></pre>
<p>这个方法大致思路是：先拿到key的hashCode，然后对这个值进行再散列。</p>
<h3 id="Segment-put-方法"><a href="#Segment-put-方法" class="headerlink" title="Segment.put() 方法"></a>Segment.put() 方法</h3><pre><code class="java">final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // 1. 加锁
    HashEntry&lt;K,V&gt; node = tryLock() ? null :
            // scanAndLockForPut在没有获取到锁的情况下，去查询key是否存在，如果不存在就新建一个Node
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry&lt;K,V&gt;[] tab = table;
        // 确定元素在table数组上的位置
        int index = (tab.length - 1) &amp; hash;
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);
        for (HashEntry&lt;K,V&gt; e = first;;) {
            if (e != null) {
                K k;
                // 如果原来位置上有值并且key相同，那么直接替换原来的value
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;&amp; key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                // 元素总数加一
                int c = count + 1;
                // 判断是否需要扩容
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}
</code></pre>
<p>大致过程是：</p>
<ul>
<li>加锁</li>
<li>定位key在table数组上的索引位置index，获取到头结点</li>
<li>判断是否有hash冲突</li>
<li>如果没有冲突直接将新节点node添加到数组index索引位</li>
<li>如果有冲突，先判断是否有相同key</li>
<li>有相同key直接替换对应node的value值</li>
<li>没有添加新元素到链表尾部</li>
<li>解锁<br>这里需要注意的是scanAndLockForPut方法，他在没有获取到锁的时候不仅会通过自旋获取锁，还会做一些其他的查找或新增节点的工，以此来提升put性能。</li>
</ul>
<h3 id="Segment-scanAndLockForPut-方法"><a href="#Segment-scanAndLockForPut-方法" class="headerlink" title="Segment.scanAndLockForPut() 方法"></a>Segment.scanAndLockForPut() 方法</h3><pre><code class="java">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {
    //定位HashEntry数组位置，获取第一个节点
    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);
    HashEntry&lt;K,V&gt; e = first;
    HashEntry&lt;K,V&gt; node = null;
    //扫描次数，循环标记位
    int retries = -1; // negative while locating node
    while (!tryLock()) {
        HashEntry&lt;K,V&gt; f; // to recheck first below
        // 表示遍历链表还没有结束
        if (retries &lt; 0) {
            if (e == null) {
                if (node == null) // speculatively create node
                    //  完成新节点初始化
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);
                // 完成链表的遍历，还是没有找到相同key的节点
                retries = 0;
            }
            // 有hash冲突，开始查找是否有相同的key
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        // 断循环次数是否大于最大扫描次数
        else if (++retries &gt; MAX_SCAN_RETRIES) {
            // 自旋获取锁
            lock();
            break;
        }
        // 每间隔一次循环，检查一次first节点是否改变
        else if ((retries &amp; 1) == 0 &amp;&amp;
                 (f = entryForHash(this, hash)) != first) {
            // 首节点有变动，更新first，重新扫描
            e = first = f; // re-traverse if entry changed
            retries = -1;
        }
    }
    return node;
}
</code></pre>
<p>scanAndLockForPut方法在当前线程获取不到segment锁的情况下，完成查找或新建节点的工作。当获取到锁后直接将该节点加入链表即可，提升了put操作的性能。大致过程：</p>
<ul>
<li>定位key在HashEntry数组的索引位，并获取第一个节点</li>
<li>尝试获取锁，如果成功直接返回，否则进入自旋</li>
<li>判断是否有hash冲突，没有就直接完成新节点的初始化</li>
<li>有hash冲突，开始遍历链表查找是否有相同key</li>
<li>如果没找到相同key，那么就完成新节点的初始化</li>
<li>如果找到相同key，判断循环次数是否大于最大扫描次数</li>
<li>如果循环次数大于最大扫描次数，就直接CAS拿锁（阻塞式）</li>
<li>如果循环次数不大于最大扫描次数，判断头结点是否有变化</li>
<li>进入下次循环</li>
</ul>
<h3 id="Segment-rehash-扩容方法"><a href="#Segment-rehash-扩容方法" class="headerlink" title="Segment.rehash() 扩容方法"></a>Segment.rehash() 扩容方法</h3><pre><code class="java">private void rehash(HashEntry&lt;K,V&gt; node) {
    // 复制老数组
    HashEntry&lt;K,V&gt;[] oldTable = table;
    int oldCapacity = oldTable.length;
    // table数组扩容2倍
    int newCapacity = oldCapacity &lt;&lt; 1;
    // 扩容阈值也增加两倍
    threshold = (int)(newCapacity * loadFactor);
    // 创建新数组
    HashEntry&lt;K,V&gt;[] newTable =
        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];
    // 计算新的掩码
    int sizeMask = newCapacity - 1;
    for (int i = 0; i &lt; oldCapacity ; i++) {
        HashEntry&lt;K,V&gt; e = oldTable[i];
        if (e != null) {
            HashEntry&lt;K,V&gt; next = e.next;
            // 计算新的索引位
            int idx = e.hash &amp; sizeMask;
            // 转移数据
            if (next == null)   //  Single node on list
                newTable[idx] = e;
            else { // Reuse consecutive sequence at same slot
                HashEntry&lt;K,V&gt; lastRun = e;
                int lastIdx = idx;
                for (HashEntry&lt;K,V&gt; last = next;
                     last != null;
                     last = last.next) {
                    int k = last.hash &amp; sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                newTable[lastIdx] = lastRun;
                // Clone remaining nodes
                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {
                    V v = p.value;
                    int h = p.hash;
                    int k = h &amp; sizeMask;
                    HashEntry&lt;K,V&gt; n = newTable[k];
                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);
                }
            }
        }
    }
    // 将新的节点加到对应索引位
    int nodeIndex = node.hash &amp; sizeMask; // add the new node
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    table = newTable;
}
</code></pre>
<p>在这里我们可以发现每次扩容是针对一个单独的Segment的，在扩容完成之前中不会对扩容前的数组进行修改，这样就可以保证get()不被扩容影响。大致过程是：</p>
<ul>
<li>新建扩容后的数组，容量是原来的两倍</li>
<li>遍历扩容前的数组</li>
<li>通过e.hash &amp; sizeMask;计算key新的索引位</li>
<li>转移数据</li>
<li>将扩容后的数组指向成员变量table</li>
</ul>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get() 方法"></a>get() 方法</h3><pre><code class="java">public V get(Object key) {
    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead
    HashEntry&lt;K,V&gt;[] tab;
    int h = hash(key);
    // 计算出Segment的索引位
    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
    // 以原子的方式获取Segment
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;
        (tab = s.table) != null) {
        // 原子方式获取HashEntry
        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            // key相同
            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))
                // value是volatile所以可以不加锁直接取值返回
                return e.value;
        }
    }
    return null;
}
</code></pre>
<p>我们可以看到get方法是没有加锁的，因为HashEntry的value和next属性是volatile的，volatile直接保证了可见性，所以读的时候可以不加锁.</p>
<h3 id="size-方法"><a href="#size-方法" class="headerlink" title="size() 方法"></a>size() 方法</h3><pre><code class="java">public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment&lt;K,V&gt;[] segments = this.segments;
    int size;
    // true表示size溢出32位（大于Integer.MAX_VALUE）
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn&#39;t retry
    try {
        for (;;) {
            // retries 如果retries等于2则对所有Segment加锁
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            // 统计每个Segment元素个数
            for (int j = 0; j &lt; segments.length; ++j) {
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c &lt; 0 || (size += c) &lt; 0)
                        overflow = true;
                }
            }
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        // 解锁
        if (retries &gt; RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    // 如果size大于Integer.MAX_VALUE值则直接返货Integer.MAX_VALUE
    return overflow ? Integer.MAX_VALUE : size;
}
</code></pre>
<p>size的核心思想是先进性两次不加锁统计，如果两次的值一样则直接返回，否则第三个统计的时候会将所有segment全部锁定，再进行size统计，所以size()尽量少用。因为这是在并发情况下，size其他线程也会改变size大小，所以size()的返回值只能表示当前线程、当时的一个状态，可以算其实是一个预估值。</p>
<h3 id="isEmpty-方法"><a href="#isEmpty-方法" class="headerlink" title="isEmpty() 方法"></a>isEmpty() 方法</h3><pre><code class="java">public boolean isEmpty() {
    long sum = 0L;
    final Segment&lt;K,V&gt;[] segments = this.segments;
    for (int j = 0; j &lt; segments.length; ++j) {
        Segment&lt;K,V&gt; seg = segmentAt(segments, j);
        if (seg != null) {
            // 只要有一个Segment的元素个数不为0则表示不为null
            if (seg.count != 0)
                return false;
            // 统计操作总数
            sum += seg.modCount;
        }
    }
    if (sum != 0L) { // recheck unless no modifications
        for (int j = 0; j &lt; segments.length; ++j) {
            Segment&lt;K,V&gt; seg = segmentAt(segments, j);
            if (seg != null) {
                if (seg.count != 0)
                    return false;
                sum -= seg.modCount;
            }
        }
        // 说明在统计过程中ConcurrentHashMap又被操作过，
        // 因为上面判断了ConcurrentHashMap不可能会有元素，所以这里如果有操作一定是新增节点
        if (sum != 0L)
            return false;
    }
    return true;
}
</code></pre>
<ul>
<li>先判断Segment里面是否有元素，如果有直接返回，如果没有则统计操作总数；</li>
<li>为了保证在统计过程中ConcurrentHashMap里面的元素没有发生变化，再对所有的Segment的操作数做了统计；</li>
<li>最后 sum==0 表示ConcurrentHashMap里面确实没有元素返回true，否则一定进行过新增元素返回false。<br>和size方法一样这个方法也是一个若一致方法，最后的结果也是一个预估值。</li>
</ul>
<h2 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h2><p><img src="https://i.loli.net/2020/11/25/cM5TOhxaEjqLQid.png" alt="image.png"></p>
<p>这个结构和HashMap一样</p>
<h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><pre><code class="java">//最大容量
private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
//初始容量
private static final int DEFAULT_CAPACITY = 16;
//数组最大容量
static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
//默认并发度，兼容1.7及之前版本
private static final int DEFAULT_CONCURRENCY_LEVEL = 16;
//加载/扩容因子，实际使用n - (n &gt;&gt;&gt; 2)
private static final float LOAD_FACTOR = 0.75f;
//链表转红黑树的节点数阀值
static final int TREEIFY_THRESHOLD = 8;
//红黑树转链表的节点数阀值
static final int UNTREEIFY_THRESHOLD = 6;
//当数组长度还未超过64,优先数组的扩容,否则将链表转为红黑树
static final int MIN_TREEIFY_CAPACITY = 64;
//扩容时任务的最小转移节点数
private static final int MIN_TRANSFER_STRIDE = 16;
//sizeCtl中记录stamp的位数
private static int RESIZE_STAMP_BITS = 16;
//帮助扩容的最大线程数
private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;
//size在sizeCtl中的偏移量
private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;

// ForwardingNode标记节点的hash值（表示正在扩容）
static final int MOVED     = -1; // hash for forwarding nodes
// TreeBin节点的hash值，它是对应桶的根节点
static final int TREEBIN   = -2; // hash for roots of trees
static final int RESERVED  = -3; // hash for transient reservations
static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash

//存放Node元素的数组,在第一次插入数据时初始化
transient volatile Node&lt;K,V&gt;[] table;
//一个过渡的table表,只有在扩容的时候才会使用
private transient volatile Node&lt;K,V&gt;[] nextTable;
//基础计数器值(size = baseCount + CounterCell[i].value)
private transient volatile long baseCount;
/**
 * 控制table数组的初始化和扩容，不同的值有不同的含义：
 * -1:表示正在初始化
 * -n:表示正在扩容
 * 0:表示还未初始化，默认值
 * 大于0：表示下一次扩容的阈值
 */
private transient volatile int sizeCtl;
//节点转移时下一个需要转移的table索引
private transient volatile int transferIndex;
//元素变化时用于控制自旋
private transient volatile int cellsBusy;
// 保存table中的每个节点的元素个数 长度是2的幂次方，初始化是2，每次扩容为原来的2倍
// size = baseCount + CounterCell[i].value
private transient volatile CounterCell[] counterCells;
</code></pre>
<h3 id="Node-类"><a href="#Node-类" class="headerlink" title="Node 类"></a>Node 类</h3><pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    volatile V val;
    volatile Node&lt;K,V&gt; next;

    Node(int hash, K key, V val, Node&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.val = val;
        this.next = next;
    }
...
</code></pre>
<p>链表节点，保存着key和value的值。</p>
<h3 id="TreeNode类"><a href="#TreeNode类" class="headerlink" title="TreeNode类"></a>TreeNode类</h3><pre><code class="java">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; parent;  // red-black tree links
    TreeNode&lt;K,V&gt; left;
    TreeNode&lt;K,V&gt; right;
    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
    boolean red;

    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next,
             TreeNode&lt;K,V&gt; parent) {
        super(hash, key, val, next);
        this.parent = parent;
    }
...
</code></pre>
<p>红黑树节点，包含了树的信息。</p>
<h3 id="TreeBin类"><a href="#TreeBin类" class="headerlink" title="TreeBin类"></a>TreeBin类</h3><p>TreeBins中使用的节点</p>
<pre><code class="java">static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; root;
    volatile TreeNode&lt;K,V&gt; first;
    // 锁的持有者
    volatile Thread waiter;
    // 锁状态
    volatile int lockState;
    // values for lockState
    // 表示持有写锁
    static final int WRITER = 1; // set while holding write lock
    // 表示等待
    static final int WAITER = 2; // set when waiting for write lock
    // 表示读锁的增量值
    static final int READER = 4; // increment value for setting read lock
...
</code></pre>
<p>与HashMap有点区别的是，他不直接使用TreeNode作为数的根节点，而是使用TreeBins对其做了装饰后成为了根节点；同时它还记录了锁的状态；需要注意的是：</p>
<ul>
<li>TreeBins节点的hash值是 -2</li>
<li>我们对红黑树添加节点后，红黑树的根节点有可能会因为旋转而发生变化，所以我们在添加树节点的时候在putTreeVal()方法里面我们使用cas在加了一次锁。</li>
</ul>
<h3 id="ForwardingNode-类"><a href="#ForwardingNode-类" class="headerlink" title="ForwardingNode 类"></a>ForwardingNode 类</h3><pre><code class="java">/**
 * A node inserted at head of bins during transfer operations.
 */
static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {
    final Node&lt;K,V&gt;[] nextTable;
    ForwardingNode(Node&lt;K,V&gt;[] tab) {
        super(MOVED, null, null, null);
        this.nextTable = tab;
    }

    Node&lt;K,V&gt; find(int h, Object k) {
        // loop to avoid arbitrarily deep recursion on forwarding nodes
        outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) {
            Node&lt;K,V&gt; e; int n;
            // 1. 判断新的数组是否是null，
            // 2. 如果不为NULL给那就找到对应索引位上的头结点
            // 3. 判断头节点是否为NULL
            if (k == null || tab == null || (n = tab.length) == 0 ||
                (e = tabAt(tab, (n - 1) &amp; h)) == null)
                return null;
            // 自旋找节点
            for (;;) {
                int eh; K ek;
                if ((eh = e.hash) == h &amp;&amp;
                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))
                    return e;
                if (eh &lt; 0) {
                    // 如果又变成了ForwardingNode标记节点，那说明有发生了扩容，需要跳出循环从新查找
                    if (e instanceof ForwardingNode) {
                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;
                        continue outer;
                    }
                    else
                        return e.find(h, k);
                }
                if ((e = e.next) == null)
                    return null;
            }
        }
    }
}
</code></pre>
<p>ForwardingNode 节点是一个扩容标记节点，只要在数组上发现对应索引位上是ForwardingNode 节点时，表示正在扩容。当get方法调用时，如果遇到ForwardingNode 节点，那么它将会到扩容后的数据上查找数据，否则还是在扩容前的数组上查找数据。这个要注意两点：</p>
<ul>
<li>这个节点的hash值是 -1</li>
<li>这个节点的find方法是在对扩容后的数组进行查找</li>
</ul>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="java">public ConcurrentHashMap18() {
}
</code></pre>
<p>与HashMap一样，构造函数啥都没干，初始化操作是在第一次put完成的。</p>
<h3 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put() 方法"></a>put() 方法</h3><pre><code class="java">public V put(K key, V value) {
        return putVal(key, value, false);
    }
</code></pre>
<h3 id="spread-方法"><a href="#spread-方法" class="headerlink" title="spread() 方法"></a>spread() 方法</h3><pre><code class="java">static final int spread(int h) {
        return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;
    }
</code></pre>
<p>计算key.hashCode（）并将更高位的散列扩展（XOR）降低。采用位运算主要是是加快计算速度。</p>
<h3 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal() 方法"></a>putVal() 方法</h3><pre><code class="java">/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    // 计算hash值
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node&lt;K,V&gt;[] tab = table;;) {
        Node&lt;K,V&gt; f; int n, i, fh;
        // 判断是否需要初始化
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        // 找出key对应的索引位上的第一个节点
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
            // 如果该索引位为null，则直接将数据放到该索引位
            if (casTabAt(tab, i, null,
                         new Node&lt;K,V&gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        // 正在扩容
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // 加内置锁锁定一个数组的索引位，并添加节点
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    // 表示链表节点
                    if (fh &gt;= 0) {
                        binCount = 1;
                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
                            K ek;
                            // key相同直接替换value值
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            // 将新节点添加到链表尾部
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    // 表示树节点
                    else if (f instanceof TreeBin) {
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        // 添加数节点
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                // 尝试将链表转换成红黑树
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
</code></pre>
<p>主要流程：</p>
<ul>
<li>计算key的hash值</li>
<li>判断是否需要初始化，如果是则调用initTable() 方法完成初始化</li>
<li>判断是否有hash冲突，如没有直接设置新节点到对饮索引位，如果有获取头结点</li>
<li>根据头结点的hash值判断是否正在扩容，如果是则帮助扩容</li>
<li>如果没有扩容则对头结点加锁，添加新节点</li>
<li>fh &gt;= 0根据头结点hash值判断是否是链表节点，如果是新增链表节点，否则新增树节点</li>
<li>新增树节点putTreeVal()需要注意，红黑树的根节点有可能会因为旋转而发生变化，所以我们在添加节点的时候还需要对根节点使用cas在加了一次锁。</li>
<li>判断是否需要尝试由链表转换成树结构</li>
<li>addCount(1L, binCount);新增count数，并判断是否需要扩容或者帮助扩容</li>
</ul>
<p>sizeCtl值含义：<br>-1:表示正在初始化<br>-n:表示正在扩容<br>0:表示还未初始化，默认值<br>大于0：表示下一次扩容的阈值</p>
<h3 id="initTable-初始化方法"><a href="#initTable-初始化方法" class="headerlink" title="initTable() 初始化方法"></a>initTable() 初始化方法</h3><pre><code class="java">private final Node&lt;K,V&gt;[] initTable() {
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        // 正在初始化
        if ((sc = sizeCtl) &lt; 0)
            // 让出CPU执行权，然后自旋
            Thread.yield(); // lost initialization race; just spin
        // CAS替换标志位（相当于获取锁）
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                // 二次判断
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    // 相当于sc=n*3/4
                    sc = n - (n &gt;&gt;&gt; 2); 
                }
            } finally {
                // 扩容阈值
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
</code></pre>
<p>主要过程：</p>
<ul>
<li>根据sizeCtl判断是否正在初始化</li>
<li>如果其他线程正在初始化就让出CPU执行权，进入下一次CPU执行权的竞争Thread.yield();</li>
<li>如果没有进行初始化的线程则，CAS替换sizeCtl标志位（相当于获取锁）</li>
<li>获取到锁后再次判断是否初始化</li>
<li>如果没有则初始化Node数组,并设置sizeCtl值为下一次扩容阈值</li>
</ul>
<h3 id="helpTransfer-帮助扩容"><a href="#helpTransfer-帮助扩容" class="headerlink" title="helpTransfer()帮助扩容"></a>helpTransfer()帮助扩容</h3><pre><code class="java">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {
    Node&lt;K,V&gt;[] nextTab; int sc;
    // ForwardingNode标记节点，表示正在扩容
    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;
        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {
        int rs = resizeStamp(tab.length);
        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;
               (sc = sizeCtl) &lt; 0) {
            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)
                break;
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                transfer(tab, nextTab);
                break;
            }
        }
        return nextTab;
    }
    return table;
}
</code></pre>
<p>判断是否正在扩容，如果是就帮助扩容。</p>
<h3 id="transfer-扩容方法"><a href="#transfer-扩容方法" class="headerlink" title="transfer() 扩容方法"></a>transfer() 扩容方法</h3><pre><code class="java">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {\
    // n原来数组长度
    int n = tab.length, stride;
    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; // subdivide range
    // 判断是发起扩容的线程还是帮助扩容的线程，如果是发起扩容的需要初始化新数组
    if (nextTab == null) {            // initiating
        try {
            @SuppressWarnings(&quot;unchecked&quot;)
            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
            nextTab = nt;
        } catch (Throwable ex) {      // try to cope with OOME
            sizeCtl = Integer.MAX_VALUE;
            return;
        }
        nextTable = nextTab;
        transferIndex = n;
    }
    int nextn = nextTab.length;
    // 扩容期间的数据节点（用于标志位，hash值是-1）
    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);
    // 当advance == true时，表明该节点已经处理过了
    boolean advance = true;
    // 在扩容完成之前保证get不被影响
    boolean finishing = false; // to ensure sweep before committing nextTab
    // 1. 从右往左找到第一个有数据的索引位节点（有hash冲突的桶）
    // 2. 如果找到的节点是NULL节点（没有hash冲突的节点），那么将该索引位的NULL替换成ForwardingNode标记节点，这个节点的hash是-1
    // 3. 如果找到不为NULL的节点（有hash冲突的桶），则对这个节点进行加锁
    // 4. 开始进进移动节点数据
    for (int i = 0, bound = 0;;) {
        //f:当前处理i位置的node（头结点或者根节点）;
        Node&lt;K,V&gt; f; int fh;
        // 通过while循环获取本次需要移动的节点索引i
        while (advance) {
            // nextIndex:下一个要处理的节点索引; nextBound:下一个需要处理的节点的索引边界
            int nextIndex, nextBound;
            // i是老数组索引位，通过--i来讲索引位往前一个索引位移动，直到0索引位
            if (--i &gt;= bound || finishing)
                advance = false;
            // 节点已全部转移
            else if ((nextIndex = transferIndex) &lt;= 0) {
                i = -1;
                advance = false;
            }
            // transferIndex（初值为最后一个节点的索引），表示从transferIndex开始后面所有的节点都已分配，
            // 每次线程领取扩容任务后，需要更新transferIndex的值(transferIndex-stride)。
            // CAS修改transferIndex，并更新索引边界
            else if (U.compareAndSwapInt
                     (this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex &gt; stride ?
                                   nextIndex - stride : 0))) {
                bound = nextBound;
                // 老数组最后一个索引位置
                i = nextIndex - 1;
                advance = false;
            }
        }
        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {
            int sc;
            // 已经完成所有节点复制了
            if (finishing) {
                nextTable = null;
                table = nextTab;
                // sizeCtl阈值为原来的1.5倍
                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);
                // 结束自旋
                return;
            }
            // CAS 更新扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
                    return;
                finishing = advance = true;
                i = n; // recheck before commit
            }
        }
        // 将以前老数组上为NULL的节点（还没有元素的桶或者说成没有hash冲突的数据节点），用ForwardingNode标记节点补齐
        // 主要作用是：其他线程在put元素，发现找到的索引位是fwd节点则表示正在扩容，那么该线程会来帮助扩通，而不是在那里等待
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);
        // 表示处理过该节点了
        else if ((fh = f.hash) == MOVED)
            advance = true; // already processed
        else {
            // 对应索引位加锁
            synchronized (f) {
                // 再次校验一下老数组对应索引位节点是否是我们找到的节点f
                if (tabAt(tab, i) == f) {
                    // 低索引位头节点(i位)， 高位索引位头节点（i+tab.length）
                    Node&lt;K,V&gt; ln, hn;
                    // fh &gt;=0 表示链表节点，TreeBin节点的hash值-2
                    if (fh &gt;= 0) {
                        // fh &amp; n算法可以算出新的节点该分配到那个索引位（runBit要么为0放低位ln，要么为n放高位hn），
                        // runBit表示链表中最后一个元素的hash值&amp;n的值
                        int runBit = fh &amp; n;
                        // lastRun表示链表中最后一个元素
                        Node&lt;K,V&gt; lastRun = f;
                        // 找到链表中最后一个节点，并赋值给lastRun
                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {
                            int b = p.hash &amp; n;
                            if (b != runBit) {
                                runBit = b;
                                lastRun = p;
                            }
                        }
                        // 判断原来的最后一个节点应该添加到高位还是低位
                        if (runBit == 0) {
                            ln = lastRun;
                            hn = null;
                        }
                        else {
                            hn = lastRun;
                            ln = null;
                        }
                        // f表示头结点，如果p不是尾节点，则转移节点
                        // 如果以前节点顺序是 1 2 3 4 转移后就是 3 2 1 4 
                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph &amp; n) == 0)
                                // 转移节点时都是新建节点,以免破坏原来数组结构影响get方法
                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);
                            else
                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);
                        }
                        // 设置新数组低索引位头节点(i位)
                        setTabAt(nextTab, i, ln);
                        // 设置新数组高位索引位头节点（i+tab.length）
                        setTabAt(nextTab, i + n, hn);
                        // 设置老数组i位为标记节点，表示已经处理过了
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                    else if (f instanceof TreeBin) {
                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;
                        TreeNode&lt;K,V&gt; lo = null, loTail = null;
                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;
                        int lc = 0, hc = 0;
                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {
                            int h = e.hash;
                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;
                                (h, e.key, e.val, null, null);
                            if ((h &amp; n) == 0) {
                                if ((p.prev = loTail) == null)
                                    lo = p;
                                else
                                    loTail.next = p;
                                loTail = p;
                                ++lc;
                            }
                            else {
                                if ((p.prev = hiTail) == null)
                                    hi = p;
                                else
                                    hiTail.next = p;
                                hiTail = p;
                                ++hc;
                            }
                        }
                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;
                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;
                        // 设置新数组低索引位头节点(i位)
                        setTabAt(nextTab, i, ln);
                        // 设置新数组高位索引位头节点（i+tab.length）
                        setTabAt(nextTab, i + n, hn);
                        // 设置老数组i位为标记节点，表示已经处理过了
                        setTabAt(tab, i, fwd);
                        advance = true;
                    }
                }
            }
        }
    }
}
</code></pre>
<p>主要过程：</p>
<ul>
<li>tab为扩容前的数组</li>
<li>判断是否是第一个发起扩容的线程，如果是需要初始化扩容后的数组nextTable</li>
<li>fwd = new ForwardingNode<k,v>(nextTab)初始化扩容标记节点</k,v></li>
<li>进入扩容循环</li>
<li>在扩容前的数组tab上从右往左（从高索引位到低索引位）遍历所有头结点，索引位为i</li>
<li>如果找到的头结点是NULL(没有hash冲突)则tab[i]=fwd。</li>
<li>找到的头结点不为NULL则（有hash冲突）则锁定头结点synchronized (f)</li>
<li>再次校验头结点是否发生改变，如果改变直接结束</li>
<li>初始化高索引位和第索引位的头结点</li>
<li>移动节点到相应索引位</li>
<li>设置扩容后的数组低索引位头节点(i位)</li>
<li>设置扩容后的数组高位索引位头节点（i+tab.length）</li>
<li>设置扩容前的数组i位为标记节点（tab[i]=fwd），表示已经处理过了</li>
<li>进入第3步直到完成</li>
</ul>
<p>注意：</p>
<ul>
<li>第5点有tab[i]=fwd有两层含义：1,表示对应索引位已经处理过了；2,当其他线程拿到该头结点的时候能知晓正在扩容，这时在put的时候帮助扩容，在get的时候去扩容后的数组上找相应的key</li>
<li>int runBit = fh &amp; n;算法可以算出新的节点该分配到那个索引位（runBit要么为0放低位ln，要么为n放高位hn）</li>
<li>如果是链表节点，以前节点顺序是 1 2 3 4 扩容后会变成 3 2 1 4</li>
</ul>
<p>扩容的大致过程图解：</p>
<ol>
<li>发起扩容，扩容前数组tab</li>
</ol>
<p><img src="https://i.loli.net/2020/11/25/WL3vCiXeB7tqyfU.png" alt="image.png"></p>
<ol>
<li>在扩容前的数组tab上从右往左（从高索引位到低索引位）遍历所有头结点，索引位为i，如果找到的头结点是NULL则直接赋值成<code>`fwd</code> 标记节点。</li>
</ol>
<p><img src="https://i.loli.net/2020/11/25/luVcF6AwN2TtaUK.png" alt="image.png"></p>
<ol>
<li>扩容前的数组上找到不为NULL的节点，则还是移动节点到扩容后的额数组</li>
</ol>
<p><img src="https://i.loli.net/2020/11/25/cZKgYvChXGIirf9.png" alt="image.png"></p>
<h3 id="addCount-方法"><a href="#addCount-方法" class="headerlink" title="addCount() 方法"></a>addCount() 方法</h3><pre><code class="java">private final void addCount(long x, int check) {
    // CounterCell[] as;使用计数器数组因该是为了提升并发量，减小冲突概率
    CounterCell[] as; long b, s;
    // 计数器表不为NULL（counterCells当修改baseCount有冲突时，需要将size增量放到这个计数器数组里面）
    if ((as = counterCells) != null ||
        // 使用CAS更新baseCount的值（+1）如果失败说明存在竞争
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        CounterCell a; long v; int m;
        // CounterCell是否存在竞争的标记位
        boolean uncontended = true;
        // CounterCell[] as为NULL表示as没有竞争
        if (as == null || (m = as.length - 1) &lt; 0 ||
            // 随机一个数组位置来验证是否为NULL，如果a是null表示没有竞争，随机也是为了减小冲突概率
            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||
            // CAS替换a的value，如果失败表示存在竞争
            !(uncontended =
              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            // 将size增量值存到as上
            fullAddCount(x, uncontended);
            return;
        }
        if (check &lt;= 1)
            return;
        // 统计size
        s = sumCount();
    }
    // 检查是否需要扩容
    if (check &gt;= 0) {
        Node&lt;K,V&gt;[] tab, nt; int n, sc;
        // size大于阈值sizeCtl，tab数组长度小于最大值1&lt;&lt;30
        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
               (n = tab.length) &lt; MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n);
            // 表示正在扩容
            if (sc &lt; 0) {
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &lt;= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    // 帮助扩容
                    transfer(tab, nt);
            }
            // sc = (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，移位后是负数
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                // 发起扩容，此时nextTable=null
                transfer(tab, null);
            s = sumCount();
        }
    }
}
</code></pre>
<p>在put()方法执行最后会对当前Map的size+1，ConcurrentHashMap中size由baseCount和CounterCell[] as组成，size=baseCount+as[i].value。addCount的大致过程如下：</p>
<ul>
<li>CAS替换baseCount值，如果失败说明对size的增量（size++）存在竞争</li>
<li>如果存在竞争，我们会使用到CounterCell[] as数组</li>
<li>as[ThreadLocalRandom.getProbe() &amp; m]随机取一个索引位，使用CAS完成size++</li>
<li>如果as[i]也存在竞争会调用fullAddCount(x, uncontended);方法完成size++</li>
<li>size++完成后通过size=baseCount+as[i].value公式计算出元素总数</li>
<li>判断是否需要扩容</li>
<li>如果需要扩容，在判断一下是帮助扩容还是发起扩容</li>
</ul>
<p>注意：</p>
<ul>
<li>CounterCell[] as：这个的只要目的是分散对baseCount的单一竞争，提示size++的并发率，这里和table数组一样使用了锁分离技术，as的长度也是2的n次方，初始长度是2</li>
<li>在第三步中使用随机数也是为了提升并发效率，ThreadLocalRandom类是JDK7在JUC包下新增的随机数生成器，它解决了Random类在多线程下，多个线程竞争内部唯一的原子性种子变量，而导致大量线程自旋重试的不足</li>
<li>fullAddCount(x, uncontended);方法里面完成了as的初始化和扩容</li>
<li>元素总数的计算公式是size=baseCount+as[i].value</li>
</ul>
<h3 id="sumCount-方法"><a href="#sumCount-方法" class="headerlink" title="sumCount() 方法"></a>sumCount() 方法</h3><pre><code class="java">final long sumCount() {
    CounterCell[] as = counterCells; CounterCell a;
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i &lt; as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
</code></pre>
<p>元素总数的计算公式是size=baseCount+as[i].value</p>
<h3 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get() 方法"></a>get() 方法</h3><pre><code class="java">public V get(Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
    int h = spread(key.hashCode());
    // table 不为NULL并且对饮索引位不为NULL
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (e = tabAt(tab, (n - 1) &amp; h)) != null) {
        if ((eh = e.hash) == h) {
            // 头节点key相同
            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                return e.val;
        }
        // 树节点或者ForwardingNode标记节点
        else if (eh &lt; 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        // 链表节点
        while ((e = e.next) != null) {
            // key相同
            if (e.hash == h &amp;&amp;
                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
</code></pre>
<p>主要流程：</p>
<ul>
<li>判断table和key对应索引位是否为NULL</li>
<li>判断头节点是否是要找的节点</li>
<li>eh &lt; 0表示是树节点或ForwardingNode标记节点，直接通过find方法找对应的key</li>
<li>否则是链表节点，挨个链表节点找相应的key</li>
<li>返回结果</li>
</ul>
<p>注意：</p>
<ul>
<li>get 方法没有加锁，原因是节点的value是volatile的，已经保证了可见性，只要value有更新，那么我们一定能读到最新数据。</li>
<li>e.find(h, key)这里：如果对应索引位头结点是ForwardingNode节点，那么会直接去扩通后的数组找对应的key，可以参见上面ForwardingNode.find()方法</li>
</ul>
<h3 id="size-方法-1"><a href="#size-方法-1" class="headerlink" title="size()方法"></a>size()方法</h3><pre><code class="java">public int size() {
    long n = sumCount();
    return ((n &lt; 0L) ? 0 :
            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
            (int)n);
}
</code></pre>
<h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>get方法和containsKey方法都是遍历对应索引位上所有节点，来判断是否存在key相同的节点以及获得该节点的value。但由于遍历过程中其他线程可能对链表结构做了调整，因此get和containsKey返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现。</p>
<h3 id="JDK1-8与JDK1-7的不同点"><a href="#JDK1-8与JDK1-7的不同点" class="headerlink" title="JDK1.8与JDK1.7的不同点"></a>JDK1.8与JDK1.7的不同点</h3><ul>
<li>去掉了Segment 数组：这样做锁的粒度更小，减少了并发冲突的概率；查找数据时不用计算两次hash；</li>
<li>存储数据是采用了链表+红黑树的形式：当一个桶内数据量很大的时候，红黑树的查询效率远高于链表。</li>
<li>1.8直接使用了内置锁synchronized：简化了加锁操作</li>
<li>1.8的初始化是在第一次put时完成的，1.7的时候再构造的时候完成的</li>
<li>在put过程中当发现正在扩容，1.8的线程会帮助扩容，1.7的只是会检查key是否存在或者完成新节点的初始化工作</li>
<li>1.8的hash值计算更简单了</li>
<li>1.8扩容过程中会修改扩容前的数组，1.7扩容过程中不会修改原来数组</li>
<li>1.8在get()时如果判断到当前索引位正在扩容，那么直接在扩容后的数组中去找对应的key</li>
<li>1.7的size计算使用的三次计算的方式，1.8使用了锁分离技术</li>
</ul>
<p>1、整体结构<br>1.7：Segment + HashEntry + Unsafe</p>
<p>1.8: 移除Segment，使锁的粒度更小，Synchronized + CAS + Node + Unsafe</p>
<p>2、put（）<br>1.7：先定位Segment，再定位桶，put全程加锁，没有获取锁的线程提前找桶的位置，并最多自旋64次获取锁，超过则挂起。</p>
<p>1.8：由于移除了Segment，类似HashMap，可以直接定位到桶，拿到first节点后进行判断，1、为空则CAS插入；2、为-1则说明在扩容，则跟着一起扩容；3、else则加锁put（类似1.7）</p>
<p>3、get（）<br>基本类似，由于value声明为volatile，保证了修改的可见性，因此不需要加锁。</p>
<p>4、resize（）<br>1.7：跟HashMap步骤一样，只不过是搬到单线程中执行，避免了HashMap在1.7中扩容时死循环的问题，保证线程安全。</p>
<p>1.8：支持并发扩容，HashMap扩容在1.8中由头插改为尾插（为了避免死循环问题），ConcurrentHashmap也是，迁移也是从尾部开始，扩容前在桶的头部放置一个hash值为-1的节点，这样别的线程访问时就能判断是否该桶已经被其他线程处理过了。</p>
<p>5、size（）<br>1.7：很经典的思路：计算两次，如果不变则返回计算结果，若不一致，则锁住所有的Segment求和。</p>
<p>1.8：用baseCount来存储当前的节点个数，这就设计到baseCount并发环境下修改的问题</p>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #757575;
            text-shadow: 0;
            display: none
        }
</style>
	
<div class="btn_click_load"> 
    <button class="disqus_click_btn">阅读评论（请确保 disqus 可以正常加载）</button>
</div>

<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://seanthefish.com/2020/11/24/juc-15/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://seanthefish.com/2020/11/24/juc-15/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/ls-javascript" id="disqus-lazy-load-script">
    $.ajax({
        url: 'https://disqus.com/next/config.json',
        timeout: 4000,
        type: 'GET',
        success: (function() {
            var d = document;
            var s = d.createElement('script');
            s.src = '//seanthefish.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
            $('.disqus_click_btn').css('display','none');
        })(),
        error: function() {
          $('.disqus_click_btn').css('display','block');
        }
    });
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//seanthefish.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.disqus_click_btn').css('display','none');
    });
</script>
  	

</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>

                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2020/11/25/juc-16/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2020/11/24/juc-14/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Sean Yu's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        a728976009@hotmail.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="mailto: a728976009@hotmail.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2020/12/">十二月 2020<span class="sidebar_archives-count">16</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/11/">十一月 2020<span class="sidebar_archives-count">46</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/07/">七月 2020<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/06/">六月 2020<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/05/">五月 2020<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/04/">四月 2020<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/11/">十一月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/11/">十一月 2018<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/09/">九月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/07/">七月 2018<span class="sidebar_archives-count">27</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/06/">六月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/04/">四月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/03/">三月 2018<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/12/">十二月 2017<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/Java-9/">Java 9<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/categories/OAuth/">OAuth<span class="sidebar_archives-count">31</span></a></li><li><a class="sidebar_archives-link" href="/categories/jpa/">jpa<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/jvm/">jvm<span class="sidebar_archives-count">8</span></a></li><li><a class="sidebar_archives-link" href="/categories/k8s/">k8s<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/mysql/">mysql<span class="sidebar_archives-count">9</span></a></li><li><a class="sidebar_archives-link" href="/categories/network/">network<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/nio/">nio<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/categories/raft/">raft<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/redis/">redis<span class="sidebar_archives-count">8</span></a></li><li><a class="sidebar_archives-link" href="/categories/spring/">spring<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/categories/台词/">台词<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/基础/">基础<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/并发/">并发<span class="sidebar_archives-count">23</span></a></li><li><a class="sidebar_archives-link" href="/categories/微服务/">微服务<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/设计模式/">设计模式<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Pages  -->
    
        <li>
            <a href="/about" title="关于我">
                
                    <i class="material-icons sidebar-material-icons">person</i>
                
                关于我
            </a>
        </li>
        
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/ShanyouYu-Sean" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    

    <!-- V2EX -->
    

    <!-- Segmentfault -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;<span year></span>&nbsp;小鱼肖恩
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?Bn9UzEm8RrBSxqyZB0zPjA==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>



    
        <script>lsloader.load("sm_js","/js/smoothscroll.js?lOy/ACj5suSNi7ZVFVbpFQ==", true)</script>
    







   <!-- 使用 DISQUS js 代码 -->






<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    var copyrightNow = new Date().getFullYear();
    var textContent = document.querySelector('span[year]')

    copyrightSince = 0000;
    if (copyrightSince === copyrightNow||copyrightSince === 0000) {
        textContent.textContent = copyrightNow
    } else {
        textContent.textContent = copyrightSince + ' - ' + copyrightNow
    }

    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.6 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
